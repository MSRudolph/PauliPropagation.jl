var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"TODO","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"TODO","category":"page"},{"location":"api/Surrogate/#Surrogate","page":"Surrogate","title":"Surrogate","text":"","category":"section"},{"location":"api/Surrogate/#Datatypes","page":"Surrogate","title":"Datatypes","text":"","category":"section"},{"location":"api/Surrogate/","page":"Surrogate","title":"Surrogate","text":"Modules = [PauliPropagation]\nPages = [\"src/Surrogate/datatypes.jl\"]","category":"page"},{"location":"api/Surrogate/#PauliPropagation.CircuitNode","page":"Surrogate","title":"PauliPropagation.CircuitNode","text":"Abstract node type for the Pauli propagation Surrogate \n\n\n\n\n\n","category":"type"},{"location":"api/Surrogate/#PauliPropagation.EvalEndNode","page":"Surrogate","title":"PauliPropagation.EvalEndNode","text":"EvalEndNode(pstr::Integer, coefficient::Real)\n\nNode type for the Pauli strings in the observable to be backpropagated.\n\n\n\n\n\n","category":"type"},{"location":"api/Surrogate/#PauliPropagation.EvalEndNode-Tuple{Integer}","page":"Surrogate","title":"PauliPropagation.EvalEndNode","text":"EvalEndNode(pstr::Integer)\n\nConstructor for EvalEndNode with a default coefficient of 1.0.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.NodePathProperties","page":"Surrogate","title":"PauliPropagation.NodePathProperties","text":"NodePathProperties(node::CircuitNode, nsins::Int, ncos::Int, freq::Int)\n\nSurrogate PathProperties type. Carries CircuitNodes instead of numerical coefficients.\n\n\n\n\n\n","category":"type"},{"location":"api/Surrogate/#PauliPropagation.NodePathProperties-Tuple{PauliPropagation.CircuitNode}","page":"Surrogate","title":"PauliPropagation.NodePathProperties","text":"NodePathProperties(node::CircuitNode)\n\nOne-argument constructor for NodePathProperties. Initializes nsins, ncos, and freq to 0.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.PauliRotationNode","page":"Surrogate","title":"PauliPropagation.PauliRotationNode","text":"PauliRotationNode(parents::Vector{Union{EvalEndNode,PauliRotationNode}}, trig_inds::Vector{Int}, signs::Vector{Int}, param_idx::Int)\n\nSurrogate graph node for a Pauli rotation gate.\n\n\n\n\n\n","category":"type"},{"location":"api/Surrogate/#Base.show-Tuple{IO, NodePathProperties}","page":"Surrogate","title":"Base.show","text":"Pretty print for PauliFreqTracker\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#Base.show-Tuple{IO, PauliPropagation.CircuitNode}","page":"Surrogate","title":"Base.show","text":"Pretty print for CircuitNode\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#Base.show-Tuple{IO, PauliPropagation.EvalEndNode}","page":"Surrogate","title":"Base.show","text":"Pretty print for EvalEndNode\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.set!-Union{Tuple{TT}, Tuple{Dict{TT, NodePathProperties}, TT, NodePathProperties}} where TT","page":"Surrogate","title":"PauliPropagation.set!","text":"set!(psum::Dict{TermType, NodePathProperties}, pstr::TermType, path::NodePathProperties)\n\nIn-place setting the coefficient of a Pauli string in a Pauli sum dictionary. The type of the Pauli string needs to be the keytype=TermType of the dictionary, and the coefficient coeff needs to be the valuetype=NodePathProperties. If the coefficient is 0, the Pauli string is removed from the dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.tonumber-Tuple{NodePathProperties}","page":"Surrogate","title":"PauliPropagation.tonumber","text":"tonumber(path::NodePathProperties)\n\nGet the cummulative coefficient of a NodePathProperties node. This assumes that the surrogate has already been evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.wrapcoefficients-Tuple{PauliString, Type{NodePathProperties}}","page":"Surrogate","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(pstr::PauliString, ::Type{NodePathProperties})\n\nWrap the coefficient of a PauliString into NodePathProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.wrapcoefficients-Tuple{PauliSum, Type{NodePathProperties}}","page":"Surrogate","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(psum::PauliSum, ::Type{NodePathProperties})\n\nWrap the coefficients of a PauliSum into NodePathProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#Evaluate","page":"Surrogate","title":"Evaluate","text":"","category":"section"},{"location":"api/Surrogate/","page":"Surrogate","title":"Surrogate","text":"Modules = [PauliPropagation]\nPages = [\"src/Surrogate/evaluate.jl\"]","category":"page"},{"location":"api/Surrogate/#PauliPropagation._traceevalorder-Tuple{PauliPropagation.EvalEndNode, Any}","page":"Surrogate","title":"PauliPropagation._traceevalorder","text":"_traceevalorder(node::EvalEndNode, thetas; eval_list=nothing)\n\nEvaluates the observable's coefficient.  This function likely does not need to be called manually.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation._traceevalorder-Tuple{PauliPropagation.PauliRotationNode, Any}","page":"Surrogate","title":"PauliPropagation._traceevalorder","text":"_traceevalorder(node::PauliRotationNode, thetas; eval_list=nothing)\n\nEvaluate the coefficient of node on the Surrogate by recursively evaluating all parents. thetas are the parameters of the circuit. NOTE: This requires calling resetnodes in-between evaluations with different thetas. eval_list does not need to be passed when manually using this function.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation._traceevalorder-Tuple{Vector{<:PauliPropagation.CircuitNode}, Any}","page":"Surrogate","title":"PauliPropagation._traceevalorder","text":"_traceevalorder(nodes::Vector{<:CircuitNode}, thetas)\n\nEvaluate the sum of coefficients of a vector of CircuitNode on the Surrogate.  This will be evaluated in parallel with recursive evaluation of the parents.  NOTE: This requires calling resetnodes in-between evaluations with different thetas.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.evaluate!-Union{Tuple{TT}, Tuple{PauliSum{TT, NodePathProperties}, Any}} where TT","page":"Surrogate","title":"PauliPropagation.evaluate!","text":"evaluate!(psum::PauliSum{TermType,NodePathProperties}, thetas)\n\nEvaluate the expectation value of a Surrogate by evaluating all involved circuit nodes in the correct order. eval_list can be attained as the output of gettraceevalorder()\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.expectation-Tuple{Vector{<:PauliPropagation.CircuitNode}, Any}","page":"Surrogate","title":"PauliPropagation.expectation","text":"expectation(eval_list::Vector{<:CircuitNode}, thetas)\n\nEvaluate the expectation value of a Surrogate by evaluating all involved circuit nodes in the correct order. eval_list can be attained as the output of gettraceevalorder()\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.gettraceevalorder-Tuple{PauliPropagation.CircuitNode, Any}","page":"Surrogate","title":"PauliPropagation.gettraceevalorder","text":"gettraceevalorder(node::CircuitNode, thetas)\n\nReturn a vector of CircuitNodes in the order they should be evaluated to get the correct cummulative result on node. thetas numerically plays no role here but it needs to be the correct length given the number of parametrized gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Tuple{PauliPropagation.CircuitNode}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(circuit_node::CircuitNode)\n\nReset a CircuitNode in a the Surrogate. Needs to be done in-between evaluatios with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Tuple{PauliPropagation.EvalEndNode}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(end_node::EvalEndNode)\n\nReset a EvalEndNode in a the Surrogate. Needs to be done in-between evaluatios with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Tuple{Vector{<:PauliPropagation.CircuitNode}}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(eval_list::Vector{<:CircuitNode})\n\nResets a vector of CircuitNodes.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Union{Tuple{PauliSum{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT<:NodePathProperties}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(psum::PauliSum{TermType, NodePathProperties})\n\nReset the nodes in a the Surrogate. Needs to be done in-between evaluatios with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#Propagate","page":"Surrogate","title":"Propagate","text":"","category":"section"},{"location":"api/Surrogate/","page":"Surrogate","title":"Surrogate","text":"Modules = [PauliPropagation]\nPages = [\"src/Surrogate/propagate.jl\"]","category":"page"},{"location":"api/Surrogate/#PauliPropagation.apply-Tuple{CliffordGate, Integer, NodePathProperties}","page":"Surrogate","title":"PauliPropagation.apply","text":"apply(gate::CliffordGate, pstr::PauliStringType, coeff::NodePathProperties)\n\nApply a CliffordGate to an integer Pauli string and NodePathProperties coefficient. \n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.propagate!-Union{Tuple{TT}, Tuple{Any, PauliSum{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.propagate!","text":"propagate!(circ, psum::PauliSum{PauliStringType,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliSum through the circuit circ in the Heisenberg picture.  The PauliSum psum is modified in place. The circuit must only contain CliffordGates and PauliRotations.  It is applied to the Pauli sum in reverse order, and the action of each gate is its conjugate action. The input psum will be modified. Default truncations are max_weight, max_freq, and max_sins. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.propagate-Union{Tuple{TT}, Tuple{Any, PauliString{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.propagate","text":"propagate(circ, pstr::PauliString{PauliStringType,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliString through the circuit circ in the Heisenberg picture.  The circuit must only contain CliffordGates and PauliRotations. It is applied to the Pauli string in reverse order, and the action of each gate is its conjugate action. Default truncations are max_weight, max_freq, and max_sins. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.propagate-Union{Tuple{TT}, Tuple{Any, PauliSum{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.propagate","text":"propagate(circ, psum::PauliSum{PauliStringType,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliSum through the circuit circ in the Heisenberg picture. The circuit must only contain CliffordGates and PauliRotations.  It is applied to the Pauli sum in reverse order, and the action of each gate is its conjugate action. Default truncations are max_weight, max_freq, and max_sins. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#Path-Properties","page":"Path Properties","title":"Path Properties","text":"","category":"section"},{"location":"api/PathProperties/#Pauli-frequency-tracker","page":"Path Properties","title":"Pauli frequency tracker","text":"","category":"section"},{"location":"api/PathProperties/","page":"Path Properties","title":"Path Properties","text":"Modules = [PauliPropagation]\nPages = [\"src/PathProperties/paulifreqtracker.jl\"]","category":"page"},{"location":"api/PathProperties/#PauliPropagation.PauliFreqTracker","page":"Path Properties","title":"PauliPropagation.PauliFreqTracker","text":"PauliFreqTracker(coeff::Number, nsins::Int, ncos::Int, freq::Int)\n\nWrapper type for numerical coefficients in Pauli propagation that records  the number of sin and cos factors applied via a PauliRotation gate, and the so-called frequency, which is their sum. It appears redundant but these three properties need to be tracked separately because of how merging affects them.\n\n\n\n\n\n","category":"type"},{"location":"api/PathProperties/#PauliPropagation.PauliFreqTracker-Tuple{Number}","page":"Path Properties","title":"PauliPropagation.PauliFreqTracker","text":"PauliFreqTracker(coeff::Number)\n\nConstructor for PauliFreqTracker from only a coefficient. Initializes nsins, ncos, and freq to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.applytoall!-Union{Tuple{PProp}, Tuple{TT}, Tuple{PauliRotation, Any, PauliSum{TT, PProp}, Any}} where {TT<:Integer, PProp<:PathProperties}","page":"Path Properties","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::PauliRotation, theta, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for PauliRotation gates acting onto Pauli sums with PathProperties coefficients. \n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#Abstract-type","page":"Path Properties","title":"Abstract type","text":"","category":"section"},{"location":"api/PathProperties/","page":"Path Properties","title":"Path Properties","text":"Modules = [PauliPropagation]\nPages = [\"src/PathProperties/abstracttype.jl\"]","category":"page"},{"location":"api/PathProperties/#PauliPropagation.PathProperties","page":"Path Properties","title":"PauliPropagation.PathProperties","text":"Abstract type for wrapping coefficients and record custom path properties\n\n\n\n\n\n","category":"type"},{"location":"api/PathProperties/#Base.:*-Union{Tuple{PProp}, Tuple{Number, PProp}} where PProp<:PathProperties","page":"Path Properties","title":"Base.:*","text":"Multiplication of a PathProperties object with a number. Requires that the PathProperties object has a coeff field defined which will be multiplied.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#Base.:*-Union{Tuple{PProp}, Tuple{PProp, Number}} where PProp<:PathProperties","page":"Path Properties","title":"Base.:*","text":"Multiplication of the coeff field in a PathProperties object with a number. Requires that the PathProperties object has a coeff field defined which will be multiplied.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#Base.:+-Union{Tuple{PProp}, Tuple{PProp, PProp}} where PProp<:PathProperties","page":"Path Properties","title":"Base.:+","text":"Addition of two PathProperties objects of equal concrete type. Adds the coeff fields and takes the minimum of the other fields. Requires that the PathProperties object has a coeff field defined.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#Base.float-Tuple{PProp} where PProp<:PathProperties","page":"Path Properties","title":"Base.float","text":"float(path::PathProperties)\n\nReturns an equivalent PathProperties object where float() is applied to the coeff field.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#Base.show-Union{Tuple{PProp}, Tuple{IO, PProp}} where PProp<:PathProperties","page":"Path Properties","title":"Base.show","text":"Pretty print for PathProperties\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.tonumber-Tuple{PProp} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.tonumber","text":"tonumber(path::PathProperties)\n\nGet the numerical coefficient of a PathProperties wrapper.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.wrapcoefficients-Union{Tuple{PProp}, Tuple{PauliString, Type{PProp}}} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(pstr::PauliString, PathPropertiesType<:PathProperties)\n\nWrap the coefficient of a PauliString into a custom PathProperties type. For anything that is not natively supported by the library, you can subtype PathProperties. A one-argument constructor of the custom PathProperties type from a coefficient must be defined.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.wrapcoefficients-Union{Tuple{PProp}, Tuple{PauliSum, Type{PProp}}} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(psum::PauliSum, PathPropertiesType<:PathProperties)\n\nWrap the coefficients of a PauliSum into a custom PathProperties type. For anything that is not natively supported by the library, you can subtype PathProperties. A one-argument constructor of the custom PathProperties type from a coefficient must be defined.\n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#Truncations","page":"Truncations","title":"Truncations","text":"","category":"section"},{"location":"api/Truncations/","page":"Truncations","title":"Truncations","text":"Modules = [PauliPropagation]\nPages = [\"src/truncations.jl\"]","category":"page"},{"location":"api/Truncations/#PauliPropagation.truncatedampingcoeff-Tuple{Integer, Any, Real, Real}","page":"Truncations","title":"PauliPropagation.truncatedampingcoeff","text":"truncatedampingcoeff(\n    pstr::PauliStringType, \n    coeff::Real, \n    gamma::Real, \n    min_abs_coeff::Float64\n)\n\nCustom truncation function with dissipation-assisted damping of coefficients.\n\nThis function damps the coefficient coeff scaling with the weight of an interger Pauli string pstr.  The damping factor is gamma.  If the coefficient, damped by an exponential factor, falls below min_abs_coeff,  the function returns true to indicate truncation.\n\nArguments\n\npstr::PauliStringType: The Pauli string whose coefficient may be damped.\ncoeff::Float64: The coefficient associated with the Pauli string pstr.\ngamma::Float64: Gamma, rate of exponential decay in the damping process.\nmin_abs_coeff::Float64: The minimum value of the coefficient for truncation.\n\nReturns\n\nBool: true if the damped coefficient of pstr < min_abs_coeff;   false otherwise.\n\nDetails\n\nThe function evaluates the condition: abs(coeff) * exp(-gamma * w(pstr)) < min_abs_coeff\n\nwhere w(pstr) is the weight of the Pauli string (computed by countweight).  The damping factor gamma controls the exponential decay.\n\nExamples\n\n```julia truncatedampingcoeff(pstr, 0.8, 0.5, 0.01)\n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#PauliPropagation.truncatefrequency-Tuple{Any, Real}","page":"Truncations","title":"PauliPropagation.truncatefrequency","text":"truncatefrequency(coeff, max_freq::Real)\n\nReturn true if  PathProperties.freq > max_freq. Truncations on coefficients should default to false if it is not applicable for a type.\n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#PauliPropagation.truncatefrequency-Union{Tuple{PProp}, Tuple{PProp, Real}} where PProp<:PathProperties","page":"Truncations","title":"PauliPropagation.truncatefrequency","text":"truncatefrequency(path_properties::PathProperties, max_freq::Real)\n\nReturn true if  path_properties.freq > max_freq.\n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#PauliPropagation.truncatemincoeff-Tuple{Any, Real}","page":"Truncations","title":"PauliPropagation.truncatemincoeff","text":"truncatemincoeff(coeff, min_abs_coeff::Real)\n\nReturn true if abs(coeff) < min_abs_coeff. Truncations on coefficients should default to false if it is not applicable for a type.\n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#PauliPropagation.truncatemincoeff-Tuple{Real, Real}","page":"Truncations","title":"PauliPropagation.truncatemincoeff","text":"truncatemincoeff(coeff::Float64, min_abs_coeff::Real)\n\nReturn true if abs(coeff) < min_abs_coeff. \n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#PauliPropagation.truncatemincoeff-Union{Tuple{PProp}, Tuple{PProp, Real}} where PProp<:PathProperties","page":"Truncations","title":"PauliPropagation.truncatemincoeff","text":"truncatemincoeff(path_property::PathProperties, min_abs_coeff::Real)\n\nReturn true if abs(path_property.coeff) < min_abs_coeff. \n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#PauliPropagation.truncatesins-Tuple{Any, Real}","page":"Truncations","title":"PauliPropagation.truncatesins","text":"truncatesins(coeff, max_sins::Real)\n\nReturn true if  PathProperties.nsins > max_sins. Truncations on coefficients should default to false if it is not applicable for a type.\n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#PauliPropagation.truncatesins-Union{Tuple{PProp}, Tuple{PProp, Real}} where PProp<:PathProperties","page":"Truncations","title":"PauliPropagation.truncatesins","text":"truncatesins(path_properties::PathProperties, max_sins::Real)\n\nReturn true if  path_properties.nsins > max_sins.\n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#PauliPropagation.truncateweight-Tuple{Integer, Real}","page":"Truncations","title":"PauliPropagation.truncateweight","text":"truncateweight(pstr::PauliStringType, max_weight::Real)\n\nReturn true if an integer Pauli string should be truncated because its weight (i.e., number of non-identity Paulis) is larger than max_weight. \n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#State-Overlap","page":"State Overlap","title":"State Overlap","text":"","category":"section"},{"location":"api/StateOverlap/","page":"State Overlap","title":"State Overlap","text":"Modules = [PauliPropagation]\nPages = [\"src/stateoverlap.jl\"]","category":"page"},{"location":"api/StateOverlap/#PauliPropagation.filter!-Union{Tuple{F}, Tuple{PauliSum, F}} where F<:Function","page":"State Overlap","title":"PauliPropagation.filter!","text":"filter!(psum::PauliSum, filterfunc::Function)\n\nFilter a PauliSum in-place by removing all Pauli strings that satisfy the filterfunc.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.filter-Union{Tuple{F}, Tuple{PauliSum, F}} where F<:Function","page":"State Overlap","title":"PauliPropagation.filter","text":"filter(psum::PauliSum, filterfunc::Function)\n\nReturn a filtered PauliSum by removing all Pauli strings that satisfy the filterfunc.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.orthogonaltoplus-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.orthogonaltoplus","text":"orthogonaltoplus(pstr)\n\nCalculates the overlap of a Pauli string with the plus state |+><+|\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.orthogonaltozero-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.orthogonaltozero","text":"overlapwithzero(pstr)\n\nCalculates the overlap of a Pauli string with the zero state |0><0|\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapbyorthogonality-Union{Tuple{F}, Tuple{Integer, F}} where F<:Function","page":"State Overlap","title":"PauliPropagation.overlapbyorthogonality","text":"overlapbyorthogonality(pstr::PauliString, orthogonalfunc::Function)\n\nOverlap an integer Pauli string with a state or operator via function that returns true if the Pauli string is orthogonal and hence has overlap 0.  An example orthogonalfunc is containsXorY which returns true if the Pauli string contains an X or Y Pauli. If not orthogonal, then the overlap is 1. This is particularly useful for overlaps with stabilizer states.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapbyorthogonality-Union{Tuple{F}, Tuple{PauliString, F}} where F<:Function","page":"State Overlap","title":"PauliPropagation.overlapbyorthogonality","text":"overlapbyorthogonality(pstr::PauliString, orthogonalfunc::Function)\n\nOverlap a PauliString with a state or operator via function that returns true if the PauliString is orthogonal and hence has overlap 0.  An example orthogonalfunc is containsXorY which returns true if the PauliString contains an X or Y Pauli. If not orthogonal, then the overlap is the coefficient of the PauliString. This is particularly useful for overlaps with stabilizer states.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapbyorthogonality-Union{Tuple{F}, Tuple{PauliSum, F}} where F<:Function","page":"State Overlap","title":"PauliPropagation.overlapbyorthogonality","text":"overlapbyorthogonality(psum::PauliSum, orthogonalfunc::Function)\n\nOverlap a PauliSum with a state or operator via function that returns true if a Pauli string is orthogonal and hence doesn't contribute. An example orthogonalfunc is containsXorY which returns true if a Pauli string contains an X or Y Pauli. If not orthogonal, then a Pauli string contributes with its coefficient. This is particularly useful for overlaps with stabilizer states.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithcomputational-Tuple{PauliString, Any}","page":"State Overlap","title":"PauliPropagation.overlapwithcomputational","text":"overlapwithcomputational(pstr::PauliString, onebitinds)\n\nCalculates the overlap of a Pauli string with the computational basis state which has one-bits at all specified onebitinds and zero-bits elsewhere. For example, overlapwithcomputational(pstr, [1,2,4]) returns the overlap with |1101000...> and will be either zero or plus/minus pstr.coeff.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithcomputational-Tuple{PauliSum, Any}","page":"State Overlap","title":"PauliPropagation.overlapwithcomputational","text":"overlapwithcomputational(psum::PauliSum, onebitinds)\n\nCalculates the overlap of a Pauli sum with the computational basis state which has one-bits at all specified indices and zero-bits elsewhere. For example, overlapwithcomputational(psum, [1,2,4]) returns the overlap with |1101000...>\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithmaxmixed-Union{Tuple{PauliSum{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT}","page":"State Overlap","title":"PauliPropagation.overlapwithmaxmixed","text":"overlapwithmaxmixed(psum::PauliSum)\n\nCalculates the overlap of a PauliSum with the maximally mixed state 1/2^n I.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithpaulisum-Tuple{PauliSum, PauliSum}","page":"State Overlap","title":"PauliPropagation.overlapwithpaulisum","text":"overlapwithpaulisum(psum1::PauliSum, psum2::PauliSum)\n\nCalculates the overlap between two PauliSums. Important: We assume 'normalized' Pauli strings, i.e. such that Tr[P^2] = 1 for any n-qubit Pauli string P. If one Pauli sum represents e.g. a normalized quantum state, the result will need to be scaled by 2^n.  \n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithplus-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.overlapwithplus","text":"overlapwithplus(psum)\n\nCalculates the overlap of a Pauli sum with the plus state |+><+|\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithzero-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.overlapwithzero","text":"overlapwithzero(psum)\n\nCalculates the overlap of a Pauli sum with the zero state |0><0|\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.plusfilter!-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.plusfilter!","text":"zerofilter!(psum)\n\nFilter a Pauli sum in-place with only Pauli strings that are not orthogonal to the plus state |+><+|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.plusfilter-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.plusfilter","text":"plusfilter(psum)\n\nReturn a filtered Pauli sum with only Pauli strings that are not orthogonal to the plus state |+><+|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.zerofilter!-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.zerofilter!","text":"zerofilter!(psum)\n\nFilter a Pauli sum in-place with only Pauli strings that are not orthogonal to the zero state |0><0|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.zerofilter-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.zerofilter","text":"zerofilter(psum)\n\nReturn a filtered Pauli sum with only Pauli strings that are not orthogonal to the zero state |0><0|.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#Circuits","page":"Circuits","title":"Circuits","text":"","category":"section"},{"location":"api/Circuits/#Builders","page":"Circuits","title":"Builders","text":"","category":"section"},{"location":"api/Circuits/","page":"Circuits","title":"Circuits","text":"Modules = [PauliPropagation]\nPages = [\"src/Circuits/builders.jl\"]","category":"page"},{"location":"api/Circuits/#PauliPropagation.appendSU4!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.appendSU4!","text":"appendSU4!(circuit, pair)\n\nAppend a layer of SU(4) gates to a circuit on a given pair of qubits. The SU(4) gate is decomposed via the KAK Decomposition into single-qubit Z-X-Z gates on each qubit, followed by XX-YY-ZZ gates and again single-qubit Z-X-Z gates, for a total of 15 Pauli gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.efficientsu2circuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.efficientsu2circuit","text":"efficientsu2circuit(nqubits::Integer, nlayers::Integer; topology=nothing)\n\nCreate a hardware-efficient circuit consisting of layers of single-qubit Y-Z Pauli gates and CNOT entangling gates. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.hardwareefficientcircuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.hardwareefficientcircuit","text":"hardwareefficientcircuit(nqubits::Integer, nlayers::Integer; topology=nothing)\n\nCreate a hardware-efficient circuit consisting of layers of single-qubit X-Z-X Pauli gates and YY entangling gates. A topology can be specified as a list of pairs of qubit indices.  If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.heisenbergtrottercircuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.heisenbergtrottercircuit","text":"heisenbergtrottercircuit(nqubits::Integer, nlayers::Integer; topology=nothing)\n\nCreate a circuit that corresponds to a Trotterization of the Heisenberg Hamiltonian. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used. Note that the gates are applied as layers of XX-YY-ZZ gates, not as layers of XX on all, then YY on all, then ZZ on all. On the bricklayer topology, these are equivalent.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.qcnncircuit-Tuple{Integer}","page":"Circuits","title":"PauliPropagation.qcnncircuit","text":"qcnncircuit(nqubits::Integer; periodic=false)\n\nCreate a Quantum Convolutional Neural Network (QCNN) circuit on nqubits qubits. The topology for the circuit is created by creating bricklayer topologies on half the qubits every layer. The final qubits are qubit 1 and ~nqubits/2, which should be measured.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rxlayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.rxlayer!","text":"rxlayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:X, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rxxlayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.rxxlayer!","text":"rxxlayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:X, :X], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rylayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.rylayer!","text":"rylayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:Y, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.ryylayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.ryylayer!","text":"ryylayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:Y, :Y], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rzlayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.rzlayer!","text":"rzlayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:Z, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rzzlayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.rzzlayer!","text":"rzzlayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:Z, :Z], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.su4circuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.su4circuit","text":"su4circuit(nqubits::Integer, nlayers::Integer; topology=nothing)\n\nCreate a circuit that consists of layers of SU(4) gates on a given topology.  SU(4) gates are decomposed via the KAK Decomposition into single-qubit Z-X-Z gates on each qubit, followed by XX-YY-ZZ gates and again single-qubit Z-X-Z gates, for a total of 15 Pauli gates. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.tfitrottercircuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.tfitrottercircuit","text":"tfitrottercircuit(nqubits::Integer, nlayers::Integer; topology=nothing, start_with_ZZ=true)\n\nCreate a circuit that corresponds to a Trotterization of the transverse-field Ising Hamiltonian.  A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used. If start_with_ZZ is set to true, the circuit starts with a layer of ZZ gates, else with a layer of X gates. This is relevant depending on the initial state.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.tiltedtfitrottercircuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.tiltedtfitrottercircuit","text":"tiltedtfitrottercircuit(nqubits, n_layers; topology=nothing)\n\nReturns a Trottterized circuit for the tilted transverse field Ising model. H = Sum{(i, i+1) in topology} Zi Z_{i+1} \n\nSum{i=1}^{nqubits} Zi + Sum{i=1}^{nqubits} Xi\n\nArguments\n\nnqubits::Integer: The number of qubits in the circuit.\nn_layers::Integer: The number of Trotter steps to perform.\ntopology=nothing: The topology of the qubits in the circuit.    Default (nothing): A linear chain.\n\nReturns\n\nThe Trottterized circuit as a vector of Gate.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#Topologies","page":"Circuits","title":"Topologies","text":"","category":"section"},{"location":"api/Circuits/","page":"Circuits","title":"Circuits","text":"Modules = [PauliPropagation]\nPages = [\"src/Circuits/topologies.jl\"]","category":"page"},{"location":"api/Circuits/#PauliPropagation.ibmeagletopology","page":"Circuits","title":"PauliPropagation.ibmeagletopology","text":"ibmeagletopology\n\nTopology of the IBM Eagle device with 127 qubits. Also called the heave-hex topology on 127 qubits.\n\n\n\n\n\n","category":"constant"},{"location":"api/Circuits/#PauliPropagation.bricklayertopology-Tuple{Any}","page":"Circuits","title":"PauliPropagation.bricklayertopology","text":"bricklayertopology(qindices; periodic=false)\n\nCreate the topology of a so-called 1D bricklayer circuit on a subset of qubits indicated by qindices. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.bricklayertopology-Tuple{Integer}","page":"Circuits","title":"PauliPropagation.bricklayertopology","text":"bricklayertopology(nqubits::Integer; periodic=false)\n\nCreate the topology of a so-called 1D bricklayer circuit on nqubits qubits. It consists of two sublayers connecting odd-even and eve-odd qubit indices, respectively. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rectangletopology-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.rectangletopology","text":"rectangletopology(nx::Integer, ny::Integer; periodic=false)\n\nCreate a 2D topology on a grid of nx by ny qubits. The order is none in particular and may need to be adapted for specific purposes. If periodic is set to true, the grid is connected periodically in both directions.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.staircasetopology-Tuple{Integer}","page":"Circuits","title":"PauliPropagation.staircasetopology","text":"staircasetopology(nqubits::Integer; periodic=false)\n\nCreate a 1D staircase topology on nqubits qubits. The qubits are connected in a staircase pattern, where qubit i is connected to qubit i+1. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.staircasetopology2d-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.staircasetopology2d","text":"staircasetopology2d(nx::Integer, ny::Integer)\n\nCreate a 2D staircase topology on a grid of nx by ny qubits. Mind the order of the topology, which forms a staircase spanning the grid -> in the Schrödinger picture <-.  An observable acting on qubits index nqubits may interact non-trivially with every gate on the topology.  Can topology can either be pathological or the most simple, depending on which index observables are non-identity.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#Utils","page":"Circuits","title":"Utils","text":"","category":"section"},{"location":"api/Circuits/","page":"Circuits","title":"Circuits","text":"Modules = [PauliPropagation]\nPages = [\"src/Circuits/utils.jl\"]","category":"page"},{"location":"api/Circuits/#PauliPropagation.countparameters-Tuple{Any}","page":"Circuits","title":"PauliPropagation.countparameters","text":"countparameters(circuit)\n\nUtility function to count the number of gates of type ParametrizedGate in a circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Tuple{Any, Type{PauliRotation}, Vector{Symbol}, Vector{Int64}}","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, ::PauliRotation, gate_symbols::Vector{Symbol}), qinds::Vector{Int})\n\nUtility function to get the parameter indices of PauliRotation gates with symbol gate_symbols acting on the qubits qinds. For example, getparameterindices(circuit, PauliRotation, [:X], [1]).\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Tuple{Any, Type{PauliRotation}, Vector{Symbol}}","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, ::PauliRotation, gate_symbols::Vector{Symbol}))\n\nUtility function to get the parameter indices of PauliRotation gates with symbol gate_symbols. For example, getparameterindices(circuit, PauliRotation, [:X]).\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Union{Tuple{GT}, Tuple{Any, Type{GT}}} where GT<:ParametrizedGate","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, GateType<:ParametrizedGate)\n\nUtility function to get the parameter indices of gates of type GateType in a circuit. This naturally only works for gates that subtype ParametrizedGate.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#Propagation","page":"Propagation","title":"Propagation","text":"","category":"section"},{"location":"api/Propagation/#Generics","page":"Propagation","title":"Generics","text":"","category":"section"},{"location":"api/Propagation/","page":"Propagation","title":"Propagation","text":"Modules = [PauliPropagation]\nPages = [\"src/Propagation/generics.jl\"]","category":"page"},{"location":"api/Propagation/#Base.mergewith!-Union{Tuple{CT}, Tuple{TT}, Tuple{Any, PauliSum{TT, CT}, PauliSum{TT, CT}}} where {TT, CT}","page":"Propagation","title":"Base.mergewith!","text":"mergewith!(merge, psum::PauliSum{TermType, CoeffType}, aux_psum::PauliSum{TermType, CoeffType})\n\nMerge two PauliSums using the merge function on the coefficients. merge can be overloaded for different coefficient types.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.apply-Union{Tuple{SG}, Tuple{SG, Any, Any, Any}} where SG<:StaticGate","page":"Propagation","title":"PauliPropagation.apply","text":"apply(gate::StaticGate, pstr, coeff, theta)\n\nCalling apply on a StaticGate will dispatch to a 3-argument apply function without the paramter theta. If a 4-argument apply function is defined for a concrete type, it will still dispatch to that one. See the 4-custom-gates.ipynb for examples of how to define custom gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applyandadd!-NTuple{5, Any}","page":"Propagation","title":"PauliPropagation.applyandadd!","text":"applyandadd!(gate, pstr, coefficient, theta, output_psum; kwargs...)\n\n3rd-level function below applymergetruncate! that applies one gate to one Pauli string in psum, moving results into output_psum by default. This function can be overwritten for a custom gate if the lower-level function apply is not sufficient.  This is likely the the case if apply is not type-stable because it does not return a unique number of outputs.  E.g., a Pauli gate returns 1 or 2 (pstr, coefficient) outputs. See the 4-custom-gates.ipynb for examples of how to define custom gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applymergetruncate!-NTuple{5, Any}","page":"Propagation","title":"PauliPropagation.applymergetruncate!","text":"applymergetruncate!(gate, psum, aux_psum, thetas, param_idx; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\n1st-level function below propagate! that applies one gate to all Pauli strings in psum, potentially using aux_psum in the process, and merges everything back into psum. Truncations are checked here after merging. This function can be overwritten for a custom gate if the lower-level functions applytoall!, applyandadd!, and apply are not sufficient.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-NTuple{4, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate, theta psum, output_psum; kwargs...)\n\n2nd-level function below applymergetruncate! that applies one gate to all Pauli strings in psum, moving results into output_psum by default. After this functions, Pauli strings in remaining in psum and output_psum are merged. This function can be overwritten for a custom gate if the lower-level functions applyandadd! and apply are not sufficient. In particular, this function can be used to manipulate both psum and output_psum at the same time to reduce memory movement. Note that manipulating psum on anything other than the current Pauli string will likely lead to errors. See the 4-custom-gates.ipynb for examples of how to define custom gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.checktruncationonall!-Tuple{Any}","page":"Propagation","title":"PauliPropagation.checktruncationonall!","text":"checktruncationonall!(psum; max_weight::Real=Inf, min_abs_coeff=1e-10, max_freq::Real=Inf, max_sins::Real=Inf, kwargs...)\n\nCheck truncation conditions on all Pauli strings in psum and remove them if they are truncated. This function supports the default truncations based on max_weight, min_abs_coeff, max_freq, and max_sins. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.checktruncationonone!-Tuple{Any, Any, Any}","page":"Propagation","title":"PauliPropagation.checktruncationonone!","text":"checktruncationonone!(\npsum, pstr, coeff;\nmax_weight::Real=Inf, min_abs_coeff=1e-10,\nmax_freq::Real=Inf, max_sins::Real=Inf,\ncustomtruncfunc=nothing,\nkwargs...\n\nCheck truncation conditions one Pauli string in psum and it them if it is truncated. This function supports the default truncations based on max_weight, min_abs_coeff, max_freq, and max_sins. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.merge-Tuple{Any, Any}","page":"Propagation","title":"PauliPropagation.merge","text":"merge(val1, val2)\n\nMerging two coefficients calls + by default unless there exists a suitable overloaded merge function.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.mergeandempty!-Tuple{Any, Any}","page":"Propagation","title":"PauliPropagation.mergeandempty!","text":"mergeandempty!(psum, aux_psum)\n\nMerge aux_psum into psum using the merge function. merge can be overloaded for different coefficient types. Then empty aux_psum for the next iteration.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.propagate","page":"Propagation","title":"PauliPropagation.propagate","text":"propagate(circ, psum::PauliSum, thetas=nothing; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nPropagate a PauliSum through the circuit circ in the Heisenberg picture.  This means that the circuit is applied to the Pauli sum in reverse order, and the action of each gate is its conjugate action. Parameters for the parametrized gates in circ are given by thetas, and need to be passed as if the circuit was applied as written in the Schrödinger picture. If thetas are not passed, the circuit must contain only non-parametrized StaticGates. Default truncations are max_weight, min_abs_coeff, max_freq, and max_sins. max_freq, and max_sins can only be used with PauliFreqTracker coefficients. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#PauliPropagation.propagate-2","page":"Propagation","title":"PauliPropagation.propagate","text":"propagate(circ, pstr::PauliString, thetas=nothing; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nPropagate a PauliString through the circuit circ in the Heisenberg picture.  This means that the circuit is applied to the Pauli string in reverse order, and the action of each gate is its conjugate action. Parameters for the parametrized gates in circ are given by thetas, and need to be passed as if the circuit was applied as written in the Schrödinger picture. If thetas are not passed, the circuit must contain only non-parametrized StaticGates. Default truncations are max_weight, min_abs_coeff, max_freq, and max_sins. max_freq, and max_sins can only be used with PauliFreqTracker coefficients. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#PauliPropagation.propagate!","page":"Propagation","title":"PauliPropagation.propagate!","text":"propagate!(circ, psum::PauliSum, thetas=nothing; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nPropagate a Pauli sum  through the circuit circ in the Heisenberg picture.  This means that the circuit is applied to the Pauli sum in reverse order, and the action of each gate is its conjugate action. The input psum will be modified. Parameters for the parametrized gates in circ are given by thetas, and need to be passed as if the circuit was applied as written in the Schrödinger picture. If thetas are not passed, the circuit must contain only non-parametrized StaticGates. Default truncations are max_weight, min_abs_coeff, max_freq, and max_sins. max_freq, and max_sins can only be used with PauliFreqTracker coefficients. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#Specializations","page":"Propagation","title":"Specializations","text":"","category":"section"},{"location":"api/Propagation/","page":"Propagation","title":"Propagation","text":"Modules = [PauliPropagation]\nPages = [\"src/Propagation/specializations.jl\"]","category":"page"},{"location":"api/Propagation/#PauliPropagation.apply-Tuple{CliffordGate, Integer, Any}","page":"Propagation","title":"PauliPropagation.apply","text":"apply(gate::CliffordGate, pstr::PauliStringType, coeff)\n\nApply a CliffordGate to an integer Pauli string and its coefficient. \n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.apply-Tuple{TransferMapGate, Any, Any}","page":"Propagation","title":"PauliPropagation.apply","text":"apply(gate::TransferMapGate, pstr, coeff)\n\nApply a TransferMapGate to an integer Pauli string and its coefficient. The outcomes are determined by the transfer_map of the gate.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applyandadd!-Tuple{CliffordGate, Vararg{Any, 4}}","page":"Propagation","title":"PauliPropagation.applyandadd!","text":"applyandadd!(gate::CliffordGate, pstr, coeff, theta, output_psum; kwargs...)\n\nOverload of applyandadd! for CliffordGate gates. Use set!() instead of add!() because Clifford gates create non-overlapping Pauli strings. applytoall! does not need to be adapted.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{AmplitudeDampingNoise, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::AmplitudeDampingNoise, theta, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for AmplitudeDampingNoise gates.  It fixes the type-instability of the apply() function and reduces moving Pauli strings between psum and auxpsum. psum and `auxpsum` are merged later.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{FrozenGate, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::FrozenGate, thetas, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for FrozenGates. Re-directs to applytoall! for the wrapped FrozenGate.gate with the frozen parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{PauliNoise, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::PauliNoise, p, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for PauliNoise gates with noise strength p.  It changes the coefficients in-place and does not require the aux_psum, which stays empty.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{PauliRotation, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::PauliRotation, theta, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for PauliRotation gates.  It fixes the type-instability of the apply() function and reduces moving Pauli strings between psum and aux_psum. psum and aux_psum are merged later.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{TGate, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::TGate, thetas, psum, aux_psum; kwargs...)\n\nOverload of applytoall!() for TGate(qind). Redirects to a PauliRotation(:Z, qind) with angle π/4.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.getnewpaulistring-Tuple{MaskedPauliRotation, Integer}","page":"Propagation","title":"PauliPropagation.getnewpaulistring","text":"getnewpaulistring(gate::MaskedPauliRotation, pstr::PauliStringType)\n\nGet the new Pauli string after applying a MaskedPauliRotation to an integer Pauli string, as well as the corresponding ±1 coefficient.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliTransferMatrix/#Pauli-Transfer-Matrix","page":"Pauli Transfer Matrix","title":"Pauli Transfer Matrix","text":"","category":"section"},{"location":"api/PauliTransferMatrix/#Matrices","page":"Pauli Transfer Matrix","title":"Matrices","text":"","category":"section"},{"location":"api/PauliTransferMatrix/","page":"Pauli Transfer Matrix","title":"Pauli Transfer Matrix","text":"Modules = [PauliPropagation]\nPages = [\"src/PauliTransferMatrix/matrices.jl\"]","category":"page"},{"location":"api/PauliTransferMatrix/#PauliPropagation.calculateptm-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Number","page":"Pauli Transfer Matrix","title":"PauliPropagation.calculateptm","text":"function calculateptm(mat; tol=1e-15, heisenberg=true)\nfunction calculateptm(dtype, mat; tol=1e-15, heisenberg=true)\n\nCalculate the Pauli Transfer Matrix (PTM) of a matrix mat.  The PTM will be real-valued in the Pauli basis. However, it can be complex in a general basis. Pass an optional data type dtype when entries are not floats. We truncate small complex components and abs values in the PTM using the tol parameter. Note, by default the PTM is calculated in the -> Heisenberg picture <-,  i.e., the PTM is that of the conjugate transpose of the  matrix. This can be changed via the heisenberg::Bool keyword argument. Arguments\n\nmat::Matrix: The evolutioin gate matrix for which the PTM is calculated.\ntol::Float64=1e-15: The tolerance for dropping small values in the PTM.\nheisenberg::Bool=true: Whether the PTM is calculated in the Heisenberg picture. \ndtype::DataType: Default type for a real PTM is Float64.\n\nReturns\n\nptm::Matrix: The PTM of the conjugate transpose of matrix mat.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliTransferMatrix/#PauliPropagation.getpaulibasis-Tuple{Int64}","page":"Pauli Transfer Matrix","title":"PauliPropagation.getpaulibasis","text":"getpaulimatrices(nq::Int)\n\nCompute the Pauli basis for n qubits.\n\nArguments\n\nn::Int: The number of qubits.\n\nReturns\n\nbasis::Vector{Array{ComplexF64}}: The Pauli basis for nq qubits.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliTransferMatrix/#Transfer-maps","page":"Pauli Transfer Matrix","title":"Transfer maps","text":"","category":"section"},{"location":"api/PauliTransferMatrix/","page":"Pauli Transfer Matrix","title":"Pauli Transfer Matrix","text":"Modules = [PauliPropagation]\nPages = [\"src/PauliTransferMatrix/transfermaps.jl\"]","category":"page"},{"location":"api/PauliTransferMatrix/#PauliPropagation.totransfermap","page":"Pauli Transfer Matrix","title":"PauliPropagation.totransfermap","text":"totransfermap(nq::Integer, circuit::Vector{Gate}, thetas=nothing)\n\nComputes the Pauli transfer map acting on nq qubits from a circuit with parameters thetas. thetas defaults to nothing but is required if the circuit contains parametrized gates. The returned lookup map is a vector of vectors like [(pstr1, coeff1), (pstr2, coeff2), ...], where the pstr are partial Pauli strings on the affected qubits.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliTransferMatrix/#PauliPropagation.totransfermap-Tuple{AbstractMatrix}","page":"Pauli Transfer Matrix","title":"PauliPropagation.totransfermap","text":"totransfermap(ptm::Matrix)\n\nComputes the Pauli transfer map acting on nq qubits from a Pauli Transfer Matrix (PTM). The PTM should be the matrix representation of a gate in Pauli basis. The returned lookup map is a vector of vectors like [(pstr1, coeff1), (pstr2, coeff2), ...], where the pstr are partial Pauli strings on the affected qubits.\n\n\n\n\n\n","category":"method"},{"location":"api/NumericalCertificates/#Numerical-Certificates","page":"Numerical Certificates","title":"Numerical Certificates","text":"","category":"section"},{"location":"api/NumericalCertificates/","page":"Numerical Certificates","title":"Numerical Certificates","text":"Modules = [PauliPropagation]\nPages = [\"src/numericalcertificates.jl\"]","category":"page"},{"location":"api/NumericalCertificates/#PauliPropagation._calculatesplitprobabilities-Tuple{AbstractArray, AbstractArray}","page":"Numerical Certificates","title":"PauliPropagation._calculatesplitprobabilities","text":"Function that automatically calculates the vector of splitting probabilities of the gates in the circuit based on a vector of thetas. For Pauli gates, the theta value is interpreted as the limits of the integration [-theta, theta]. For AmplitudeDampingNoise, the splitting probability is the damping rate.\n\n\n\n\n\n","category":"method"},{"location":"api/NumericalCertificates/#PauliPropagation._calculatesplitprobabilities-Tuple{AbstractArray, Number}","page":"Numerical Certificates","title":"PauliPropagation._calculatesplitprobabilities","text":"Function that automatically calculates the splitting probability of the gates in the circuit based on a one number theta. This assumes that the circuit consists only of PauliRotation -CliffordGate.\n\n\n\n\n\n","category":"method"},{"location":"api/NumericalCertificates/#PauliPropagation.estimatemse","page":"Numerical Certificates","title":"PauliPropagation.estimatemse","text":"estimatemse(circ, pstr::PauliString, n_mcsamples::Integer, thetas=π; stateoverlapfunc=overlapwithzero, circuit_is_reversed=false, customtruncfunc=nothing)\n\nFunction to estimate the mean square error of a truncated circuit simulation using Monte Carlo sampling. Returns the mean squared error of the truncated Pauli propagation simulation averaged over the thetas∈ [theta, theta] of the angle theta of each PauliRotation. Currently, the function only supports circuits with PauliRotation and CliffordGate gates.\n\nThe length the thetas vector should be equal to the number of parametrized gates in the circuit.  Alternatively, thetas can be a single real number applicable for all parametrized gates. The default thetas=π or any other non-array values assume that the circuit consists only of PauliRotation -CliffordGate. For PauliRotation, the value should be the integration range of the parameters around zero.\n\nAn initial state overlap function stateoverlapfunc can be provided to calculate the overlap of the backpropagated Pauli strings with the initial state. Importantly, the kwargs can be used to set the truncation parameters of the Pauli propagation. Currently supported are max_weight, max_freq, and max_sins. Note that min_abs_coeff is not supported here, as we consider errors integrated over the angles. max_freq effectively truncates small coefficients below (1/2)^max_freq on average over thetas ∈ [-π, π]. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool.\n\n\n\n\n\n","category":"function"},{"location":"api/NumericalCertificates/#PauliPropagation.estimatemse!-Tuple{Any, PauliString, AbstractVector, Any, Any}","page":"Numerical Certificates","title":"PauliPropagation.estimatemse!","text":"estimatemse!(circ, pstr::PauliString, error_array::AbstractVector, thetas, split_probabilities; stateoverlapfunc=overlapwithzero, circuit_is_reversed=false, kwargs...)\n\nIn-place version of estimatemse. This function takes an array error_array of length n_mcsamples as an argument and modifies it in-place.  It further assumes that the thetas and split_probabilities are already correctly calculated and provided as arguments.  In general they will be vectors, but they can also be real numbers. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/NumericalCertificates/#PauliPropagation.mcapply-Tuple{CliffordGate, PauliString, Any, Any}","page":"Numerical Certificates","title":"PauliPropagation.mcapply","text":"mcapply(gate::CliffordGate, pauli, coeff, theta, split_probability)\n\nmcapply() function for a CliffordGate is just the apply() function because it does not split.\n\n\n\n\n\n","category":"method"},{"location":"api/NumericalCertificates/#PauliPropagation.mcapply-Tuple{MaskedPauliRotation, PauliString, Any, Any}","page":"Numerical Certificates","title":"PauliPropagation.mcapply","text":"mcapply(gate::MaskedPauliRotation, pauli, coeff, theta, split_prob)\n\nMC apply function for a MaskedPauliRotation. This will error if a PauliRotation is not converted to a MaskedPauliRotation before calling this function. If the gate commutes with the pauli string, the pauli string is left unchanged.  Else the pauli string is split off with a probability 1 - split_prob.\n\n\n\n\n\n","category":"method"},{"location":"api/NumericalCertificates/#PauliPropagation.montecarlopropagation-Tuple{Any, PauliString, Any, Any}","page":"Numerical Certificates","title":"PauliPropagation.montecarlopropagation","text":"montecarlopropagation(circ, pstr::PauliString, thetas, split_probabilities; max_weight=Inf, max_freq=Inf, max_sins=Inf)\n\nPerform a single Monte Carlo propagation of a Pauli string through an already reversed circuit. Returns the final Pauli string and a boolean indicating whether the path was truncated.\n\nIt further assumes that the thetas and split_probabilities are already correctly calculated and provided as arguments.  In general they will be vectors, but they can also be real numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Pauli-Algebra","page":"Pauli Algebra","title":"Pauli Algebra","text":"","category":"section"},{"location":"api/PauliAlgebra/#Data-types","page":"Pauli Algebra","title":"Data types","text":"","category":"section"},{"location":"api/PauliAlgebra/","page":"Pauli Algebra","title":"Pauli Algebra","text":"Modules = [PauliPropagation]\nPages = [\"src/PauliAlgebra/datatypes.jl\"]","category":"page"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliString","page":"Pauli Algebra","title":"PauliPropagation.PauliString","text":"PauliString(nqubits::Int, pauli::Symbol, qind::Integer, coeff=1.0)\nPauliString(nqubits::Int, paulis::Vector{Symbol}, qinds::Vector{Integer}, coeff=1.0)\n\nConstructor for a PauliString on nqubits qubits from a Symbol (:I, :X, :Y, :Z) or Vector{Symbol}. Provide the index or indices for those symbols as qind or qinds. The coefficient of the Pauli string in the Pauli sum defaults to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliString-2","page":"Pauli Algebra","title":"PauliPropagation.PauliString","text":"PauliString(nqubits::Int, term::TermType, coeff::CoeffType)\n\nPauliString is a struct that represents a Pauli string on nqubits qubits. Commonly term is an unsigned Integer.  See the other PauliString constructors for higher-level usage. \n\n\n\n\n\n","category":"type"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(nqubits::Int, terms::Dict)\n\nPauliSum is a struct that represents a sum of Pauli strings acting on nqubits qubits. It is a wrapper around a dictionary Dict(Pauli string => coefficient}, where the Pauli strings are typically unsigned Integers for efficiency reasons.\n\n\n\n\n\n","category":"type"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Tuple{Int64}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(nqubits::Integer)\n\nContructor for an empty PauliSum on nqubits qubits. Element type defaults for Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(pstr::PauliString)\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Tuple{Union{Tuple, Base.Generator, AbstractArray}}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(pstrs::Vector{PauliString})\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Union{Tuple{CT}, Tuple{Int64, Dict{Vector{Symbol}, CT}}} where CT","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(nqubits::Integer, psum::Dict{Vector{Symbol},CoeffType})\n\nConstructor for a PauliSum on nqubits qubits from a dictionary of {Vector{Symbols} => coefficients}.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Union{Tuple{CT}, Tuple{Int64, Type{CT}}} where CT","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(nq::Int, COEFFTYPE)\n\nContructor for an empty PauliSum on nqubits qubits. The type of the coefficients can be provided.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Union{Tuple{CT}, Tuple{TT}, Tuple{Integer, PauliString{TT, CT}}} where {TT, CT}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(nq::Integer, pstr::PauliString)\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:*-Tuple{PauliSum, Number}","page":"Pauli Algebra","title":"Base.:*","text":"*(psum::PauliSum, c::Number)\n\nMultiply a PauliSum by a scalar c. This copies the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliString{TT, CT}, PauliString{TT, CT}}} where {TT, CT}","page":"Pauli Algebra","title":"Base.:+","text":"+(pstr1::PauliString{TermType,CoeffType}, pstr2::PauliString{TermType,CoeffType})\n\nAddition of two PauliStrings. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, Number}} where {TT, CT}","page":"Pauli Algebra","title":"Base.:+","text":"+(psum1::PauliSum, c::Number)\n\nAddition of c * Identity to a PauliSum. This copies the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, PauliString{TT, CT}}} where {TT, CT}","page":"Pauli Algebra","title":"Base.:+","text":"+(psum::PauliSum{TermType,CoeffType}, pstr::PauliString{TermType,CoeffType})\n\nAddition of a PauliString to a PauliSum. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, PauliSum{TT, CT}}} where {TT, CT}","page":"Pauli Algebra","title":"Base.:+","text":"+(psum1::PauliSum{TermType,CoeffType}, psum2::PauliSum{TermType,CoeffType})\n\nAddition of two PauliSums. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:--Union{Tuple{CT}, Tuple{TT}, Tuple{PauliString{TT, CT}, PauliString{TT, CT}}} where {TT, CT}","page":"Pauli Algebra","title":"Base.:-","text":"-(pstr1::PauliString{TermType,CoeffType}, pstr2::PauliString{TermType,CoeffType})\n\nSubtract two PauliStrings. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:--Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, PauliString{TT, CT}}} where {TT, CT}","page":"Pauli Algebra","title":"Base.:-","text":"-(psum::PauliSum{TermType,CoeffType}, pstr::PauliString{TermType,CoeffType})\n\nSubtract a PauliString to a PauliSum. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:--Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, PauliSum{TT, CT}}} where {TT, CT}","page":"Pauli Algebra","title":"Base.:-","text":"-(psum1::PauliSum{TermType,CoeffType}, psum2::PauliSum{TermType,CoeffType})\n\nSubtract two PauliSums. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:/-Tuple{PauliSum, Number}","page":"Pauli Algebra","title":"Base.:/","text":"/(psum::PauliSum, c::Number)\n\nDivide a PauliSum by a scalar c. This copies the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:==-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"Base.:==","text":"==(psum1::PauliSum, psum2::PauliSum)\n\nEquality check for PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:≈-Union{Tuple{CT2}, Tuple{TT2}, Tuple{CT1}, Tuple{TT1}, Tuple{PauliSum{TT1, CT1}, PauliSum{TT2, CT2}}} where {TT1, CT1, TT2, CT2}","page":"Pauli Algebra","title":"Base.:≈","text":"≈(psum1::PauliSum, psum2::PauliSum)\n\nApproximate equality check for PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.copy-Tuple{PauliSum}","page":"Pauli Algebra","title":"Base.copy","text":"Copy a PauliSum by copying its terms field.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.delete!-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, TT}} where {TT, CT}","page":"Pauli Algebra","title":"Base.delete!","text":"delete!(psum::PauliSum{TermType, CoeffType}, pstr::TermType)\n\nDelete a Pauli string from a PauliSum. The type of the Pauli string needs to be the keytype=TermType of the dictionary, and the coefficient coeff needs to be the valuetype=CoeffType.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.empty!-Tuple{PauliSum}","page":"Pauli Algebra","title":"Base.empty!","text":"empty!(psum::PauliSum)\n\nEmpty the PauliSum by emptying the dictionary on the terms fields. \n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.iterate","page":"Pauli Algebra","title":"Base.iterate","text":"Iterator for PauliSum returns the iterator over its terms.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliAlgebra/#Base.length-Tuple{PauliSum}","page":"Pauli Algebra","title":"Base.length","text":"length(psum::PauliSum)\n\nNumber of terms in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.show-Tuple{IO, PauliString}","page":"Pauli Algebra","title":"Base.show","text":"Pretty print for PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.show-Tuple{IO, PauliSum}","page":"Pauli Algebra","title":"Base.show","text":"Pretty print for PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._checknumberofqubits-Tuple{Int64, Any}","page":"Pauli Algebra","title":"PauliPropagation._checknumberofqubits","text":"Checks whether the number of qubits nqubits is the same between as the length of the vector pstr.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._checknumberofqubits-Tuple{Int64, Union{PauliString, PauliSum}}","page":"Pauli Algebra","title":"PauliPropagation._checknumberofqubits","text":"Checks whether the number of qubits nqubits is the same between our datatypes.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._checknumberofqubits-Tuple{Union{PauliString, PauliSum}, Union{PauliString, PauliSum}}","page":"Pauli Algebra","title":"PauliPropagation._checknumberofqubits","text":"Checks whether the number of qubits nqubits is the same between our datatypes.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._checknumberofqubits-Tuple{Union{Tuple, Base.Generator, AbstractArray}}","page":"Pauli Algebra","title":"PauliPropagation._checknumberofqubits","text":"Checks whether the number of qubits nqubits is the same between in some collection.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.add!","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum::PauliSum, pauli::Symbol, qind::Integer, coeff=1.0)\nadd!(psum::PauliSum, paulis::Vector{Symbol}, qinds::Vector{Integer}, coeff=1.0)\n\nAdd a Pauli string to a PauliSum psum. Changes psum in-place. Provide the Pauli string as a Symbol (:I, :X, :Y, :Z) or Vector{Symbol}. Provide the index or indices for those symbols as qind or qinds. The coefficient of the Pauli string in the Pauli sum defaults to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliAlgebra/#PauliPropagation.add!-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, PauliString{TT, CT}}} where {TT, CT}","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum::PauliSum, pstr::PauliString)\n\nAdd a PauliString pstr to a PauliSum psum. Changes psum in-place. psum and pstr need to be defined on the same number of qubits and have the same coefficient type.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.add!-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, PauliSum{TT, CT}}} where {TT, CT}","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum1::PauliSum, psum2::PauliSum)\n\nAdd two PauliSums psum1 and psum2. Changes psum1 in-place. psum1 and psum2 need to be defined on the same number of qubits and have the same coefficient type.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.add!-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, TT, CT}} where {TT, CT}","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum::PauliSum{TermType, CoeffType}, pstr::TermType, coeff::CoeffType)\n\nAdd a Pauli string pstr with coefficient coeff to a PauliSum psum. This changes psum in-place. pstr needs to have the same type as paulitype(psum), and coeff needs to have the same type as coefftype(psum).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.coefficients-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.coefficients","text":"coefficients(psum::PauliSum)\n\nReturns an iterator over the coefficients of a PauliSum. Call topaulistrings to receive entries as PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.coefftype-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.coefftype","text":"coefftype(pstr::PauliString)\n\nGet the coefficient type of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.coefftype-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.coefftype","text":"coefftype(psum::PauliSum)\n\nGet the coefficient type of a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Tuple{PauliSum, Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pstr::Vector{Symbol}, qinds::Vector{Int})\n\nGet the coefficient of a Pauli string in a PauliSum by providing the Pauli string pstr as a vector of Symbols acting on qubits qinds.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Tuple{PauliSum, Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pauli::Symbol, qind::Integer)\n\nGet the coefficient of a Pauli string in a PauliSum by providing the Pauli string as a Symbol acting on qubit qind.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Tuple{PauliSum, Vector{Symbol}}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pstr::Vector{Symbol})\n\nGet the coefficient of a Pauli string in a PauliSum by providing the Pauli string pstr as a vector of Symbols acting on all qubits.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT}, Tuple{PauliSum{TT, CT1}, PauliString{TT, CT2}}} where {TT, CT1, CT2}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pstr::PauliString)\n\nGet the coefficient of a PauliString in a PauliSum. Defaults to 0 if the Pauli string is not in the PauliSum. Requires that the integer Pauli string in pstr is the same type as the integer Pauli strings in psum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, TT}} where {TT, CT}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum{PauliStringType,CoeffType}, pstr::PauliStringType)\n\nGet the coefficient of an integer Pauli string in a PauliSum. Defaults to 0 if the Pauli string is not in the PauliSum. Requires that the integer Pauli string pstr is the same type as the integer Pauli strings in psum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.mult!-Tuple{PauliSum, Number}","page":"Pauli Algebra","title":"PauliPropagation.mult!","text":"mult!(psum::PauliSum, c::Number)\n\nMultiply a PauliSum by a scalar c in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.norm","page":"Pauli Algebra","title":"PauliPropagation.norm","text":"norm(psum::PauliSum, L=2)\n\nCalculate the norm of a PauliSum with respect to the L-norm.  Calls LinearAlgebra.norm on the coefficients of the PauliSum.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliAlgebra/#PauliPropagation.numcoefftype-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.numcoefftype","text":"numcoefftype(pstr::PauliString)\n\nGet the type of the numerical coefficient of a PauliString.  Will return the type of the output of  tonumber(pstr.coeff).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.numcoefftype-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.numcoefftype","text":"numcoefftype(psum::PauliSum)\n\nGet the type of the numerical coefficient of a PauliSum by calling numcoefftype() on the coefficients. If the PauliSum is empty, an error is thrown because the type cannot be inferred.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.paulis-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.paulis","text":"paulis(psum::PauliSum)\n\nReturns an iterator over the integer pauli strings of a PauliSum. Call topaulistrings to receive entries as PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.paulitype-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.paulitype","text":"paulitype(pstr::PauliString)\n\nGet the Pauli integer type of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.paulitype-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.paulitype","text":"paulitype(psum::PauliSum)\n\nGet the Pauli integer type of a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.set!-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, TT, CT}} where {TT, CT}","page":"Pauli Algebra","title":"PauliPropagation.set!","text":"set!(psum::PauliSum{TermType, CoeffType}, pstr::TermType, coeff::CoeffType)\n\nIn-place setting the coefficient of a Pauli string in a PauliSum dictionary. The type of the Pauli string needs to be the keytype=TermType of the dictionary, and the coefficient coeff needs to be the valuetype=CoeffType.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.similar-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.similar","text":"similar(psum::PauliSum)\n\nCreate a new PauliSum with the same number of qubits and coefficient type as psum. Calls sizehint!() with length(psum) on the dictionary of the new PauliSum. \n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.tonumber-Tuple{Number}","page":"Pauli Algebra","title":"PauliPropagation.tonumber","text":"tonumber(val::Number)\n\nTrivial function returning a numerical value of a number. Will be overloaded for custom wrapper types like PathProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.topaulistrings-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.topaulistrings","text":"topaulistrings(psum::PauliSum)\n\nReturns the Pauli strings in a PauliSum and their coefficients as a list of PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Pauli-operations","page":"Pauli Algebra","title":"Pauli operations","text":"","category":"section"},{"location":"api/PauliAlgebra/","page":"Pauli Algebra","title":"Pauli Algebra","text":"Modules = [PauliPropagation]\nPages = [\"src/PauliAlgebra/paulioperations.jl\"]","category":"page"},{"location":"api/PauliAlgebra/#PauliPropagation.calculatesign-Tuple{Integer, Integer, Integer, Any}","page":"Pauli Algebra","title":"PauliPropagation.calculatesign","text":"calculatesign(pauli1::PauliStringType, pauli2::PauliStringType, pauli3::PauliStringType, changed_indices)\n\nCalculate the sign of the product of two integer Pauli strings. Outcomes are either ±1 or ±i. Takes the product of the Paulis as argument for efficiency.  Indicate via changed_indices which qubit sites to check. It can be any iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.calculatesign-Tuple{Integer, Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.calculatesign","text":"calculatesign(pauli1::PauliStringType, pauli2::PauliStringType, pauli3::PauliStringType)\n\nCalculate the sign of the product of two integer Pauli strings. Outcomes are either ±1 or ±i. Takes the product of the Paulis pauli3 as argument for efficiency. \n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.calculatesign-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.calculatesign","text":"calculatesign(pauli1::PauliStringType, pauli2::PauliStringType)\n\nCalculate the sign of the product of two integer Pauli strings. Outcomes are either ±1 or ±i.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(pstr1::PauliStringType, pstr2::PauliStringType)\n\nCalculate the commutator of two integer Pauli strings. Returns a tuple of the coefficient and the potentially integer Pauli string. The coefficient is zero if the Pauli strings commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(pstr1::PauliString, pstr2::PauliString)\n\nCalculate the commutator of two PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliSum, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(psum::PauliSum, pstr::PauliString)\ncommutator(pstr::PauliString, psum::PauliSum)\n\nCalculate the commutator of a PauliSum and a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(psum1::PauliSum, psum2::PauliSum)\n\nCalculate the commutator of two PauliSums.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(pstr1::PauliStringType, pstr2::PauliStringType)\n\nCheck if two integer Pauli strings commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(pstr1::PauliString, pstr2::PauliString)\n\nCheck if two Pauli strings of type PauliString commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(psum1::PauliSum, psum2::PauliSum)\n\nCheck if two Pauli sums of type PauliSum commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(pauli1::Symbol, pauli2::PauliType)\ncommutes(pauli1::PauliType, pauli2::Symbol)\n\nCheck if two Paulis commute where one is a Symbol and the other is in the integer representation.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{Symbol, Symbol}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(pauli1::Symbol, pauli2::Symbol)\n\nCheck if two Paulis of type Symbol commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsXorY-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.containsXorY","text":"containsXorY(pstr::PauliStringType)\n\nCheck if an integer Pauli string contains an X or Y Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsXorY-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.containsXorY","text":"containsXorY(pstr::PauliString)\n\nCheck if a Pauli string contains an X or Y Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsYorZ-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.containsYorZ","text":"containsYorZ(pstr::PauliStringType)\n\nCheck if an integer Pauli string contains a Y or Z Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsYorZ-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.containsYorZ","text":"containsXorY(pstr::PauliString)\n\nCheck if a Pauli string contains a Y or Z Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(pstr::PauliStringType)\n\nFunction to count the weight of an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(pstr::PauliString)\n\nFunction to count the weight of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(psum::PauliSum)\n\nFunction to count the weight Pauli strings in a PauliSum. Returns an array of weights.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(pstr::PauliStringType)\n\nFunction to count the number of X and Y Paulis in an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(pstr::PauliString)\n\nFunction to count the number of X and Y Paulis in a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(psum::PauliSum)\n\nFunction to count the number of X and Y Paulis in a PauliSum. Returns an array of counts.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(pstr::PauliStringType)\n\nFunction to count the number of Y and Z Paulis in an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(pstr::PauliString)\n\nFunction to count the number of Y and Z Paulis in a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(psum::PauliSum)\n\nFunction to count the number of Y and Z Paulis in a PauliSum. Returns an array of counts.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.generalizedlevicivita-Tuple{Integer, Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.generalizedlevicivita","text":"generalizedlevicivita(pauli1::PauliType, pauli2::PauliType, pauli3::PauliType)\n\nCalculate the sign of the product of two integer Paulis. Outcomes are either ±1 or ±i. Takes the product of the Paulis as argument for efficiency.  Indicate via changed_indices which qubit sites to check. It can be any iterable.\n\nNote, this function is the foundation of calculatesign but assumes that the only (potentially) non-identity Pauli is on the first site.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{Integer, Integer, Any}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pauli1::PauliType, pauli2::PauliType)\n\nCalculate the product of two integer Paulis.  Indicate via changed_indices which qubit sites to check. It can be any iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pauli1::PauliStringType, pauli2::PauliStringType)\n\nCalculate the product of two integer Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{Integer, Symbol}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pauli1::PauliType, pauli2::Symbol)\n\nCalculate the product of two Paulis where one is in the integer representation and the other is a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pstr1::PauliString, pstr2::PauliString)\n\nCalculate the product of two PauliStrings. For example X*Y = iZ.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pauli1::Symbol, pauli2::PauliType)\n\nCalculate the product of two Paulis where one is a Symbol and the other is in the integer representation.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{Symbol, Symbol}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pauli1::Symbol, pauli2::Symbol)\n\nCalculate the product of two Paulis of type Symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Bit-operations","page":"Pauli Algebra","title":"Bit operations","text":"","category":"section"},{"location":"api/PauliAlgebra/","page":"Pauli Algebra","title":"Pauli Algebra","text":"Modules = [PauliPropagation]\nPages = [\"src/PauliAlgebra/bitoperations.jl\"]","category":"page"},{"location":"api/PauliAlgebra/#PauliPropagation._bitcommutes-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation._bitcommutes","text":"_bitcommutes(pstr1::PauliStringType, pstr2::PauliStringType)\n\nThis function checks if two integer Pauli strings commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._bitpaulimultiply-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation._bitpaulimultiply","text":"_bitpaulimultiply(pstr1::PauliStringType, pstr2::PauliStringType)\n\nXOR between two Pauli different non-identity strings gives the third one. Ignores signs or any coefficient.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._countbitweight-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation._countbitweight","text":"_countbitweight(pstr::PauliStringType)\n\nThis function counts the number of 00 bit pairs in the integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._countbitxy-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation._countbitxy","text":" _countbitxy(pstr::PauliStringType)\n\nThis function counts the number of 01 (X) or 10 (Y) bit pairs in the integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._countbityz-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation._countbityz","text":"_countbityz(pstr::PauliStringType)\n\nThis function counts the number of 10 (Y) or 11 (Z) bit pairs in the integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._getbit-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation._getbit","text":"_getbit(pauli::Integer, bitindex::Integer)\n\nGets the bit at index bitindex in the integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._getpaulibits-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation._getpaulibits","text":"_getpaulibits(pstr::PauliStringType, index::Integer)\n\nThis function extracts the Pauli at position index from the integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._paulishiftright-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation._paulishiftright","text":"_paulishiftright(pstr::PauliStringType)\n\nShift to the right and truncate the first encoded Pauli string. Just a utility function.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._setbit-Tuple{Integer, Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation._setbit","text":"_setbit(pstr::PauliStringType, target_bit::Integer, bitindex::Integer)\n\nSets a bit at index bitindex in the integer Pauli string to the value of target_bit.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._setbittoone-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation._setbittoone","text":"_setbittoone(pstr::Integer, bitindex::Integer)\n\nSets a bit at index bitindex in the integer Pauli string to 1.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._setbittozero-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation._setbittozero","text":"_setbittozero(pstr::Integer, bitindex::Integer)\n\nSets a bit at index bitindex in the integer Pauli string to 0.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._setpaulibits-Tuple{Integer, Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation._setpaulibits","text":"_setpaulibits(pstr::PauliStringType, pauli::PauliType, index::Integer)\n\nThis function sets the Pauli at position index in the integer Pauli string to target_pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getinttype-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.getinttype","text":"getinttype(nqubits::Integer)\n\nFunction to return the smallest integer type that can hold nqubits for memory and speed.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Utils","page":"Pauli Algebra","title":"Utils","text":"","category":"section"},{"location":"api/PauliAlgebra/","page":"Pauli Algebra","title":"Pauli Algebra","text":"Modules = [PauliPropagation]\nPages = [\"src/PauliAlgebra/utils.jl\"]","category":"page"},{"location":"api/PauliAlgebra/#PauliPropagation._getprettystr-Tuple{Dict, Int64}","page":"Pauli Algebra","title":"PauliPropagation._getprettystr","text":"Pretty string function.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getpauli-Tuple{Integer, Any}","page":"Pauli Algebra","title":"PauliPropagation.getpauli","text":"getpauli(pstr::PauliStringType, qinds::Vector{Integer})\n\nGets the Paulis on indices qinds of a pstr in the integer representation.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getpauli-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.getpauli","text":"getpauli(pstr::PauliStringType, index::Integer)\n\nGets the Pauli on index index of an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.identitylike-Tuple{TT} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.identitylike","text":"identitylike(pstr::PauliStringType)\n\nReturns an integer Pauli string of the same type as pstr with all Paulis set to identity.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.identitypauli-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.identitypauli","text":"identitypauli(nqubits::Integer)\n\nReturns the integer representation of the identity Pauli string acting on nqubits qubits. The type of will be the smallest integer type that can hold the number of qubits, as given by getinttype(nqubits).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.identitypauli-Union{Tuple{Type{TT}}, Tuple{TT}} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.identitypauli","text":"identitypauli(TermType<:PauliStringType)\n\nReturns the integer representation of the identity Pauli string with type TermType.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttostring-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttostring","text":"inttostring(pstr::PauliType, nqubits::Integer)\n\nReturns a string representation of an integer Pauli string pstr on nqubits qubits.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttosymbol-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttosymbol","text":"inttosymbol(pstr::PauliStringType, nqubits::Integer)\n\nMaps an integer Pauli string to a vector of symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttosymbol-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttosymbol","text":"inttosymbol(pauli::PauliType)\n\nMaps an integer Pauli to its corresponding symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.ispauli-Tuple{Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.ispauli","text":"ispauli(pauli1::Union{Symbol, PauliType}, pauli2::Union{Symbol, PauliType})\n\nispauli(pauli1::Union{Vector{Symbol}, PauliStringType}, pauli2::Union{Vector{Symbol}, PauliStringType})\n\nCheck if two Paulis are equal, where one is given as a symbol and the other as an integer.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(\n    pstr::PauliStringType, \n    target_paulis::Vector{Symbol}, \n    qinds::Vector{Integer}\n)\n\nSet the Paulis qinds of an integer Pauli string pstr to target_paulis. target_paulis is a vector of symbols. Use tuples in performance critical functions because they are immutable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Integer, Any}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(\n    pstr::PauliStringType, \n    target_paulis::PauliStringType, \n    qinds::Vector{Integer}\n)\n\nSet the Paulis qinds of an integer Pauli string pstr to target_paulis. Use Tuples for qinds in performance critical functions because they are immutable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(pstr::PauliStringType, target_pauli::PauliType, index::Integer)\n\nSets the Pauli on index index of an integer Pauli string to target_pauli.  That Pauli should be provided as integer (0, 1, 2, 3).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(pstr::PauliStringType, target_pauli::Symbol, index::Integer)\n\nSets the Pauli on index of an integer Pauli string to target_pauli.  That Pauli should be provided as a symbol (:I, :X, :Y, :Z).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Any}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(pstr::Union{Vector{Symbol}, Symbol})\n\nMaps a symbol or a vector of symbols pstr to an integer Pauli string.\n\nExample\n\nsymboltoint([:X, :I])\n\n# output\n\n0x01\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Integer, Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(nqubits::Integer, paulis::Vector{Symbol}, qinds::Vector{Int})\n\nMaps a vector of symbols pstr acting on the indices qinds to an integer Pauli string. Other sites are set to the identity. qinds can be any iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Integer, Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(nqubits::Integer, pauli::Symbol, qind::Integer)\n\nMaps a single symbol pauli acting on the index qind to an integer Pauli string. Other sites are set to the identity.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Symbol}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(pauli::Symbol)\n\nMaps a single symbol to its corresponding integer representation.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Union{Tuple{TT}, Tuple{Type{TT}, Any, Any}} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(::TermType, paulis, qinds)\n\nMaps a vector of symbols paulis acting on the indices qinds to an integer Pauli string with type TermType. Other sites are set to the identity. qinds can be any iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Union{Tuple{TT}, Tuple{Type{TT}, Symbol, Integer}} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(::TermType, pauli::Symbol, qind::Integer)\n\nMaps a single symbol pauli acting on the index qind to an integer Pauli string with type TermType. Other sites are set to the identity.\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TODO","category":"page"},{"location":"api/Gates/#Gates","page":"Gates","title":"Gates","text":"","category":"section"},{"location":"api/Gates/#Cliffords","page":"Gates","title":"Cliffords","text":"","category":"section"},{"location":"api/Gates/","page":"Gates","title":"Gates","text":"Modules = [PauliPropagation]\nPages = [\"src/Gates/cliffordgates.jl\"]","category":"page"},{"location":"api/Gates/#PauliPropagation.clifford_map","page":"Gates","title":"PauliPropagation.clifford_map","text":"clifford_map\n\nGlobal dictionary of Clifford gates and their action on Pauli strings. Currently supported Clifford gates are :H, :X, :Y, :Z, :SX, :SY, :S (:SZ) , :CNOT, :CZ, :ZZpihalf, and:SWAP. If one indexes into the returned arrays with the integer that corresponds to the partial Pauli string, the returned tuple is(sign, partialpstr)wheresignis the sign change andpartialpstr` is the new partial Pauli string.\n\n\n\n\n\n","category":"constant"},{"location":"api/Gates/#PauliPropagation.CliffordGate","page":"Gates","title":"PauliPropagation.CliffordGate","text":"\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.CliffordGate-Tuple{Symbol, Any}","page":"Gates","title":"PauliPropagation.CliffordGate","text":"CliffordGate(symbol::Symbol, qinds::Vector{Int})\nCliffordGate(symbol::Symbol, qinds::Int)\n\nA Clifford gate with the name symbol acting on the qubits qinds. symbol needs to match any of the implemented Clifford gates in the global clifford_map. qinds can be a single integer, a vector of integers, or anything that transforms into a vector via vec(collect(qinds)).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.composecliffordmaps-Tuple{Any}","page":"Gates","title":"PauliPropagation.composecliffordmaps","text":"composecliffordmaps(circuit::Vector{CliffordGate})\n\nCompose a circuit of Clifford gates into a single Clifford map. The length of the map is 4^nqwherenqis the maximum qubit index in the circuit. The resulting clifford map can be added to the globalclifford_mapwith a custom Clifford gate name. The maximum number of qubits is 4 due to current restrictions ofUInt8`. Even if all gates only act on one qubit, that qubit index will determine the dimensionality of the map.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.createcliffordmap-Tuple{Dict}","page":"Gates","title":"PauliPropagation.createcliffordmap","text":"createcliffordmap(gate_relations::Dict)\n\nCreate a Clifford gate map from a dictionary of gate relations which can then be pushed to the global clifford_map. gate_relations is a dictionary with pairs like (:X, :X) => (:Z, :X, -1), describing the action of the Clifford gate on symbols (including the sign change).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.reset_clifford_map!-Tuple{}","page":"Gates","title":"PauliPropagation.reset_clifford_map!","text":"reset_clifford_map!()\n\nReset global clifford_map to the CLifford gate implemented by default.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.transposecliffordmap-Tuple{Vector{Tuple{UInt8, Int64}}}","page":"Gates","title":"PauliPropagation.transposecliffordmap","text":"transposecliffordmap(map_array::Vector{Tuple{UInt8,Int}})\n\nTranspose the Clifford gate maparray so that the output map is the inverse of the input map. For example, transposecliffordmap(clifford_map[:H]) returns the map for the inverse of the Hadamard gate, which is the same map.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#Pauli-rotations","page":"Gates","title":"Pauli rotations","text":"","category":"section"},{"location":"api/Gates/","page":"Gates","title":"Gates","text":"Modules = [PauliPropagation]\nPages = [\"src/Gates/paulirotations.jl\"]","category":"page"},{"location":"api/Gates/#PauliPropagation.PauliRotationUnion","page":"Gates","title":"PauliPropagation.PauliRotationUnion","text":"PauliRotationUnion\n\nUnion type for PauliRotation and MaskedPauliRotation, useful for functions which handle either agnostically.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.MaskedPauliRotation","page":"Gates","title":"PauliPropagation.MaskedPauliRotation","text":"MaskedPauliRotation(symbols::Vector{Symbol}, qinds::Vector{Int}, term::PauliStringType)\n\nA parametrized Pauli rotation gate acting on the qubits qinds with the Pauli string symbols. The term is the integer representation of the Pauli string with the correct integer type for the total number of qubits. This allows for faster application of the gate. See tomaskedpaulirotation for conversion from PauliRotation, which is the easiest way to construct a MaskedPauliRotation.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliRotation-Tuple{Any, Any, Any}","page":"Gates","title":"PauliPropagation.PauliRotation","text":"PauliRotation(symbols, qinds, theta)\n\nConstructor for a frozen PauliRotation generated by the Pauli string symbols acting on the qubits qinds, and with fixed parameter theta.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliRotation-Tuple{Any, Any}","page":"Gates","title":"PauliPropagation.PauliRotation","text":"PauliRotation(symbols::Vector{Symbol}, qinds::Vector{Int})\nPauliRotation(symbol::Symbol, qinds::Int)\n\nA parametrized Pauli rotation generated by the Pauli string symbols acting on the qubits qinds. For example PauliRotation(:X, 2)  or PauliRotation([:X, :Y], [1, 2]).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation._tomaskedpaulirotation-Tuple{FrozenGate, Integer}","page":"Gates","title":"PauliPropagation._tomaskedpaulirotation","text":"_tomaskedpaulirotation(frozen_gate::FrozenGate, nqubits::Integer)\n\nTransforms a FrozenGate with a PauliRotation to a MaskedPauliRotation  which carries the integer representation of the gate generator.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation._tomaskedpaulirotation-Tuple{MaskedPauliRotation, Vararg{Any}}","page":"Gates","title":"PauliPropagation._tomaskedpaulirotation","text":"_tomaskedpaulirotation(fast_pauli_gate::MaskedPauliRotation, args...)\n\nReturn the MaskedPauliRotation gate as is.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation._tomaskedpaulirotation-Tuple{PauliRotation, Integer}","page":"Gates","title":"PauliPropagation._tomaskedpaulirotation","text":"_tomaskedpaulirotation(pauli_gate::PauliRotation, nqubits::Integer)\n\nTransforms a PauliRotation to a MaskedPauliRotation which carries the integer representation of the gate generator. This allows for significantly faster computation with the gate.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation._tomaskedpaulirotation-Union{Tuple{G}, Tuple{Vector{G}, Integer}} where G<:Gate","page":"Gates","title":"PauliPropagation._tomaskedpaulirotation","text":"_tomaskedpaulirotation(circ::Vector{Gate})\n\nReturns a circuit where PauliRotation gates are transformed to MaskedPauliRotation gates. This allows for significantly faster computation with the gate.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation._tomaskedpaulirotation-Union{Tuple{TT}, Tuple{G}, Tuple{Vector{G}, Type{TT}}} where {G<:Gate, TT<:Integer}","page":"Gates","title":"PauliPropagation._tomaskedpaulirotation","text":"_tomaskedpaulirotation(circ::Vector{Gate})\n\nReturns a circuit where PauliRotation gates are transformed to MaskedPauliRotation gates. This allows for significantly faster computation with the gate.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation._tomaskedpaulirotation-Union{Tuple{TT}, Tuple{PauliRotation, Type{TT}}} where TT<:Integer","page":"Gates","title":"PauliPropagation._tomaskedpaulirotation","text":"_tomaskedpaulirotation(pauli_gate::PauliRotation, ::TermType)\n\nTransforms a PauliRotation to a MaskedPauliRotation which carries the integer representation of the gate generator. This allows for significantly faster computation with the gate.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.commutes-Tuple{MaskedPauliRotation, Integer}","page":"Gates","title":"PauliPropagation.commutes","text":"commutes(gate::MaskedPauliRotation, pstr::PauliStringType)\n\nCheck if a MaskedPauliRotation commutes with an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.commutes-Tuple{PauliRotation, Integer}","page":"Gates","title":"PauliPropagation.commutes","text":"commutes(gate::PauliRotationUnion, pstr)\n\nCheck if a PauliRotation commutes with an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.commutes-Tuple{PauliRotation, PauliString}","page":"Gates","title":"PauliPropagation.commutes","text":"commutes(gate::PauliRotation, pstr::PauliString)\n\nCheck if a PauliRotation commutes with a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.tomatrix-Tuple{PauliRotation, Any}","page":"Gates","title":"PauliPropagation.tomatrix","text":"tomatrix(gate::PauliRotation, theta)\n\nCompute the unitary matrix for the PauliRotation gate with parameter theta in the computational 0/1 basis. This is done by computing the matrix U = cos(θ/2) I - i sin(θ/2) P where P is the Pauli matrix corresponding to the symbols. The returned unitary is returned in Schrödinger picture form. \n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#Frozen","page":"Gates","title":"Frozen","text":"","category":"section"},{"location":"api/Gates/","page":"Gates","title":"Gates","text":"Modules = [PauliPropagation]\nPages = [\"src/Gates/frozengates.jl\"]","category":"page"},{"location":"api/Gates/#PauliPropagation.FrozenGate","page":"Gates","title":"PauliPropagation.FrozenGate","text":"FrozenGate(gate::ParametrizedGate, parameter::Number)\n\nA StaticGate that wraps a ParametrizedGate with a fixed parameter. These are used to fix the parameter of ParametrizedGate at the time of circuit construction. This can be convenient but might exclude this parameter from being, e.g., differentiated by external libraries.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.freeze-Tuple{Any, Any}","page":"Gates","title":"PauliPropagation.freeze","text":"freeze(gates, parameters)\n\nReturns a vector of Gates where ParametrizedGates are frozen with their parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.freeze-Tuple{ParametrizedGate, Number}","page":"Gates","title":"PauliPropagation.freeze","text":"freeze(gate::ParametrizedGate, parameter::Number)\n\nReturns a FrozenGate wrapping the gate with the fixed parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#Noise","page":"Gates","title":"Noise","text":"","category":"section"},{"location":"api/Gates/","page":"Gates","title":"Gates","text":"Modules = [PauliPropagation]\nPages = [\"src/Gates/noisechannels.jl\"]","category":"page"},{"location":"api/Gates/#PauliPropagation.AmplitudeDampingNoise","page":"Gates","title":"PauliPropagation.AmplitudeDampingNoise","text":"AmplitudeDampingNoise(qind::Int)\n\nAn amplitude damping noise channel acting on the qubit at index qind. Damps X and Y Paulis by a factor of sqrt(1-gamma) and splits Z into and gamma * I and (1-gamma) * Z component (in the transposed Heisenberg picture).\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.AmplitudeDampingNoise-Tuple{Int64, Real}","page":"Gates","title":"PauliPropagation.AmplitudeDampingNoise","text":"AmplitudeDampingNoise(qind::Int, gamma::Real)\n\nA frozen amplitude damping noise channel acting on the qubit at index qind with noise strength gamma. Damps X and Y Paulis, and splits Z into and I and Z component (in the transposed Heisenberg picture).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.DephasingNoise","page":"Gates","title":"PauliPropagation.DephasingNoise","text":"DephasingNoise(qind::Int)\nDephasingNoise(qind::Int, p::Real)\n\nThis is an alias for PauliZNoise. A dephasing noise channel acting on the qubit at index qind. Will damp X and Y Paulis equally by a factor of 1-p. If p is provided, this returns a frozen gate with that noise strength.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.DepolarizingNoise-Tuple{Int64, Real}","page":"Gates","title":"PauliPropagation.DepolarizingNoise","text":"DepolarizingNoise(qind::Int, p::Real)\n\nA frozen depolarizing noise channel acting on the qubit at index qind with noise strength p. Will damp X, Y, and Z Paulis equally by a factor of 1-p.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.DepolarizingNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.DepolarizingNoise","text":"DepolarizingNoise(qind::Int)\n\nA depolarizing noise channel acting on the qubit at index qind. Will damp X, Y, and Z Paulis equally by a factor of 1-p.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.ParametrizedNoiseChannel","page":"Gates","title":"PauliPropagation.ParametrizedNoiseChannel","text":"Abstract type for parametrized noise channels\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliNoise","page":"Gates","title":"PauliPropagation.PauliNoise","text":"Abstract type for Pauli noise, i.e., noise that is diagonal in Pauli basis\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliXDamping-Tuple{Int64, Real}","page":"Gates","title":"PauliPropagation.PauliXDamping","text":"PauliXDamping(qind::Int, p::Real)\n\nA frozen Pauli-X noise damping acting on the qubit at index qind with noise strength p. Will damp X Paulis by a factor of 1-p. This alone is not a valid quantum channel.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliXDamping-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliXDamping","text":"PauliXDamping(qind::Int)\n\nA Pauli-X noise damping acting on the qubit at index qind. Will damp X Paulis by a factor of 1-p. This alone is not a valid quantum channel.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliXNoise-Tuple{Int64, Real}","page":"Gates","title":"PauliPropagation.PauliXNoise","text":"PauliXNoise(qind::Int, p::Real)\n\nA frozen Pauli-X noise channel acting on the qubit at index qind with noise strength p. Will damp Y and Z Paulis equally by a factor of 1-p. This corresponds to inserting a random Pauli X operator into the circuit with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliXNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliXNoise","text":"PauliXNoise(qind::Int)\n\nA Pauli-X noise channel acting on the qubit at index qind. Will damp Y and Z Paulis equally by a factor of 1-p. This corresponds to inserting a random Pauli X operator into the circuit with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliYDamping-Tuple{Int64, Real}","page":"Gates","title":"PauliPropagation.PauliYDamping","text":"PauliYDamping(qind::Int, p::Real)\n\nA frozen Pauli-Y damping acting on the qubit at index qind with noise strength p. Will damp Y Paulis by a factor of 1-p. This alone is not a valid quantum channel.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliYDamping-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliYDamping","text":"PauliYDamping(qind::Int)\n\nA Pauli-Y noise damping acting on the qubit at index qind. Will damp Y Paulis by a factor of 1-p. This alone is not a valid quantum channel.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliYNoise-Tuple{Int64, Real}","page":"Gates","title":"PauliPropagation.PauliYNoise","text":"PauliYNoise(qind::Int, p::Real)\n\nA frozen Pauli-Y noise channel acting on the qubit at index qind with noise strength p. Will damp X and Z Paulis equally by a factor of 1-p. This corresponds to inserting a random Pauli Y operator into the circuit with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliYNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliYNoise","text":"PauliYNoise(qind::Int)\n\nA Pauli-Y noise channel acting on the qubit at index qind. Will damp X and Z Paulis equally by a factor of 1-p. This corresponds to inserting a random Pauli Y operator into the circuit with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliZDamping-Tuple{Int64, Real}","page":"Gates","title":"PauliPropagation.PauliZDamping","text":"PauliZDamping(qind::Int, p::Real)\n\nA frozen Pauli-Z noise damping acting on the qubit at index qind with noise strength p. Will damp Z Paulis by a factor of 1-p. This alone is not a valid quantum channel.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliZDamping-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliZDamping","text":"PauliZDamping(qind::Int)\n\nA Pauli-Z noise damping acting on the qubit at index qind. Will damp Z Paulis by a factor of 1-p. This alone is not a valid quantum channel.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliZNoise-Tuple{Int64, Real}","page":"Gates","title":"PauliPropagation.PauliZNoise","text":"PauliZNoise(qind::Int, p::Real)\n\nA frozen Pauli-Z noise channel acting on the qubit at index qind with noise strength p. Will damp X and Y Paulis equally by a factor of 1-p. This corresponds to inserting a random Pauli Z operator into the circuit with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliZNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliZNoise","text":"PauliZNoise(qind::Int)\n\nA Pauli-Z noise channel acting on the qubit at index qind. Will damp X and Y Paulis equally by a factor of 1-p. This corresponds to inserting a random Pauli Z operator with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#Misc","page":"Gates","title":"Misc","text":"","category":"section"},{"location":"api/Gates/","page":"Gates","title":"Gates","text":"Modules = [PauliPropagation]\nPages = [\"src/Gates/miscgates.jl\"]","category":"page"},{"location":"api/Gates/#PauliPropagation.TGate-Tuple{Integer}","page":"Gates","title":"PauliPropagation.TGate","text":"TGate(qind::Integer)\n\nReturns a T gate acting on qubit qind. It acts on qubit qind like a PauliRotation(:Z, qind) with angle π/4.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.TransferMapGate","page":"Gates","title":"PauliPropagation.TransferMapGate","text":"TransferMapGate(transfer_map::Vector{Vector{Tuple{TermType,CoeffType}}}, qinds::Vector{Int})\n\nA non-parametrized StaticGate defined by a transfer map acting on the qubits qinds. Transfer maps can be constructed manually or generated via totransfermap().\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.TransferMapGate-Tuple{AbstractMatrix, Any}","page":"Gates","title":"PauliPropagation.TransferMapGate","text":"A constructor for TransferMapGate that accepts matrix representations in the 0/1 basis or the Pauli basis (a PTM).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.tomatrix-Tuple{TGate}","page":"Gates","title":"PauliPropagation.tomatrix","text":"tomatrix(gate::TGate)\n\nCompute the unitary matrix for a TGate. The returned unitary is returned in Schrödinger picture form. \n\n\n\n\n\n","category":"method"}]
}
