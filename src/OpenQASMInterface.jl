module OpenQASMInterface

using OpenQASM
# This line imports the necessary types from the main PauliPropagation module
using ..PauliPropagation: Gate, CliffordGate, PauliRotation, TGate

export readqasm

# --- Helper functions for Value-Based Dispatch ---

# Fallback for any gate not explicitly defined
function _translate_gate(gate_name_val::Val{G}, qubits, cargs) where {G}
    gate_name = Symbol(gate_name_val) # Extract symbol from Val type
    error("Unsupported translation for QASM gate: '$(G)'. This operation is not implemented.")
end

# -- Clifford Gates (return gate, nothing for theta) --
_translate_gate(::Val{:h}, qubits, cargs) = (CliffordGate(:H, qubits[1]), nothing)
_translate_gate(::Val{:x}, qubits, cargs) = (CliffordGate(:X, qubits[1]), nothing)
_translate_gate(::Val{:y}, qubits, cargs) = (CliffordGate(:Y, qubits[1]), nothing)
_translate_gate(::Val{:z}, qubits, cargs) = (CliffordGate(:Z, qubits[1]), nothing)
_translate_gate(::Val{:s}, qubits, cargs) = (CliffordGate(:S, qubits[1]), nothing)
_translate_gate(::Val{:sx}, qubits, cargs) = (CliffordGate(:SX, qubits[1]), nothing)
_translate_gate(::Val{:cx}, qubits, cargs) = (CliffordGate(:CNOT, qubits), nothing)
_translate_gate(::Val{:cz}, qubits, cargs) = (CliffordGate(:CZ, qubits), nothing)
_translate_gate(::Val{:swap}, qubits, cargs) = (CliffordGate(:SWAP, qubits), nothing)
_translate_gate(::Val{:t}, qubits, cargs) = (TGate(qubits[1]), nothing)
# Identity gate - do nothing (skip it)
_translate_gate(::Val{:id}, qubits, cargs) = (nothing, nothing)
# Barrier gate - do nothing (skip it, it's just a compiler hint)
_translate_gate(::Val{:barrier}, qubits, cargs) = (nothing, nothing)

# -- Pauli Rotations (return gate, and the parsed theta value) --
function _translate_gate(::Val{:rx}, qubits, cargs)
    param_token = cargs[1]
    theta = parse(Float64, param_token.str)
    return (PauliRotation(:X, qubits[1]), theta)
end

function _translate_gate(::Val{:ry}, qubits, cargs)
    param_token = cargs[1]
    theta = parse(Float64, param_token.str)
    return (PauliRotation(:Y, qubits[1]), theta)
end

function _translate_gate(::Val{:rz}, qubits, cargs)
    param_token = cargs[1]
    theta = parse(Float64, param_token.str)
    return (PauliRotation(:Z, qubits[1]), theta)
end

function _translate_gate(::Val{:p}, qubits, cargs)
    # p(lambda) is equivalent to rz(lambda) - phase gate
    param_token = cargs[1]
    lambda = parse(Float64, param_token.str)
    return (PauliRotation(:Z, qubits[1]), lambda)
end

function _translate_gate(::Val{:sdg}, qubits, cargs)
    # sdg = S† = u1(-pi/2) = RZ(-pi/2) - conjugate of S gate (no parameters)
    return (PauliRotation(:Z, qubits[1]), -pi/2)
end

function _translate_gate(::Val{:tdg}, qubits, cargs)
    # tdg = T† = u1(-pi/4) = RZ(-pi/4) - conjugate of T gate (no parameters)
    return (PauliRotation(:Z, qubits[1]), -pi/4)
end

function _translate_gate(::Val{:rzz}, qubits, cargs)
    param_token = cargs[1]
    theta = parse(Float64, param_token.str)
    # If angle is π/2, use the Clifford gate ZZpihalf
    if isapprox(theta, pi/2, atol=1e-10)
        return (CliffordGate(:ZZpihalf, qubits), nothing)
    else
        # Two-qubit ZZ rotation generated by Z ⊗ Z
        return (PauliRotation([:Z, :Z], qubits), theta)
    end
end

function _translate_gate(::Val{:rxx}, qubits, cargs)
    param_token = cargs[1]
    theta = parse(Float64, param_token.str)
    # Two-qubit XX rotation generated by X ⊗ X
    return (PauliRotation([:X, :X], qubits), theta)
end

# -- Composite Gates (return vector of gates) --

function _translate_gate(::Val{:sxdg}, qubits, cargs)
    # sxdg = { s a; h a; s a; } - inverse sqrt(X)
    a = qubits[1]
    gates = [CliffordGate(:S, a), CliffordGate(:H, a), CliffordGate(:S, a)]
    thetas = [nothing, nothing, nothing]
    return (gates, thetas)
end

function _translate_gate(::Val{:cy}, qubits, cargs)
    # cy = { sdg b; cx a,b; s b; } - controlled-Y
    a, b = qubits
    gates = [PauliRotation(:Z, b), CliffordGate(:CNOT, [a, b]), CliffordGate(:S, b)]
    thetas = [-pi/2, nothing, nothing]  # only sdg has a theta
    return (gates, thetas)
end

function _translate_gate(::Val{:ch}, qubits, cargs)
    # ch = controlled-H (complex decomposition)
    a, b = qubits
    gates = [
        CliffordGate(:H, b),
        PauliRotation(:Z, b),  # sdg
        CliffordGate(:CNOT, [a, b]),
        CliffordGate(:H, b),
        TGate(b),
        CliffordGate(:CNOT, [a, b]),
        TGate(b),
        CliffordGate(:H, b),
        CliffordGate(:S, b),
        CliffordGate(:X, b),
        CliffordGate(:S, a)
    ]
    thetas = [nothing, -pi/2, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing]
    return (gates, thetas)
end

function _translate_gate(::Val{:ccx}, qubits, cargs)
    # ccx = Toffoli gate (complex decomposition)
    a, b, c = qubits
    gates = [
        CliffordGate(:H, c),
        CliffordGate(:CNOT, [b, c]),
        PauliRotation(:Z, c),  # tdg
        CliffordGate(:CNOT, [a, c]),
        TGate(c),
        CliffordGate(:CNOT, [b, c]),
        PauliRotation(:Z, c),  # tdg
        CliffordGate(:CNOT, [a, c]),
        TGate(b),
        TGate(c),
        CliffordGate(:H, c),
        CliffordGate(:CNOT, [a, b]),
        TGate(a),
        PauliRotation(:Z, b),  # tdg
        CliffordGate(:CNOT, [a, b])
    ]
    thetas = [nothing, nothing, -pi/4, nothing, nothing, nothing, -pi/4, nothing, nothing, nothing, nothing, nothing, nothing, -pi/4, nothing]
    return (gates, thetas)
end

function _translate_gate(::Val{:cswap}, qubits, cargs)
    # cswap = controlled-SWAP (Fredkin gate) = { cx c,b; ccx a,b,c; cx c,b; }
    a, b, c = qubits
    # First cx c,b
    gates = Gate[CliffordGate(:CNOT, [c, b])]
    thetas = Union{Nothing, Float64}[nothing]
    # Then ccx a,b,c (expands to 15 gates with 3 thetas)
    ccx_gates, ccx_thetas = _translate_gate(Val(:ccx), [a, b, c], cargs)
    append!(gates, ccx_gates)
    append!(thetas, ccx_thetas)
    # Finally cx c,b
    push!(gates, CliffordGate(:CNOT, [c, b]))
    push!(thetas, nothing)
    return (gates, thetas)
end

function _translate_gate(::Val{:crx}, qubits, cargs)
    # crx(lambda) = controlled RX rotation
    # { u1(pi/2) b; cx a,b; u3(-lambda/2,0,0) b; cx a,b; u3(lambda/2,-pi/2,0) b; }
    a, b = qubits
    param_token = cargs[1]
    lambda = parse(Float64, param_token.str)
    
    gates = [
        PauliRotation(:Z, b),           # u1(pi/2) = rz(pi/2)
        CliffordGate(:CNOT, [a, b]),    # cx a,b
        PauliRotation(:Y, b),           # u3(-lambda/2,0,0) = ry(-lambda/2)
        CliffordGate(:CNOT, [a, b]),    # cx a,b
        PauliRotation(:X, b)            # u3(lambda/2,-pi/2,0) = rx(lambda/2)
    ]
    thetas = [pi/2, nothing, -lambda/2, nothing, lambda/2]
    return (gates, thetas)
end

function _translate_gate(::Val{:cry}, qubits, cargs)
    # cry(lambda) = controlled RY rotation
    # { ry(lambda/2) b; cx a,b; ry(-lambda/2) b; cx a,b; }
    a, b = qubits
    param_token = cargs[1]
    lambda = parse(Float64, param_token.str)

    gates = [
        PauliRotation(:Y, b),
        CliffordGate(:CNOT, [a, b]),
        PauliRotation(:Y, b),
        CliffordGate(:CNOT, [a, b])
    ]
    thetas = [lambda/2, nothing, -lambda/2, nothing]
    return (gates, thetas)
end

function _translate_gate(::Val{:crz}, qubits, cargs)
    # crz(lambda) = controlled RZ rotation
    # { rz(lambda/2) b; cx a,b; rz(-lambda/2) b; cx a,b; }
    a, b = qubits
    param_token = cargs[1]
    lambda = parse(Float64, param_token.str)

    gates = [
        PauliRotation(:Z, b),
        CliffordGate(:CNOT, [a, b]),
        PauliRotation(:Z, b),
        CliffordGate(:CNOT, [a, b])
    ]
    thetas = [lambda/2, nothing, -lambda/2, nothing]
    return (gates, thetas)
end

function _translate_gate(::Val{:cu1}, qubits, cargs)
    # cu1(lambda) = controlled phase using u1
    # { u1(lambda/2) a; cx a,b; u1(-lambda/2) b; cx a,b; u1(lambda/2) b; }
    a, b = qubits
    param_token = cargs[1]
    lambda = parse(Float64, param_token.str)

    gates = [
        PauliRotation(:Z, a),
        CliffordGate(:CNOT, [a, b]),
        PauliRotation(:Z, b),
        CliffordGate(:CNOT, [a, b]),
        PauliRotation(:Z, b)
    ]
    thetas = [lambda/2, nothing, -lambda/2, nothing, lambda/2]
    return (gates, thetas)
end

function _translate_gate(::Val{:cp}, qubits, cargs)
    # cp(lambda) = controlled phase using p (same as cu1 but via p)
    # { p(lambda/2) a; cx a,b; p(-lambda/2) b; cx a,b; p(lambda/2) b; }
    a, b = qubits
    param_token = cargs[1]
    lambda = parse(Float64, param_token.str)

    gates = [
        PauliRotation(:Z, a),
        CliffordGate(:CNOT, [a, b]),
        PauliRotation(:Z, b),
        CliffordGate(:CNOT, [a, b]),
        PauliRotation(:Z, b)
    ]
    thetas = [lambda/2, nothing, -lambda/2, nothing, lambda/2]
    return (gates, thetas)
end

function _translate_gate(::Val{:csx}, qubits, cargs)
    # csx = { h b; cu1(pi/2) a,b; h b; }
    a, b = qubits
    # cu1(pi/2): use lambda = pi/2
    lambda = pi/2
    gates = [
        CliffordGate(:H, b),
        PauliRotation(:Z, a),
        CliffordGate(:CNOT, [a, b]),
        PauliRotation(:Z, b),
        CliffordGate(:CNOT, [a, b]),
        PauliRotation(:Z, b),
        CliffordGate(:H, b),
    ]
    thetas = [nothing, lambda/2, nothing, -lambda/2, nothing, lambda/2, nothing]
    return (gates, thetas)
end

function _translate_gate(::Val{:rccx}, qubits, cargs)
    # rccx = relative-phase Toffoli
    # { u2(0,pi) c; u1(pi/4) c; cx b,c; u1(-pi/4) c; cx a,c; u1(pi/4) c; cx b,c; u1(-pi/4) c; u2(0,pi) c; }
    a, b, c = qubits
    gates = [
        CliffordGate(:H, c),            # u2(0,pi)
        TGate(c),                       # u1(pi/4)
        CliffordGate(:CNOT, [b, c]),
        PauliRotation(:Z, c),           # u1(-pi/4)
        CliffordGate(:CNOT, [a, c]),
        TGate(c),                       # u1(pi/4)
        CliffordGate(:CNOT, [b, c]),
        PauliRotation(:Z, c),           # u1(-pi/4)
        CliffordGate(:H, c)             # u2(0,pi)
    ]
    thetas = [nothing, nothing, nothing, -pi/4, nothing, nothing, nothing, -pi/4, nothing]
    return (gates, thetas)
end

function _translate_gate(::Val{:rc3x}, qubits, cargs)
    # rc3x = relative-phase 3-controlled X
    # as given in the OpenQASM definition
    a, b, c, d = qubits
    gates = [
        CliffordGate(:H, d),
        TGate(d),
        CliffordGate(:CNOT, [c, d]),
        PauliRotation(:Z, d),   # -pi/4
        CliffordGate(:H, d),
        CliffordGate(:CNOT, [a, d]),
        TGate(d),
        CliffordGate(:CNOT, [b, d]),
        PauliRotation(:Z, d),   # -pi/4
        CliffordGate(:CNOT, [a, d]),
        TGate(d),
        CliffordGate(:CNOT, [b, d]),
        PauliRotation(:Z, d),   # -pi/4
        CliffordGate(:H, d),
        TGate(d),
        CliffordGate(:CNOT, [c, d]),
        PauliRotation(:Z, d),   # -pi/4
        CliffordGate(:H, d)
    ]
    thetas = [
        nothing, nothing, nothing, -pi/4, nothing,
        nothing, nothing, nothing, -pi/4, nothing,
        nothing, nothing, -pi/4, nothing, nothing,
        nothing, -pi/4, nothing
    ]
    return (gates, thetas)
end

function _translate_gate(::Val{:c3x}, qubits, cargs)
    # c3x = 3-controlled X gate (non-relative-phase)
   
    gate_name_val = Val(:c3x)
    error("Unsupported translation for QASM gate: 'c3x'. This operation is not implemented.")
end


"""
    readqasm(filepath::String) -> (Int, Vector, Vector)

Parses an OpenQASM 2.0 file and returns the number of qubits, 
a circuit compatible with PauliPropagation.jl, and a vector of gate parameters (thetas).
"""
function readqasm(filepath::String)
    qasm_content = read(filepath, String)
    parsed_program = OpenQASM.parse(qasm_content)

    statements = parsed_program.prog

    # Find the qreg declaration to determine the number of qubits
    nq = 0
    qreg_decl_idx = findfirst(x -> x isa OpenQASM.Types.RegDecl, statements)
    if qreg_decl_idx !== nothing
        size_token = statements[qreg_decl_idx].size
        nq = parse(Int, size_token.str)
    else
        error("QASM file does not contain a qubit register ('qreg') declaration.")
    end

    circuit = []
    thetas = []

    # Loop through every instruction in the extracted list
    for instruction in statements
        # Handle reset and measure as special cases (they're not Instruction types)
        if instruction isa OpenQASM.Types.Reset
            error("Unsupported translation for QASM gate: 'reset'. Reset operations are non-unitary and not supported.")
        elseif instruction isa OpenQASM.Types.Measure
            error("Unsupported translation for QASM gate: 'measure'. Measurement operations are non-unitary and not supported.")
        elseif !(instruction isa OpenQASM.Types.Instruction)
            continue
        end

        gate_name_str = instruction.name
        qubits = [parse(Int, q.address.str) + 1 for q in instruction.qargs]
        cargs = instruction.cargs

        # Convert the gate name string to a Val{Symbol} to enable multiple dispatch
        gate_name_val = Val(Symbol(gate_name_str))

        # Dispatch to the correct helper method based on the gate name
        result = _translate_gate(gate_name_val, qubits, cargs)

        # Handle both single gates and vectors of gates (for composite gates)
        if result isa Tuple && result[1] isa Vector
            # Composite gate: result is (Vector{gate}, Vector{theta or nothing})
            gate_vec, theta_vec = result
            for (i, g) in enumerate(gate_vec)
                if isnothing(g)
                    continue  # Skip identity gates in composite
                end
                push!(circuit, g)
                if i <= length(theta_vec) && !isnothing(theta_vec[i])
                    push!(thetas, theta_vec[i])
                end
            end
        else
            # Single gate: original behavior (gate, theta)
            gate_obj, theta = result
            # Skip gates that return nothing (e.g., identity gate)
            if isnothing(gate_obj)
                continue
            end
            push!(circuit, gate_obj)
            if !isnothing(theta)
                push!(thetas, theta)
            end
        end
    end

    return nq, circuit, thetas
end

end # end of module