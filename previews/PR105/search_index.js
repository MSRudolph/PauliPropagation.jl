var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"TODO","category":"page"},{"location":"api/Surrogate/#Surrogate","page":"Surrogate","title":"Surrogate","text":"","category":"section"},{"location":"api/Surrogate/#Datatypes","page":"Surrogate","title":"Datatypes","text":"","category":"section"},{"location":"api/Surrogate/#PauliPropagation.NodePathProperties","page":"Surrogate","title":"PauliPropagation.NodePathProperties","text":"NodePathProperties(node::CircuitNode)\nNodePathProperties(node::CircuitNode, nsins::Int, ncos::Int, freq::Int)\n\nSurrogate PathProperties type. Carries CircuitNodes instead of numerical coefficients. If nsins, ncos, and freq are not provided, they are initialized to 0.\n\n\n\n\n\n","category":"type"},{"location":"api/Surrogate/#PauliPropagation.tonumber-Tuple{NodePathProperties}","page":"Surrogate","title":"PauliPropagation.tonumber","text":"tonumber(path::NodePathProperties)\n\nGet the cummulative coefficient of a NodePathProperties node. This assumes that the surrogate has already been evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.wrapcoefficients-Tuple{PauliString, Type{NodePathProperties}}","page":"Surrogate","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(pstr::PauliString, ::Type{NodePathProperties})\n\nWrap the coefficient of a PauliString into NodePathProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.wrapcoefficients-Tuple{PauliSum, Type{NodePathProperties}}","page":"Surrogate","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(psum::PauliSum, ::Type{NodePathProperties})\n\nWrap the coefficients of a PauliSum into NodePathProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#Evaluate","page":"Surrogate","title":"Evaluate","text":"","category":"section"},{"location":"api/Surrogate/#PauliPropagation.evaluate!-Union{Tuple{TT}, Tuple{PauliSum{TT, NodePathProperties}, Any}} where TT","page":"Surrogate","title":"PauliPropagation.evaluate!","text":"evaluate!(psum::PauliSum{<:Integer,NodePathProperties}, thetas; reset=true)\n\nEvaluate the expectation value of a Surrogate by evaluating all involved circuit nodes in the correct order. eval_list can be attained as the output of gettraceevalorder(). If reset is false, the function will not reset the is_evaluated flags of the nodes. This should only be done if they are manually reset.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Tuple{PauliPropagation.CircuitNode}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(circuit_node::CircuitNode)\n\nReset a CircuitNode in a the Surrogate. Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Tuple{PauliPropagation.EvalEndNode}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(end_node::EvalEndNode)\n\nReset a EvalEndNode in a the Surrogate.  These sit on the coeff field of NodePathProperties and are the end of the evaluation chain. Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Union{Tuple{AbstractVector{CT}}, Tuple{CT}} where CT<:NodePathProperties","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(paths::Vector{NodePathProperties})\n\nReset a vector of NodePathProperties in a the Surrogate.  Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Union{Tuple{PauliSum{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT<:NodePathProperties}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(psum::PauliSum{<:Integer, NodePathProperties})\n\nReset the nodes in a the Surrogate.  Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#Propagate","page":"Surrogate","title":"Propagate","text":"","category":"section"},{"location":"api/Surrogate/#PauliPropagation.propagate!-Union{Tuple{TT}, Tuple{Any, PauliSum{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.propagate!","text":"propagate!(circ, psum::PauliSum{<:Integer,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliSum through the circuit circ in the Heisenberg picture.  The PauliSum psum is modified in place. The circuit must only contain CliffordGates and PauliRotations. Truncations based on any numerical coefficient value cannot be used. Everything else is the same as in propagate!() for the non-Surrogate code.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.propagate-Union{Tuple{TT}, Tuple{Any, PauliString{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.propagate","text":"propagate(circ, pstr::PauliString{<:Integer,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliString through the circuit circ in the Heisenberg picture.  The circuit must only contain CliffordGates and PauliRotations. Truncations based on any numerical coefficient value cannot be used. Everything else is the same as in propagate!() for the non-Surrogate code.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.propagate-Union{Tuple{TT}, Tuple{Any, PauliSum{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.propagate","text":"propagate(circ, psum::PauliSum{<:Integer,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliSum through the circuit circ in the Heisenberg picture. The circuit must only contain CliffordGates and PauliRotations.  Truncations based on any numerical coefficient value cannot be used. Everything else is the same as in propagate!() for the non-Surrogate code.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#Path-Properties","page":"Path Properties","title":"Path Properties","text":"","category":"section"},{"location":"api/PathProperties/#Pauli-frequency-tracker","page":"Path Properties","title":"Pauli frequency tracker","text":"","category":"section"},{"location":"api/PathProperties/#PauliPropagation.PauliFreqTracker","page":"Path Properties","title":"PauliPropagation.PauliFreqTracker","text":"PauliFreqTracker(coeff::Number, nsins::Int, ncos::Int, freq::Int)\n\nWrapper type for numerical coefficients in Pauli propagation that records  the number of sin and cos factors applied via a PauliRotation gate, and the so-called frequency, which is their sum. It appears redundant but these three properties need to be tracked separately because of how merging affects them.\n\n\n\n\n\n","category":"type"},{"location":"api/PathProperties/#PauliPropagation.PauliFreqTracker-Tuple{Number}","page":"Path Properties","title":"PauliPropagation.PauliFreqTracker","text":"PauliFreqTracker(coeff::Number)\n\nConstructor for PauliFreqTracker from only a coefficient. Initializes nsins, ncos, and freq to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#Abstract-type","page":"Path Properties","title":"Abstract type","text":"","category":"section"},{"location":"api/PathProperties/#PauliPropagation.PathProperties","page":"Path Properties","title":"PauliPropagation.PathProperties","text":"Abstract type for wrapping coefficients and record custom path properties\n\n\n\n\n\n","category":"type"},{"location":"api/PathProperties/#Base.float-Tuple{PProp} where PProp<:PathProperties","page":"Path Properties","title":"Base.float","text":"float(path::PathProperties)\n\nReturns an equivalent PathProperties object where float() is applied to the coeff field.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.tonumber-Tuple{PProp} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.tonumber","text":"tonumber(path::PathProperties)\n\nGet the numerical coefficient of a PathProperties wrapper.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.unwrapcoefficients-Union{Tuple{PauliString{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT}","page":"Path Properties","title":"PauliPropagation.unwrapcoefficients","text":"unwrapcoefficients(pstr::PauliString)\n\nUnwrap the coefficient of a PauliString from a PathProperties type. Returns a PauliString with the coeff field of the PathProperties object.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.unwrapcoefficients-Union{Tuple{PauliSum{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT}","page":"Path Properties","title":"PauliPropagation.unwrapcoefficients","text":"unwrapcoefficients(psum::PauliSum)\n\nUnwrap the coefficients of a PauliSum from a PathProperties type. Returns a PauliSum with coefficients being the coeff field of the PathProperties objects.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.wrapcoefficients-Union{Tuple{PProp}, Tuple{PauliString, Type{PProp}}} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(pstr::PauliString, PathPropertiesType<:PathProperties)\n\nWrap the coefficient of a PauliString into a custom PathProperties type. For anything that is not natively supported by the library, you can subtype PathProperties. A one-argument constructor of the custom PathProperties type from a coefficient must be defined.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.wrapcoefficients-Union{Tuple{PProp}, Tuple{PauliSum, Type{PProp}}} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(psum::PauliSum, PathPropertiesType<:PathProperties)\n\nWrap the coefficients of a PauliSum into a custom PathProperties type. For anything that is not natively supported by the library, you can subtype PathProperties. A one-argument constructor of the custom PathProperties type from a coefficient must be defined.\n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#Truncations","page":"Truncations","title":"Truncations","text":"","category":"section"},{"location":"api/Truncations/#PauliPropagation.truncatedampingcoeff-Tuple{Integer, Any, Number, Real}","page":"Truncations","title":"PauliPropagation.truncatedampingcoeff","text":"truncatedampingcoeff(\n    pstr::Integer, \n    coeff::Real, \n    gamma::Number, \n    min_abs_coeff::Float64\n)\n\nCustom truncation function with dissipation-assisted damping of coefficients. It returns true (indicating to truncate) if the coefficient exponentially damped by the Pauli weight drops below min_abs_coeff.\n\nThe function evaluates the condition: abs(coeff) * 10^(-gamma * countweight(pstr)) < min_abs_coeff\n\ngamma is the damping factor controlling the rate of exponential decay with Pauli weight.\n\nTo turn this function into a custom truncation function for propagate(), you need to define a closure  that only takes the pstr and coeff as arguments, but has gamma and min_abs_coeff fixed.\n\nExample:\n\ncustomtruncfunc = (pstr, coeff) -> truncatedampingcoeff(pstr, coeff, 0.5, 1e-10) \n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#State-Overlap","page":"State Overlap","title":"State Overlap","text":"","category":"section"},{"location":"api/StateOverlap/#Base.filter!-Union{Tuple{F}, Tuple{F, PauliSum}} where F<:Function","page":"State Overlap","title":"Base.filter!","text":"filter!(filterfunc::Function, psum::PauliSum)\n\nFilter a PauliSum in-place by removing all Pauli strings for which filterfunc(pstr, coeff) returns false.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#Base.filter-Union{Tuple{F}, Tuple{F, PauliSum}} where F<:Function","page":"State Overlap","title":"Base.filter","text":"filter(filterfunc::Function, psum::PauliSum)\n\nReturn a filtered PauliSum by removing all Pauli strings for which filterfunc(pstr, coeff) returns false.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithcomputational-Tuple{PauliSum, Any}","page":"State Overlap","title":"PauliPropagation.overlapwithcomputational","text":"overlapwithcomputational(psum::PauliSum, onebitinds::Vector{Integer})\noverlapwithcomputational(pstr::PauliString, onebitinds::Vector{Integer})\n\nCalculates the overlap of a Pauli sum or Pauli string with the computational basis state  which has one-bits at all specified indices and zero-bits elsewhere. If |x><x| is a computational basis state, it we compute Tr[psum * |x><x|] = <x|psum|x> or Tr[pstr * |x><x|] = <x|pstr|x>. For example, overlapwithcomputational(psum, [1,2,4]) returns the overlap with |1101000...>.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithmaxmixed-Union{Tuple{PauliSum{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT}","page":"State Overlap","title":"PauliPropagation.overlapwithmaxmixed","text":"overlapwithmaxmixed(psum::PauliSum)\n\nCalculates the overlap of a PauliSum with the maximally mixed state I/2^n, i.e., Tr[psum * I/2^n].\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithpaulisum-Tuple{Any, Any}","page":"State Overlap","title":"PauliPropagation.overlapwithpaulisum","text":"overlapwithpaulisum(rho::PauliSum, psum::PauliSum)\n\nCalculate the overlap of a Pauli sum psum and a quantum state rho represented in the Pauli basis via another PauliSum. This is equivalent to the trace Tr[rho * psum]. Calls scalarproduct(rho, psum) * (2^rho.nqubits) to calculate the overlap.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithplus-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.overlapwithplus","text":"overlapwithplus(psum::PauliSum) \noverlapwithplus(pstr::PauliString)\n\nCalculates the overlap of a Pauli sum or Pauli string with the plus state |+><+|, i.e. Tr[psum * |+><+|] = <+|psum|+> or Tr[pstr * |+><+|] = <+|pstr|+>.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithzero-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.overlapwithzero","text":"overlapwithzero(psum::PauliSum) \noverlapwithzero(pstr::PauliString)\n\nCalculates the overlap of a Pauli sum with the zero state |0><0|, i.e., Tr[psum * |0><0|] = <0|psum|0> or Tr[pstr * |0><0|] = <0|pstr|0>.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.plusfilter!-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.plusfilter!","text":"zerofilter!(psum)\n\nFilter a Pauli sum in-place with only Pauli strings that are not orthogonal to the plus state |+><+|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.plusfilter-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.plusfilter","text":"plusfilter(psum)\n\nReturn a filtered Pauli sum with only Pauli strings that are not orthogonal to the plus state |+><+|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.scalarproduct-Tuple{PauliSum, PauliSum}","page":"State Overlap","title":"PauliPropagation.scalarproduct","text":"scalarproduct(pobj1::Union{PauliSum,PauliString}, pobj2::Union{PauliSum,PauliString})\n\nCalculates the scalar product between any combination of PauliSum and PauliString. This  calculates the sum of the products of their coefficients for all Pauli strings that are present . Important: This is not equivalent to the trace Tr[psum1 * psum2] but instead  Tr[psum1 * psum2]/2^n, and equivalently for Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.zerofilter!-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.zerofilter!","text":"zerofilter!(psum)\n\nFilter a Pauli sum in-place with only Pauli strings that are not orthogonal to the zero state |0><0|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.zerofilter-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.zerofilter","text":"zerofilter(psum)\n\nReturn a filtered Pauli sum with only Pauli strings that are not orthogonal to the zero state |0><0|.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#Circuits","page":"Circuits","title":"Circuits","text":"","category":"section"},{"location":"api/Circuits/#Builders","page":"Circuits","title":"Builders","text":"","category":"section"},{"location":"api/Circuits/#PauliPropagation.tfitrottercircuit","page":"Circuits","title":"PauliPropagation.tfitrottercircuit","text":"tfitrottercircuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits), start_with_ZZ=true)\n\nCreate a circuit that corresponds to a Trotterization of the transverse-field Ising Hamiltonian. \n\nH = _(ij)  topology J_ij Z_i Z_j + _i=1  nqubits h_i X_i\n\nThis returns only the sequence of gates, not their parameters. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used. If start_with_ZZ is set to true, the circuit starts with a layer of ZZ gates, else with a layer of X gates. This is relevant depending on the initial state.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.tiltedtfitrottercircuit","page":"Circuits","title":"PauliPropagation.tiltedtfitrottercircuit","text":"tiltedtfitrottercircuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits))\n\nCreate a circuit that corresponds to a Trotterization of the transverse-field Ising Hamiltonian. \n\nH = _(ij)  topology J_ij Z_i Z_j \n  + _i=1  nqubits h_i Z_i +  _i=1  nqubits b_i X_i\n\nThis returns only the sequence of gates, not their parameters. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.heisenbergtrottercircuit","page":"Circuits","title":"PauliPropagation.heisenbergtrottercircuit","text":"heisenbergtrottercircuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits))\n\nCreate a circuit that corresponds to a Trotterization of the Heisenberg Hamiltonian.\n\nH = _(ij)  topology Jzz_ij Z_i Z_j + Jxx_ij X_i X_j + Jyy_ij Y_i Y_j\n\nThis returns only the sequence of gates, not their parameters. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used. Note that the gates are applied as layers of XX-YY-ZZ gates, not as layers of XX on all, then YY on all, then ZZ on all.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.hardwareefficientcircuit","page":"Circuits","title":"PauliPropagation.hardwareefficientcircuit","text":"hardwareefficientcircuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits))\n\nCreate a hardware-efficient circuit consisting of layers of single-qubit X-Z-X Pauli gates and YY entangling gates. A topology can be specified as a list of pairs of qubit indices.  If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.efficientsu2circuit","page":"Circuits","title":"PauliPropagation.efficientsu2circuit","text":"efficientsu2circuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits))\n\nCreate a hardware-efficient circuit consisting of layers of single-qubit Y-Z Pauli gates and CNOT entangling gates. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.su4circuit","page":"Circuits","title":"PauliPropagation.su4circuit","text":"su4circuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits))\n\nCreate a circuit that consists of layers of SU(4) gates on a given topology.  SU(4) gates are decomposed via the KAK Decomposition into single-qubit Z-X-Z gates on each qubit, followed by XX-YY-ZZ gates and again single-qubit Z-X-Z gates, for a total of 15 Pauli gates. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.rxlayer!","page":"Circuits","title":"PauliPropagation.rxlayer!","text":"rxlayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:X, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.rylayer!","page":"Circuits","title":"PauliPropagation.rylayer!","text":"rylayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:Y, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.rzlayer!","page":"Circuits","title":"PauliPropagation.rzlayer!","text":"rzlayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:Z, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.rxxlayer!","page":"Circuits","title":"PauliPropagation.rxxlayer!","text":"rxxlayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:X, :X], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.ryylayer!","page":"Circuits","title":"PauliPropagation.ryylayer!","text":"ryylayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:Y, :Y], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.rzzlayer!","page":"Circuits","title":"PauliPropagation.rzzlayer!","text":"rzzlayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:Z, :Z], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.qcnncircuit","page":"Circuits","title":"PauliPropagation.qcnncircuit","text":"qcnncircuit(nqubits::Integer; periodic=false)\n\nCreate a Quantum Convolutional Neural Network (QCNN) circuit on nqubits qubits. The topology for the circuit is created by creating bricklayer topologies on half the qubits every layer. The final qubits are qubit 1 and ~nqubits/2, which should be measured.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.appendSU4!","page":"Circuits","title":"PauliPropagation.appendSU4!","text":"appendSU4!(circuit, pair)\n\nAppend a layer of SU(4) gates to a circuit on a given pair of qubits. The SU(4) gate is decomposed via the KAK Decomposition into single-qubit Z-X-Z gates on each qubit, followed by XX-YY-ZZ gates and again single-qubit Z-X-Z gates, for a total of 15 Pauli gates.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#Topologies","page":"Circuits","title":"Topologies","text":"","category":"section"},{"location":"api/Circuits/#PauliPropagation.bricklayertopology-Tuple{Any}","page":"Circuits","title":"PauliPropagation.bricklayertopology","text":"bricklayertopology(qindices; periodic=false)\n\nCreate the topology of a so-called 1D bricklayer circuit on a subset of qubits indicated by qindices. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.bricklayertopology-Tuple{Integer}","page":"Circuits","title":"PauliPropagation.bricklayertopology","text":"bricklayertopology(nqubits::Integer; periodic=false)\n\nCreate the topology of a so-called 1D bricklayer circuit on nqubits qubits. It consists of two sublayers connecting odd-even and eve-odd qubit indices, respectively. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rectangletopology-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.rectangletopology","text":"rectangletopology(nx::Integer, ny::Integer; periodic=false)\n\nCreate a 2D topology on a grid of nx by ny qubits. The order is none in particular and may need to be adapted for specific purposes. If periodic is set to true, the grid is connected periodically in both directions.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.staircasetopology-Tuple{Integer}","page":"Circuits","title":"PauliPropagation.staircasetopology","text":"staircasetopology(nqubits::Integer; periodic=false)\n\nCreate a 1D staircase topology on nqubits qubits. The qubits are connected in a staircase pattern, where qubit i is connected to qubit i+1. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.staircasetopology2d-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.staircasetopology2d","text":"staircasetopology2d(nx::Integer, ny::Integer)\n\nCreate a 2D staircase topology on a grid of nx by ny qubits. Mind the order of the topology, which forms a staircase spanning the grid -> in the Schrödinger picture <-.  An observable acting on qubits index nqubits may interact non-trivially with every gate on the topology.  Can topology can either be pathological or the most simple, depending on which index observables are non-identity.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.ibmeagletopology","page":"Circuits","title":"PauliPropagation.ibmeagletopology","text":"ibmeagletopology\n\nTopology of the IBM Eagle device with 127 qubits. Also called the heave-hex topology on 127 qubits.\n\n\n\n\n\n","category":"constant"},{"location":"api/Circuits/#Utils","page":"Circuits","title":"Utils","text":"","category":"section"},{"location":"api/Circuits/#PauliPropagation.countparameters-Tuple{Any}","page":"Circuits","title":"PauliPropagation.countparameters","text":"countparameters(circuit)\n\nUtility function to count the number of gates of type ParametrizedGate in a circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Tuple{Any, Type{PauliRotation}, Vector{Symbol}, Vector{Int64}}","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, ::PauliRotation, gate_symbols::Vector{Symbol}), qinds::Vector{Int})\n\nUtility function to get the parameter indices of PauliRotation gates with symbol gate_symbols acting on the qubits qinds. For example, getparameterindices(circuit, PauliRotation, [:X], [1]).\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Tuple{Any, Type{PauliRotation}, Vector{Symbol}}","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, ::PauliRotation, gate_symbols::Vector{Symbol}))\n\nUtility function to get the parameter indices of PauliRotation gates with symbol gate_symbols. For example, getparameterindices(circuit, PauliRotation, [:X]).\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Union{Tuple{GT}, Tuple{Any, Type{GT}}} where GT<:ParametrizedGate","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, GateType<:ParametrizedGate)\n\nUtility function to get the parameter indices of gates of type GateType in a circuit. This naturally only works for gates that subtype ParametrizedGate.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#Propagation","page":"Propagation","title":"Propagation","text":"","category":"section"},{"location":"api/Propagation/#Generics","page":"Propagation","title":"Generics","text":"","category":"section"},{"location":"api/Propagation/#PauliPropagation.apply-Union{Tuple{SG}, Tuple{SG, Any, Any, Any}} where SG<:StaticGate","page":"Propagation","title":"PauliPropagation.apply","text":"apply(gate::StaticGate, pstr, coeff, theta)\n\nCalling apply on a StaticGate will dispatch to a 3-argument apply function without the paramter theta. If a 4-argument apply function is defined for a concrete type, it will still dispatch to that one. See the 4-custom-gates.ipynb for examples of how to define custom gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applyandadd!-NTuple{5, Any}","page":"Propagation","title":"PauliPropagation.applyandadd!","text":"applyandadd!(gate, pstr, coefficient, theta, output_psum; kwargs...)\n\n3rd-level function below applymergetruncate! that applies one gate to one Pauli string in psum, moving results into output_psum by default. This function can be overwritten for a custom gate if the lower-level function apply is not sufficient.  This is likely the the case if apply is not type-stable because it does not return a unique number of outputs.  E.g., a Pauli gate returns 1 or 2 (pstr, coefficient) outputs. See the 4-custom-gates.ipynb for examples of how to define custom gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applymergetruncate!-NTuple{5, Any}","page":"Propagation","title":"PauliPropagation.applymergetruncate!","text":"applymergetruncate!(gate, psum, aux_psum, thetas, param_idx; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\n1st-level function below propagate! that applies one gate to all Pauli strings in psum, potentially using aux_psum in the process, and merges everything back into psum. Truncations are checked here after merging. This function can be overwritten for a custom gate if the lower-level functions applytoall!, applyandadd!, and apply are not sufficient.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-NTuple{4, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate, theta psum, output_psum; kwargs...)\n\n2nd-level function below applymergetruncate! that applies one gate to all Pauli strings in psum, moving results into output_psum by default. After this functions, Pauli strings in remaining in psum and output_psum are merged. This function can be overwritten for a custom gate if the lower-level functions applyandadd! and apply are not sufficient. In particular, this function can be used to manipulate both psum and output_psum at the same time to reduce memory movement. Note that manipulating psum on anything other than the current Pauli string will likely lead to errors. See the 4-custom-gates.ipynb for examples of how to define custom gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.propagate","page":"Propagation","title":"PauliPropagation.propagate","text":"propagate(circ, psum::PauliSum, thetas=nothing; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nPropagate a PauliSum through the circuit circ in the Heisenberg picture.  This means that the circuit is applied to the Pauli sum in reverse order, and the action of each gate is its conjugate action. Parameters for the parametrized gates in circ are given by thetas, and need to be passed as if the circuit was applied as written in the Schrödinger picture. If thetas are not passed, the circuit must contain only non-parametrized StaticGates. Default truncations are max_weight, min_abs_coeff, max_freq, and max_sins. max_freq, and max_sins will lead to automatic conversion if the coefficients are not already wrapped in suitable PathProperties objects. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#PauliPropagation.propagate-2","page":"Propagation","title":"PauliPropagation.propagate","text":"propagate(circ, pstr::PauliString, thetas=nothing; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nPropagate a PauliString through the circuit circ in the Heisenberg picture.  This means that the circuit is applied to the Pauli string in reverse order, and the action of each gate is its conjugate action. Parameters for the parametrized gates in circ are given by thetas, and need to be passed as if the circuit was applied as written in the Schrödinger picture. If thetas are not passed, the circuit must contain only non-parametrized StaticGates. Default truncations are max_weight, min_abs_coeff, max_freq, and max_sins. max_freq, and max_sins will lead to automatic conversion if the coefficients are not already wrapped in suitable PathProperties objects. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#PauliPropagation.propagate!","page":"Propagation","title":"PauliPropagation.propagate!","text":"propagate!(circ, psum::PauliSum, thetas=nothing; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nPropagate a Pauli sum  through the circuit circ in the Heisenberg picture.  This means that the circuit is applied to the Pauli sum in reverse order, and the action of each gate is its conjugate action. The input psum will be modified. Parameters for the parametrized gates in circ are given by thetas, and need to be passed as if the circuit was applied as written in the Schrödinger picture. If thetas are not passed, the circuit must contain only non-parametrized StaticGates. Default truncations are max_weight, min_abs_coeff, max_freq, and max_sins. max_freq, and max_sins can only be used with suitable PathProperties coefficients like PauliFreqTracker. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#Specializations","page":"Propagation","title":"Specializations","text":"","category":"section"},{"location":"api/Propagation/#PauliPropagation.apply-Tuple{CliffordGate, Integer, Any}","page":"Propagation","title":"PauliPropagation.apply","text":"apply(gate::CliffordGate, pstr::PauliStringType, coeff)\n\nApply a CliffordGate to an integer Pauli string and its coefficient. \n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.apply-Tuple{TransferMapGate, Any, Any}","page":"Propagation","title":"PauliPropagation.apply","text":"apply(gate::TransferMapGate, pstr, coeff)\n\nApply a TransferMapGate to an integer Pauli string and its coefficient. The outcomes are determined by the transfer_map of the gate.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applyandadd!-Tuple{CliffordGate, Vararg{Any, 4}}","page":"Propagation","title":"PauliPropagation.applyandadd!","text":"applyandadd!(gate::CliffordGate, pstr, coeff, theta, output_psum; kwargs...)\n\nOverload of applyandadd! for CliffordGate gates. Use set!() instead of add!() because Clifford gates create non-overlapping Pauli strings. applytoall! does not need to be adapted.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{AmplitudeDampingNoise, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::AmplitudeDampingNoise, theta, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for AmplitudeDampingNoise gates.  It fixes the type-instability of the apply() function and reduces moving Pauli strings between psum and auxpsum. psum and `auxpsum` are merged later.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{FrozenGate, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::FrozenGate, thetas, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for FrozenGates. Re-directs to applytoall! for the wrapped FrozenGate.gate with the frozen parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{PauliNoise, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::PauliNoise, p, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for PauliNoise gates with noise strength p.  It changes the coefficients in-place and does not require the aux_psum, which stays empty.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{PauliRotation, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::PauliRotation, theta, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for PauliRotation gates.  It fixes the type-instability of the apply() function and reduces moving Pauli strings between psum and aux_psum. psum and aux_psum are merged later.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{TGate, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::TGate, thetas, psum, aux_psum; kwargs...)\n\nOverload of applytoall!() for TGate(qind). Redirects to a PauliRotation(:Z, qind) with angle π/4.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.getnewpaulistring-Tuple{MaskedPauliRotation, Integer}","page":"Propagation","title":"PauliPropagation.getnewpaulistring","text":"getnewpaulistring(gate::MaskedPauliRotation, pstr::PauliStringType)\n\nGet the new Pauli string after applying a MaskedPauliRotation to an integer Pauli string, as well as the corresponding ±1 coefficient.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliTransferMatrix/#Pauli-Transfer-Matrix","page":"Pauli Transfer Matrix","title":"Pauli Transfer Matrix","text":"","category":"section"},{"location":"api/PauliTransferMatrix/#Matrices","page":"Pauli Transfer Matrix","title":"Matrices","text":"","category":"section"},{"location":"api/PauliTransferMatrix/#PauliPropagation.calculateptm-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Number","page":"Pauli Transfer Matrix","title":"PauliPropagation.calculateptm","text":"function calculateptm(mat::AbstractMatrix; tol=1e-15, heisenberg=true)\nfunction calculateptm(dtype<:Number, mat::AbstractMatrix; tol=1e-15, heisenberg=true)\n\nCalculate the Pauli Transfer Matrix (PTM) of a matrix mat.  The PTM will be real-valued in the Pauli basis. However, it can be complex in a general basis. Pass an optional data type dtype when entries are not floats. We truncate small complex components and abs values in the PTM using the tol parameter. Note, by default the PTM is calculated in the Heisenberg picture,  i.e., the PTM is that of the conjugate transpose of the  matrix. This can be changed via the heisenberg::Bool keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliTransferMatrix/#Transfer-maps","page":"Pauli Transfer Matrix","title":"Transfer maps","text":"","category":"section"},{"location":"api/PauliTransferMatrix/#PauliPropagation.totransfermap","page":"Pauli Transfer Matrix","title":"PauliPropagation.totransfermap","text":"totransfermap(nq::Integer, circuit::Vector{Gate}, thetas=nothing)\n\nComputes the Pauli transfer map acting on nq qubits from a circuit with parameters thetas. thetas defaults to nothing but is required if the circuit contains parametrized gates. The returned lookup map is a vector of vectors like [(pstr1, coeff1), (pstr2, coeff2), ...], where the pstr are partial Pauli strings on the affected qubits.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliTransferMatrix/#PauliPropagation.totransfermap-Tuple{AbstractMatrix}","page":"Pauli Transfer Matrix","title":"PauliPropagation.totransfermap","text":"totransfermap(ptm::AbstractMatrix)\n\nComputes the Pauli transfer map acting on nq qubits from a Pauli Transfer Matrix (PTM). The PTM should be the matrix representation of a gate in Pauli basis. The returned lookup map is a vector of vectors like [(pstr1, coeff1), (pstr2, coeff2), ...], where the pstr are partial Pauli strings on the affected qubits.\n\n\n\n\n\n","category":"method"},{"location":"api/NumericalCertificates/#Numerical-Certificates","page":"Numerical Certificates","title":"Numerical Certificates","text":"","category":"section"},{"location":"api/NumericalCertificates/#PauliPropagation.estimatemse","page":"Numerical Certificates","title":"PauliPropagation.estimatemse","text":"estimatemse(circ, pstr::PauliString, n_mcsamples::Integer, thetas=π; stateoverlapfunc=overlapwithzero, circuit_is_reversed=false, customtruncfunc=nothing)\n\nFunction to estimate the mean square error of a truncated circuit simulation using Monte Carlo sampling. Returns the mean squared error of the truncated Pauli propagation simulation averaged over the thetas∈ [theta, theta] of the angle theta of each PauliRotation. Currently, the function only supports circuits with PauliRotation and CliffordGate gates.\n\nThe length the thetas vector should be equal to the number of parametrized gates in the circuit.  Alternatively, thetas can be a single real number applicable for all parametrized gates. The default thetas=π or any other non-array values assume that the circuit consists only of PauliRotation -CliffordGate. For PauliRotation, the value should be the integration range of the parameters around zero.\n\nAn initial state overlap function stateoverlapfunc can be provided to calculate the overlap of the backpropagated Pauli strings with the initial state. Importantly, the kwargs can be used to set the truncation parameters of the Pauli propagation. Currently supported are max_weight, max_freq, and max_sins. Note that min_abs_coeff is not supported here, as we consider errors integrated over the angles. max_freq effectively truncates small coefficients below (1/2)^max_freq on average over thetas ∈ [-π, π]. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool.\n\n\n\n\n\n","category":"function"},{"location":"api/NumericalCertificates/#PauliPropagation.estimatemse!-Tuple{Any, PauliString, AbstractVector, Any, Any}","page":"Numerical Certificates","title":"PauliPropagation.estimatemse!","text":"estimatemse!(\ncirc, pstr::PauliString, error_array::AbstractVector, thetas, split_probabilities; \nstateoverlapfunc=overlapwithzero, circuit_is_reversed=false, max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing\n)\n\nIn-place version of estimatemse. This function takes an array error_array of length n_mcsamples as an argument and modifies it in-place.  It further assumes that the thetas and split_probabilities are already correctly calculated and provided as arguments.  In general they will be vectors, but they can also be real numbers. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Pauli-Algebra","page":"Pauli Algebra","title":"Pauli Algebra","text":"","category":"section"},{"location":"api/PauliAlgebra/#Data-types","page":"Pauli Algebra","title":"Data types","text":"","category":"section"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliString","page":"Pauli Algebra","title":"PauliPropagation.PauliString","text":"PauliString(nqubits::Int, pauli::Symbol, qind::Integer, coeff=1.0)\nPauliString(nqubits::Int, paulis::Vector{Symbol}, qinds::Vector{Integer}, coeff=1.0)\n\nConstructor for a PauliString on nqubits qubits from a Symbol (:I, :X, :Y, :Z) or Vector{Symbol}. Provide the index or indices for those symbols as qind or qinds. The coefficient of the Pauli string in the Pauli sum defaults to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliString-2","page":"Pauli Algebra","title":"PauliPropagation.PauliString","text":"PauliString(nqubits::Int, term::TermType, coeff::CoeffType)\n\nPauliString is a struct that represents a Pauli string on nqubits qubits. Commonly term is an unsigned Integer.  See the other PauliString constructors for higher-level usage. \n\n\n\n\n\n","category":"type"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(nqubits::Int, terms::Dict)\n\nPauliSum is a struct that represents a sum of Pauli strings acting on nqubits qubits. It is a wrapper around a dictionary Dict(Pauli string => coefficient}, where the Pauli strings are typically unsigned Integers for efficiency reasons.\n\n\n\n\n\n","category":"type"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Tuple{Int64}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(nqubits::Integer)\n\nContructor for an empty PauliSum on nqubits qubits. Element type defaults for Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(pstr::PauliString)\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Tuple{Union{Tuple, Base.Generator, AbstractArray}}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(pstrs::Vector{PauliString})\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Union{Tuple{CT}, Tuple{TT}, Tuple{Integer, PauliString{TT, CT}}} where {TT, CT}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(nq::Integer, pstr::PauliString)\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Union{Tuple{CT}, Tuple{Type{CT}, Int64}} where CT","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(CoeffType, nq::Int)\n\nContructor for an empty PauliSum on nqubits qubits. The type of the coefficients can be provided.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:*-Tuple{PauliString, Number}","page":"Pauli Algebra","title":"Base.:*","text":"*(pstr::PauliString, c::Number)\n\nMultiply a PauliString by a scalar c. Returns a new PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:*-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"Base.:*","text":"*(pstr1::PauliString, pstr2::PauliString)\n\nPerform a Pauli product of two PauliStrings. \n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:*-Tuple{PauliSum, Number}","page":"Pauli Algebra","title":"Base.:*","text":"*(psum::PauliSum, c::Number)\n\nMultiply a PauliSum by a scalar c. This copies the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:*-Tuple{PauliSum, PauliString}","page":"Pauli Algebra","title":"Base.:*","text":"*(pstr::PauliString, psum::PauliSum)\n*(psum::PauliSum, pstr::PauliString)\n\nPerform a Pauli product of a PauliString with a PauliSum. Returns a PauliSum with complex coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:*-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"Base.:*","text":"*(psum1::PauliSum, psum2::PauliSum)\n\nPerform a Pauli product of two PauliSums. Returns a PauliSum with complex coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT2}, Tuple{TT1}, Tuple{PauliSum{TT1, CT1}, PauliSum{TT2, CT2}}} where {TT1, TT2, CT1, CT2}","page":"Pauli Algebra","title":"Base.:+","text":"+(psum1::PauliSum, psum2::PauliSum)\n\nAddition of two PauliSums. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT}, Tuple{PauliString{TT, CT1}, PauliString{TT, CT2}}} where {TT, CT1, CT2}","page":"Pauli Algebra","title":"Base.:+","text":"+(pstr1::PauliString, pstr2::PauliString)\n\nAddition of two PauliStrings. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT}, Tuple{PauliSum{TT, CT1}, PauliString{TT, CT2}}} where {TT, CT1, CT2}","page":"Pauli Algebra","title":"Base.:+","text":"+(pstr::PauliString, psum::PauliSum)\n+(psum::PauliSum, pstr::PauliString)\n\nAddition of a PauliString to a PauliSum. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, Number}} where {TT, CT}","page":"Pauli Algebra","title":"Base.:+","text":"+(psum::PauliSum, c::Number)\n+(c::Number, psum::PauliSum)\n\nAddition of c * Identity to a PauliSum. This copies the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:--Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"Base.:-","text":"-(pstr1::PauliString, pstr2::PauliString)\n\nSubtract two PauliStrings. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:--Tuple{PauliSum, PauliString}","page":"Pauli Algebra","title":"Base.:-","text":"-(pstr::PauliString, psum::PauliSum)\n-(psum::PauliSum, pstr::PauliString)\n\nSubtract a PauliString from a PauliSum or vice versa. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:--Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"Base.:-","text":"-(psum1::PauliSum, psum2::PauliSum)\n\nSubtract two PauliSums. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:/-Tuple{PauliString, Number}","page":"Pauli Algebra","title":"Base.:/","text":"/(pstr::PauliString, c::Number)\n\nDivide a PauliString by a scalar c. Returns a new PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:/-Tuple{PauliSum, Number}","page":"Pauli Algebra","title":"Base.:/","text":"/(psum::PauliSum, c::Number)\n\nDivide a PauliSum by a scalar c. This copies the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:==-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"Base.:==","text":"==(psum1::PauliSum, psum2::PauliSum)\n\nEquality check for PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:≈-Union{Tuple{CT2}, Tuple{TT2}, Tuple{CT1}, Tuple{TT1}, Tuple{PauliSum{TT1, CT1}, PauliSum{TT2, CT2}}} where {TT1, CT1, TT2, CT2}","page":"Pauli Algebra","title":"Base.:≈","text":"≈(psum1::PauliSum, psum2::PauliSum)\n\nApproximate equality check for PauliSum. Simply calls isapprox() on the coefficients of the contained Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.copy-Tuple{PauliSum}","page":"Pauli Algebra","title":"Base.copy","text":"Copy a PauliSum by copying its terms field.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.empty!-Tuple{PauliSum}","page":"Pauli Algebra","title":"Base.empty!","text":"empty!(psum::PauliSum)\n\nEmpty the PauliSum by emptying the dictionary on the terms fields. \n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.iterate","page":"Pauli Algebra","title":"Base.iterate","text":"Iterator for PauliSum returns an iterator over (pstr, coeff) pairs`.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliAlgebra/#Base.length-Tuple{PauliSum}","page":"Pauli Algebra","title":"Base.length","text":"length(psum::PauliSum)\n\nNumber of terms in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.similar-Tuple{PauliSum}","page":"Pauli Algebra","title":"Base.similar","text":"similar(psum::PauliSum)\n\nCreate a new PauliSum with the same number of qubits and coefficient type as psum. Calls sizehint!() with length(psum) on the dictionary of the new PauliSum. \n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.sizehint!-Tuple{PauliSum, Any}","page":"Pauli Algebra","title":"Base.sizehint!","text":"sizehint!(psum::PauliSum, n)\n\nHint to the PauliSum to reserve space for n terms.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._checknumberofqubits-Tuple{Union{Tuple, Base.Generator, AbstractArray}}","page":"Pauli Algebra","title":"PauliPropagation._checknumberofqubits","text":"Checks whether the number of qubits nqubits is the same between in some collection.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.add!","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum::PauliSum, pauli::Symbol, qind::Integer, coeff=1.0)\nadd!(psum::PauliSum, paulis::Vector{Symbol}, qinds::Vector{Integer}, coeff=1.0)\n\nAdd a Pauli string to a PauliSum psum. Changes psum in-place. Provide the Pauli string as a Symbol (:I, :X, :Y, :Z) or Vector{Symbol}. Provide the index or indices for those symbols as qind or qinds. The coefficient of the Pauli string in the Pauli sum defaults to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliAlgebra/#PauliPropagation.add!-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT2}, Tuple{TT1}, Tuple{PauliSum{TT1, CT1}, PauliString{TT2, CT2}}} where {TT1, TT2, CT1, CT2}","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum::PauliSum, pstr::PauliString)\n\nAdd a PauliString pstr to a PauliSum psum. Changes psum in-place. psum and pstr need to be defined on the same number of qubits and have the same coefficient type.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.add!-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT2}, Tuple{TT1}, Tuple{PauliSum{TT1, CT1}, PauliSum{TT2, CT2}}} where {TT1, TT2, CT1, CT2}","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum1::PauliSum, psum2::PauliSum)\n\nAdd two PauliSums psum1 and psum2. Changes psum1 in-place. psum1 and psum2 need to be defined on the same number of qubits and have the same coefficient type.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.add!-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT}, Tuple{PauliSum{TT, CT1}, TT, CT2}} where {TT, CT1, CT2}","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum::PauliSum{Integer, CoeffType}, pstr::Integer, coeff::CoeffType)\n\nAdd a Pauli string pstr with coefficient coeff to a PauliSum psum. This changes psum in-place. pstr needs to have the same type as paulitype(psum), and coeff needs to have the same type as coefftype(psum).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.coefficients-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.coefficients","text":"coefficients(psum::PauliSum)\n\nReturns an iterator over the coefficients of a PauliSum. Call topaulistrings to receive entries as PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.coefftype-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.coefftype","text":"coefftype(pstr::PauliString)\n\nGet the coefficient type of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.coefftype-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.coefftype","text":"coefftype(psum::PauliSum)\n\nGet the coefficient type of a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Tuple{PauliSum, Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pstr::Vector{Symbol}, qinds::Vector{Int})\n\nGet the coefficient of a Pauli string in a PauliSum by providing the Pauli string pstr as a vector of Symbols acting on qubits qinds.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Tuple{PauliSum, Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pauli::Symbol, qind::Integer)\n\nGet the coefficient of a Pauli string in a PauliSum by providing the Pauli string as a Symbol acting on qubit qind.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Tuple{PauliSum, Vector{Symbol}}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pstr::Vector{Symbol})\n\nGet the coefficient of a Pauli string in a PauliSum by providing the Pauli string pstr as a vector of Symbols acting on all qubits.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT2}, Tuple{TT1}, Tuple{PauliSum{TT1, CT1}, PauliString{TT2, CT2}}} where {TT1, TT2, CT1, CT2}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pstr::PauliString)\n\nGet the coefficient of a PauliString in a PauliSum. Defaults to 0 if the Pauli string is not in the PauliSum. Requires that the integer Pauli string in pstr is the same type as the integer Pauli strings in psum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Union{Tuple{CT}, Tuple{TT2}, Tuple{TT1}, Tuple{PauliSum{TT1, CT}, TT2}} where {TT1, TT2, CT}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pstr::Integer)\n\nGet the coefficient of an integer Pauli string in a PauliSum. Defaults to 0 if the Pauli string is not in the PauliSum. Requires that the integer Pauli string pstr is the same type as the integer Pauli strings in psum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.mult!-Tuple{PauliSum, Number}","page":"Pauli Algebra","title":"PauliPropagation.mult!","text":"mult!(psum::PauliSum, c::Number)\n\nMultiply a PauliSum by a scalar c in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.norm","page":"Pauli Algebra","title":"PauliPropagation.norm","text":"norm(psum::PauliSum, L=2)\n\nCalculate the norm of a PauliSum with respect to the L-norm.  Calls LinearAlgebra.norm on the coefficients of the PauliSum.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliAlgebra/#PauliPropagation.numcoefftype-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.numcoefftype","text":"numcoefftype(pstr::PauliString)\n\nGet the type of the numerical coefficient of a PauliString.  Will return the type of the output of  tonumber(pstr.coeff).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.numcoefftype-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.numcoefftype","text":"numcoefftype(psum::PauliSum)\n\nGet the type of the numerical coefficient of a PauliSum by calling numcoefftype() on the coefficients. If the PauliSum is empty, an error is thrown because the type cannot be inferred.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.paulis-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.paulis","text":"paulis(psum::PauliSum)\n\nReturns an iterator over the integer pauli strings of a PauliSum. Call topaulistrings to receive entries as PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.paulitype-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.paulitype","text":"paulitype(pstr::PauliString)\n\nGet the Pauli integer type of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.paulitype-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.paulitype","text":"paulitype(psum::PauliSum)\n\nGet the Pauli integer type of a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.set!-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT}, Tuple{PauliSum{TT, CT1}, TT, CT2}} where {TT, CT1, CT2}","page":"Pauli Algebra","title":"PauliPropagation.set!","text":"set!(psum::PauliSum{TermType, CoeffType}, pstr::TermType, coeff::CoeffType)\n\nIn-place setting the coefficient of a Pauli string in a PauliSum dictionary. The type of the Pauli string needs to be the keytype=TermType of the dictionary, and the coefficient coeff needs to be the valuetype=CoeffType.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.tonumber-Tuple{Number}","page":"Pauli Algebra","title":"PauliPropagation.tonumber","text":"tonumber(val::Number)\n\nTrivial function returning a numerical value of a number. Will be overloaded for custom wrapper types like PathProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.topaulistrings-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.topaulistrings","text":"topaulistrings(psum::PauliSum)\n\nReturns the Pauli strings in a PauliSum and their coefficients as a list of PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Pauli-operations","page":"Pauli Algebra","title":"Pauli operations","text":"","category":"section"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(pstr1::Integer, pstr2::Integer)\n\nCalculate the commutator of two integer Pauli strings. Returns a tuple of the coefficient and the potentially integer Pauli string. The coefficient is zero if the Pauli strings commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(pstr1::PauliString, pstr2::PauliString)\n\nCalculate the commutator of two PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliSum, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(psum::PauliSum, pstr::PauliString)\ncommutator(pstr::PauliString, psum::PauliSum)\n\nCalculate the commutator of a PauliSum and a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(psum1::PauliSum, psum2::PauliSum)\n\nCalculate the commutator of two PauliSums.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(pstr1::Integer, pstr2::Integer)\n\nCheck if two integer Pauli strings commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(pstr1::PauliString, pstr2::PauliString)\n\nCheck if two Pauli strings of type PauliString commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(psum1::PauliSum, psum2::PauliSum)\n\nCheck if two Pauli sums of type PauliSum commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsXorY-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.containsXorY","text":"containsXorY(pstr::Integer)\n\nCheck if an integer Pauli string contains an X or Y Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsXorY-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.containsXorY","text":"containsXorY(pstr::PauliString)\n\nCheck if a Pauli string contains an X or Y Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsYorZ-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.containsYorZ","text":"containsYorZ(pstr::Integer)\n\nCheck if an integer Pauli string contains a Y or Z Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsYorZ-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.containsYorZ","text":"containsXorY(pstr::PauliString)\n\nCheck if a Pauli string contains a Y or Z Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(pstr::Integer)\n\nFunction to count the weight of an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(pstr::PauliString)\n\nFunction to count the weight of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(psum::PauliSum)\n\nFunction to count the weight Pauli strings in a PauliSum. Returns an array of weights.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(pstr::Integer)\n\nFunction to count the number of X and Y Paulis in an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(pstr::PauliString)\n\nFunction to count the number of X and Y Paulis in a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(psum::PauliSum)\n\nFunction to count the number of X and Y Paulis in a PauliSum. Returns an array of counts.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(pstr::Integer)\n\nFunction to count the number of Y and Z Paulis in an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(pstr::PauliString)\n\nFunction to count the number of Y and Z Paulis in a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(psum::PauliSum)\n\nFunction to count the number of Y and Z Paulis in a PauliSum. Returns an array of counts.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pstr1::Integer, pstr2::Integer)\n\nCalculate the product of two integer Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pstr1::PauliString, pstr2::PauliString)\n\nCalculate the product of two PauliStrings. For example X*Y = iZ.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Bit-operations","page":"Pauli Algebra","title":"Bit operations","text":"","category":"section"},{"location":"api/PauliAlgebra/#PauliPropagation.getinttype-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.getinttype","text":"getinttype(nqubits::Integer)\n\nFunction to return the smallest integer type that can hold nqubits. This is the type that will be used internally for representing Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Utils","page":"Pauli Algebra","title":"Utils","text":"","category":"section"},{"location":"api/PauliAlgebra/#PauliPropagation.getpauli-Tuple{Integer, Any}","page":"Pauli Algebra","title":"PauliPropagation.getpauli","text":"getpauli(pstr::PauliStringType, qinds::Vector{Integer})\n\nGets the Paulis on indices qinds of a pstr in the integer representation.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttostring-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttostring","text":"inttostring(pstr::PauliType, nqubits::Integer)\n\nReturns a string representation of an integer Pauli string pstr on nqubits qubits. The characters of the string from left to right are the Paulis on the qubits from 1 to nqubits.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttosymbol-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttosymbol","text":"inttosymbol(pstr::PauliStringType, nqubits::Integer)\n\nMaps an integer Pauli string to a vector of symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttosymbol-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttosymbol","text":"inttosymbol(pauli::PauliType)\n\nMaps an integer Pauli to its corresponding symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.ispauli-Tuple{Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.ispauli","text":"ispauli(pauli1::Union{Symbol, PauliType}, pauli2::Union{Symbol, PauliType})\n\nispauli(pauli1::Union{Vector{Symbol}, PauliStringType}, pauli2::Union{Vector{Symbol}, PauliStringType})\n\nCheck if two Paulis are equal, where one is given as a symbol and the other as an integer.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(\n    pstr::PauliStringType, \n    target_paulis::Vector{Symbol}, \n    qinds::Vector{Integer}\n)\n\nSet the Paulis qinds of an integer Pauli string pstr to target_paulis. target_paulis is a vector of symbols. Use tuples in performance critical functions because they are immutable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Integer, Any}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(\n    pstr::PauliStringType, \n    target_paulis::PauliStringType, \n    qinds::Vector{Integer}\n)\n\nSet the Paulis qinds of an integer Pauli string pstr to target_paulis. Use Tuples for qinds in performance critical functions because they are immutable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(pstr::PauliStringType, target_pauli::PauliType, index::Integer)\n\nSets the Pauli on index index of an integer Pauli string to target_pauli.  That Pauli should be provided as integer (0, 1, 2, 3).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(pstr::PauliStringType, target_pauli::Symbol, index::Integer)\n\nSets the Pauli on index of an integer Pauli string to target_pauli.  That Pauli should be provided as a symbol (:I, :X, :Y, :Z).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Any}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(pstr::Union{Vector{Symbol}, Symbol})\n\nMaps a symbol or a vector of symbols pstr to an integer Pauli string.\n\nExample:\n\nsymboltoint([:X, :I])\n>>> 0x01\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Integer, Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(nqubits::Integer, paulis::Vector{Symbol}, qinds::Vector{Int})\n\nMaps a vector of symbols pstr acting on the indices qinds to an integer Pauli string. Other sites are set to the identity. qinds can be any iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Integer, Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(nqubits::Integer, pauli::Symbol, qind::Integer)\n\nMaps a single symbol pauli acting on the index qind to an integer Pauli string. Other sites are set to the identity.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Symbol}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(pauli::Symbol)\n\nMaps a single symbol to its corresponding integer representation.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Union{Tuple{TT}, Tuple{Type{TT}, Any, Any}} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(::PauliStringType, paulis, qinds)\n\nMaps a vector of symbols paulis acting on the indices qinds to an integer Pauli string with type PauliStringType. Other sites are set to the identity. qinds can be any iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Union{Tuple{TT}, Tuple{Type{TT}, Symbol, Integer}} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(::PauliStringType, pauli::Symbol, qind::Integer)\n\nMaps a single symbol pauli acting on the index qind to an integer Pauli string with type PauliStringType. Other sites are set to the identity.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"Documentation Paper\n(Image: )(Image: ) (Image: arXiv)","category":"page"},{"location":"#PauliPropagation.jl","page":"Home","title":"PauliPropagation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PauliPropagation.jl is a Julia package for simulating Pauli propagation in quantum circuits and systems. It focuses on simulating the evolution of observables expressed in the Pauli basis under the action of unitary gates and non-unitary channels in a quantum circuit.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unlike traditional simulators which simulate a circuit mathcalE evolving the state rho in the Schrödinger picture, Pauli propagation often adopts the Heisenberg picture, evolving an observable O under mathcalE^dagger. This can be particularly efficient when the observables remain sparse or structured under evolution, and is useful for estimating expectation values such as textTrleftrho mathcalE^dagger(O)right, studying operator dynamics, and computing correlation functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pauli propagation is related to the so-called (extended) stabilizer simulation, but is fundamentally different from, for example, tensor networks. It offers a distinct approach that can handle different regimes of quantum dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implemented in Julia, PauliPropagation.jl combines high-performance computation (using features such as multiple dispatch) with an accessible and high-level interface.  ","category":"page"},{"location":"#UnitaryHACK-2025-May-28th-to-June-11th","page":"Home","title":"UnitaryHACK 2025 - May 28th to June 11th","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From May 28th to June 11th we are participating in the 5th edition of the hackathon. Solve these GitHub Issues and collect real money bounties &#128176;&#128176;&#128176;!","category":"page"},{"location":"","page":"Home","title":"Home","text":"The relevant Issues are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"For 200: https://github.com/MSRudolph/PauliPropagation.jl/issues/88\nFor 150: https://github.com/MSRudolph/PauliPropagation.jl/issues/86\nFor 100: https://github.com/MSRudolph/PauliPropagation.jl/issues/87\nFor 50: https://github.com/MSRudolph/PauliPropagation.jl/issues/89","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Note the current package requires Julia 1.10+.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The PauliPropagation.jl package is registered and can be installed into your environment in the following way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"PauliPropagation\")","category":"page"},{"location":"#Install-from-GitHub","page":"Home","title":"Install from GitHub","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you want to install the latest code, you can install the package directly from the Github link. For example, if you are working with a Jupyter notebook, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/MSRudolph/PauliPropagation.jl.git\", rev=\"branchname\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"where you can use the keyword rev=\"branchname\" to install development versions of the package. We don't recommend using branches other than main or dev.","category":"page"},{"location":"#Clone-the-repository-and-install-locally","page":"Home","title":"Clone the repository and install locally","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Navigate to a local directory where you want to clone this repository into and run the following in a terminal","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone git@github.com:MSRudolph/PauliPropagation.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inside this cloned repository, you can now freely import PauliPropagation or install it into your environment.\nAlternatively, you can push the relative path to the cloned repository to the Julia package load path called LOAD_PATH via","category":"page"},{"location":"","page":"Home","title":"Home","text":"rel_path = \"your/relative/path/PauliPropagation\"\npush!(LOAD_PATH,rel_path);","category":"page"},{"location":"","page":"Home","title":"Home","text":"This may require that you have no global installation of PauliPropagation in your enviroment.","category":"page"},{"location":"#A-note-on-installing-Julia","page":"Home","title":"A note on installing Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is recommended to install julia using juliaup with instructions from here. Then, Julia's long-term support version (currently a 1.10 version) can be installed via","category":"page"},{"location":"","page":"Home","title":"Home","text":"juliaup add lts","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get started running Jupyter notebooks, start a Julia session and install the IJulia package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are working on several projects with potentially conflicting packages, it is recommended to work with within local environments or projects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more details, we refer to this useful guide.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can find detailed example notebooks in the examples folder. We provide a brief example of how to use PauliPropagation.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider simulating the dynamics of an operator O=Z_16 under the evolution of a unitary  channel mathcalE(cdot) = U^dagger cdot U in a n=32 qubits system. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PauliPropagation\n\nnqubits = 32\n\nobservable = PauliString(nqubits, :Z, 16) # I...IZI...I","category":"page"},{"location":"","page":"Home","title":"Home","text":"Our goal is to compute","category":"page"},{"location":"","page":"Home","title":"Home","text":"textTrU^dagger O U rho","category":"page"},{"location":"","page":"Home","title":"Home","text":"A simple unitary U is the brickwork circuit, composed of two qubit gates alternating neighbouring sites. We define the circuit connectivity by ","category":"page"},{"location":"","page":"Home","title":"Home","text":"topology = bricklayertopology(nqubits; periodic=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where periodic specifies the boundary condition of the gates. The library has built-in circuits with e.g. a circuit containing alternating RX and RZZ Pauli gates on the topology. This can be defined by Trotterization of a transverse field Ising Hamiltonian with l steps","category":"page"},{"location":"","page":"Home","title":"Home","text":"U = prod_a=1^l prod_j=1^n e^-i dt   X_j e^-i dt Z_j Z_j+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"nlayers = 32 # l as above\n\ncircuit = tfitrottercircuit(nqubits, nlayers; topology=topology)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In our simulations, we can choose the circuit parameter dt","category":"page"},{"location":"","page":"Home","title":"Home","text":"dt = 0.1 # time step\n\nparameters = ones(countparameters(circuit)) * dt # all parameters","category":"page"},{"location":"","page":"Home","title":"Home","text":"Important: The circuit and parameters are defined in the order that they would act in the Schrödinger picture. Within our propagate() function, the order will be reversed to act on the observable. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"During the propagation via propagate(), we employ truncation strategies such as coefficient or weight truncations, these options can be specified as keywords. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"## the truncations\nmax_weight = 6 # maximum Pauli weight\n\nmin_abs_coeff = 1e-4 # minimal coefficient magnitude\n\n## propagate through the circuit\npauli_sum = propagate(circuit, observable, parameters; max_weight, min_abs_coeff)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output pauli_sum gives us an approximation of propagated Pauli strings","category":"page"},{"location":"","page":"Home","title":"Home","text":"U^dagger O U approx sum_alpha c_alpha P_alpha","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally we can compute expectation values with an initial state such as rho = (0 rangle  langle 0 )^otimes n","category":"page"},{"location":"","page":"Home","title":"Home","text":"## overlap with the initial state\noverlapwithzero(pauli_sum)\n# yields 0.154596728241...","category":"page"},{"location":"","page":"Home","title":"Home","text":"This computation is efficient because the initial state can be written in terms of only mathbbI and Z strings","category":"page"},{"location":"","page":"Home","title":"Home","text":"rho = left(fracmathbbI + Z2right)^otimes n","category":"page"},{"location":"","page":"Home","title":"Home","text":"Therefore, the trace is equivalent to the sum over the coefficients of Pauli strings containing only I and Z Paulis, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathrmTrU^dagger O U rho approx sum_alpha in mathbbI Z textstrings c_alpha","category":"page"},{"location":"#Important-Notes-and-Caveats","page":"Home","title":"Important Notes and Caveats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Circuits are specified in the Schrödinger picture, as if operated upon states. Behind the scenes, propagate() will (by default) apply the adjoint circuit upon the passed PauliSum which is treated as the observable operator.\nSchrödinger propagation is planned but not yet supported except through manually passing the adjoint of the intended circuit to propagate(). This is often easy. For instance, with the circuit order reversed, angles in PauliRotation gates are negated, and CliffordGate are passed to transposecliffordmap().\nWhile Pauli propagation can, in principle, be used for extended stabilizer simulation, we do not currently support sub-exponential strong simulation of stabilizer states.\nSampling quantum states is currently not supported.\nMany underlying data structures and functions can be used for other purposes involving Pauli operators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All of the above can be addressed by writing the additional missing code due to the nice extensibility of Julia.","category":"page"},{"location":"#Upcoming-Features","page":"Home","title":"Upcoming Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is still work-in-progress. You will probably find certain features that you would like to have and that are currently missing.\nHere are some features that we want to implement in the future. Feel free to contribute!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multi-threading and improved scalability. Currently, PauliPropagation.jl works uses a single CPU thread and may run your hardware out of memory. Future versions should be even faster and with options to trade-off computational runtime and memory requirements. \nEasier Schrödinger picture propagation. Currently, the default is Heisenberg and there is no easy way to transpose the gates.\nA fast and flexible Surrogate version. Currently, we provide a version of the Pauli propagation Surrogate that is good and works, at least for Pauli gates and Clifford gates. Stay tuned for a whole lot more.","category":"page"},{"location":"#How-to-contribute","page":"Home","title":"How to contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have a Slack channel #pauli-propagation in the Julia Slack.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If something bothers you or you want to propose an enhancement, please open an Issue describing everything in detail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a concrete change of code, please fork this GitHub repository and submit a Pull Request.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Otherwise, feel free to reach out to the developers!","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main developer of this package is Manuel S. Rudolph in the Quantum Information and Computation Laboratory of Prof. Zoë Holmes at EPFL, Switzerland. Contact Manuel via manuel.rudolph@epfl.ch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Further contributors to this package include Yanting Teng, Tyson Jones, and Su Yeon Chang. This package is the derivative of ongoing work at the Quantum Information and Computation lab at EPFL, supervised by Prof. Zoë Holmes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more specific code issues, bug fixes, etc. please open a GitHub issue.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are publishing research using PauliPropagation.jl, please cite this library and our paper: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{rudolph2025pauli,\n  title={Pauli Propagation: A Computational Framework for Simulating Quantum Systems},\n  author={Rudolph, Manuel S and Jones, Tyson and Teng, Yanting and Angrisani, Armando and Holmes, Zoe},\n  journal={arXiv preprint arXiv:2501.13101},\n  year={2025},\n  url={https://arxiv.org/abs/2501.13101}\n}","category":"page"},{"location":"#Related-publications","page":"Home","title":"Related publications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some of the developers of this package are co-authors in the following papers using Pauli propagation and (at least parts of) this code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Classical simulations of noisy variational quantum circuits\nClassical surrogate simulation of quantum systems with LOWESA\nQuantum Convolutional Neural Networks are (Effectively) Classically Simulable\nClassically estimating observables of noiseless quantum circuits\nEfficient quantum-enhanced classical simulation for patches of quantum landscapes\nSimulating quantum circuits with arbitrary local noise using Pauli Propagation","category":"page"},{"location":"","page":"Home","title":"Home","text":"And more are coming up.","category":"page"},{"location":"api/Gates/#Gates","page":"Gates","title":"Gates","text":"","category":"section"},{"location":"api/Gates/#Clifford-Gates","page":"Gates","title":"Clifford Gates","text":"","category":"section"},{"location":"api/Gates/#PauliPropagation.CliffordGate","page":"Gates","title":"PauliPropagation.CliffordGate","text":"A type for a Clifford gate that carries the name of the gate and qubit indices on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.CliffordGate-Tuple{Symbol, Any}","page":"Gates","title":"PauliPropagation.CliffordGate","text":"CliffordGate(symbol::Symbol, qinds::Vector{Int})\nCliffordGate(symbol::Symbol, qinds::Int)\n\nA Clifford gate with the name symbol acting on the qubits qinds. symbol needs to match any of the implemented Clifford gates in the global clifford_map. qinds can be a single integer, a vector of integers, or anything that transforms into a vector via vec(collect(qinds)).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.composecliffordmaps-Tuple{Any}","page":"Gates","title":"PauliPropagation.composecliffordmaps","text":"composecliffordmaps(circuit::Vector{CliffordGate})\n\nCompose a circuit of Clifford gates into a single Clifford map. The length of the map is 4^nq where nq is the maximum qubit index in the circuit. The resulting clifford map can be added to the global clifford_map with a custom Clifford gate name. The maximum number of qubits is 4 due to current restrictions of UInt8. Even if all gates only act on one qubit, that qubit index will determine the dimensionality of the map.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.createcliffordmap-Tuple{Dict}","page":"Gates","title":"PauliPropagation.createcliffordmap","text":"createcliffordmap(gate_relations::Dict)\n\nCreate a Clifford gate map from a dictionary of gate relations which can then be pushed to the global clifford_map. gate_relations is a dictionary with pairs like (:X, :X) => (:Z, :X, -1), describing the action of the Clifford gate on symbols (including the sign change).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.reset_clifford_map!-Tuple{}","page":"Gates","title":"PauliPropagation.reset_clifford_map!","text":"reset_clifford_map!()\n\nReset global clifford_map to the CLifford gate implemented by default.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.transposecliffordmap-Tuple{Vector{Tuple{UInt8, Int64}}}","page":"Gates","title":"PauliPropagation.transposecliffordmap","text":"transposecliffordmap(map_array::Vector{Tuple{UInt8,Int}})\n\nTranspose the Clifford gate maparray so that the output map is the inverse of the input map. For example, transposecliffordmap(clifford_map[:H]) returns the map for the inverse of the Hadamard gate, which is the same map.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.clifford_map","page":"Gates","title":"PauliPropagation.clifford_map","text":"clifford_map\n\nGlobal dictionary of Clifford gates and their action on Pauli strings. Currently supported Clifford gates are :H, :X, :Y, :Z, :SX, :SY, :S (:SZ) , :CNOT, :CZ, :ZZpihalf, and :SWAP. If one indexes into the returned arrays with the integer that corresponds to the partial Pauli string, the returned tuple is (sign, partial_pstr) where sign is the sign change and partial_pstr is the new partial Pauli string.\n\n\n\n\n\n","category":"constant"},{"location":"api/Gates/#Pauli-Rotations","page":"Gates","title":"Pauli Rotations","text":"","category":"section"},{"location":"api/Gates/#PauliPropagation.PauliRotation","page":"Gates","title":"PauliPropagation.PauliRotation","text":"A type for a Pauli rotation gate carrying the gate generator and the qubit indices on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliRotation-Tuple{Any, Any, Any}","page":"Gates","title":"PauliPropagation.PauliRotation","text":"PauliRotation(symbols, qinds, theta)\n\nConstructor for a frozen PauliRotation generated by the Pauli string symbols acting on the qubits qinds, and with fixed parameter theta.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliRotation-Tuple{Any, Any}","page":"Gates","title":"PauliPropagation.PauliRotation","text":"PauliRotation(symbols::Vector{Symbol}, qinds::Vector{Int})\nPauliRotation(symbol::Symbol, qind::Int)\n\nA parametrized Pauli rotation generated by the Pauli string symbols acting on the qubits qinds. For example PauliRotation(:X, 2) or PauliRotation([:X, :Y], [1, 2]). We follow the convention that those rotation are equivalent by conjugation of \n\ne^-i θ2 P\n\nwhere P is the corresponding Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.commutes-Tuple{PauliRotation, Integer}","page":"Gates","title":"PauliPropagation.commutes","text":"commutes(gate::PauliRotation, pstr::Integer)\n\nCheck if a PauliRotation commutes with an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.commutes-Tuple{PauliRotation, PauliString}","page":"Gates","title":"PauliPropagation.commutes","text":"commutes(gate::PauliRotation, pstr::PauliString)\n\nCheck if a PauliRotation commutes with a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.tomatrix-Tuple{PauliRotation, Any}","page":"Gates","title":"PauliPropagation.tomatrix","text":"tomatrix(gate::PauliRotation, theta)\n\nCompute the unitary matrix for the PauliRotation gate with parameter theta in the computational 0/1 basis. This is done by computing the matrix U = cos(θ/2) I - i sin(θ/2) P where P is the Pauli matrix corresponding to the symbols. The returned unitary is returned in Schrödinger picture form. \n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#Noise-Channels","page":"Gates","title":"Noise Channels","text":"","category":"section"},{"location":"api/Gates/#PauliPropagation.AmplitudeDampingNoise","page":"Gates","title":"PauliPropagation.AmplitudeDampingNoise","text":"A type for an amplitude damping noise channel carrying the qubit index on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.AmplitudeDampingNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.AmplitudeDampingNoise","text":"AmplitudeDampingNoise(qind::Int)\nAmplitudeDampingNoise(qind::Int, gamma::Real)\n\nAn amplitude damping noise channel acting on the qubit at index qind. If gamma is provided, this returns a frozen gate with that noise strength. Damps X and Y Paulis by a factor of sqrt(1-gamma) and splits Z into and gamma * I and (1-gamma) * Z component (in the transposed Heisenberg picture).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.DephasingNoise","page":"Gates","title":"PauliPropagation.DephasingNoise","text":"DephasingNoise(qind::Int)\nDephasingNoise(qind::Int, p::Real)\n\nThis is an alias for PauliZNoise. If p is provided, this returns a frozen gate with that noise strength. A dephasing noise channel acting on the qubit at index qind. Will damp X and Y Paulis equally by a factor of 1-p.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.DepolarizingNoise","page":"Gates","title":"PauliPropagation.DepolarizingNoise","text":"A type for a depolarizing noise channel carrying the qubit index on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.DepolarizingNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.DepolarizingNoise","text":"DepolarizingNoise(qind::Int)\nDepolarizingNoise(qind::Int, p::Real)\n\nA depolarizing noise channel acting on the qubit at index qind. If p is provided, this returns a frozen gate with that noise strength. Will damp X, Y, and Z Paulis equally by a factor of 1-p.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.ParametrizedNoiseChannel","page":"Gates","title":"PauliPropagation.ParametrizedNoiseChannel","text":"Abstract type for parametrized noise channels.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliNoise","page":"Gates","title":"PauliPropagation.PauliNoise","text":"Abstract type for Pauli noise, i.e., noise that is diagonal in Pauli basis.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliXNoise","page":"Gates","title":"PauliPropagation.PauliXNoise","text":"A type for a Pauli X noise channel carrying the qubit index on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliXNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliXNoise","text":"PauliXNoise(qind::Int)\nPauliXNoise(qind::Int, p::Real)\n\nA Pauli-X noise channel acting on the qubit at index qind. If p is provided, this returns a frozen gate with that noise strength. Will damp Y and Z Paulis equally by a factor of 1-p. This corresponds to inserting a Pauli X operator into the circuit with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliYNoise","page":"Gates","title":"PauliPropagation.PauliYNoise","text":"A type for a Pauli Y noise channel carrying the qubit index on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliYNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliYNoise","text":"PauliYNoise(qind::Int)\nPauliYNoise(qind::Int, p::Real)\n\nA Pauli-Y noise channel acting on the qubit at index qind. If p is provided, this returns a frozen gate with that noise strength. Will damp X and Z Paulis equally by a factor of 1-p. This corresponds to inserting a Pauli Y operator into the circuit with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliZNoise","page":"Gates","title":"PauliPropagation.PauliZNoise","text":"A type for a Pauli Z noise channel carrying the qubit index on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliZNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliZNoise","text":"PauliZNoise(qind::Int)\nPauliZNoise(qind::Int, p::Real)\n\nA Pauli-Z noise channel acting on the qubit at index qind. If p is provided, this returns a frozen gate with that noise strength. Will damp X and Y Paulis equally by a factor of 1-p. This corresponds to inserting a Pauli Z operator with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#Misc","page":"Gates","title":"Misc","text":"","category":"section"},{"location":"api/Gates/#PauliPropagation.TGate-Tuple{Integer}","page":"Gates","title":"PauliPropagation.TGate","text":"TGate(qind::Integer)\n\nReturns a T gate acting on qubit qind. It acts on qubit qind like a PauliRotation(:Z, qind) with angle π/4.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.TransferMapGate","page":"Gates","title":"PauliPropagation.TransferMapGate","text":"TransferMapGate(transfer_map::Vector{Vector{Tuple{PauliStringType,CoeffType}}}, qinds::Vector{Int})\n\nA non-parametrized StaticGate defined by a transfer map acting on the qubits qinds. Transfer maps can be constructed manually or generated via totransfermap().\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.TransferMapGate-Tuple{AbstractMatrix, Any}","page":"Gates","title":"PauliPropagation.TransferMapGate","text":"A constructor for TransferMapGate that accepts matrix representations in the 0/1 basis or the Pauli basis (a PTM).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.tomatrix-Tuple{TGate}","page":"Gates","title":"PauliPropagation.tomatrix","text":"tomatrix(gate::TGate)\n\nCompute the unitary matrix for a TGate. The returned unitary is returned in Schrödinger picture form. \n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#Frozen-Gates","page":"Gates","title":"Frozen Gates","text":"","category":"section"},{"location":"api/Gates/#PauliPropagation.FrozenGate-Union{Tuple{PT}, Tuple{GT}, Tuple{GT, PT}} where {GT<:ParametrizedGate, PT}","page":"Gates","title":"PauliPropagation.FrozenGate","text":"FrozenGate(gate::ParametrizedGate, parameter)\n\nA StaticGate that wraps a ParametrizedGate with a fixed parameter. These are used to fix the parameter of ParametrizedGate at the time of circuit construction. This can be convenient but might exclude this parameter from being, e.g., differentiated by external libraries.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.freeze-Tuple{Any, Any}","page":"Gates","title":"PauliPropagation.freeze","text":"freeze(gates::Vector{Gate}, parameters::Vector{Number})\n\nReturns a vector of Gates where ParametrizedGates are frozen with their parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.freeze-Tuple{ParametrizedGate, Any}","page":"Gates","title":"PauliPropagation.freeze","text":"freeze(gate::ParametrizedGate, parameter)\n\nReturns a FrozenGate wrapping the gate with the fixed parameter.\n\n\n\n\n\n","category":"method"}]
}
