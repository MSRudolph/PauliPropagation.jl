var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"TODO","category":"section"},{"location":"api/Symmetry/#Symmetry","page":"Symmetry","title":"Symmetry","text":"","category":"section"},{"location":"api/Symmetry/#PauliPropagation.symmetrymerge-Union{Tuple{F}, Tuple{PauliSum, F}} where F<:Function","page":"Symmetry","title":"PauliPropagation.symmetrymerge","text":"symmetrymerge(psum::AbstractPauliSum, mapfunc::Function) -> AbstractPauliSum\n\nMerge equivalent Pauli strings in psum under a symmetry mapping. Each Pauli string is transformed using mapfunc(pstr) to its canonical representative, and identical representatives are combined.\n\nArguments\n\npsum: A PauliSum containing Pauli strings and coefficients.\nmapfunc: A function mapping each PauliString to its canonical representative.\n\nReturns\n\nA new PauliSum where symmetric terms have been merged.\n\nExample\n\npsum = PauliSum(6)\nadd!(psum, :Z, 3)\nadd!(psum, :Z, 6)\nsymmetrymerge(psum, pstr -> _translatetolowestinteger(pstr, psum.nqubits))\n\n\n\n\n\n","category":"method"},{"location":"api/Symmetry/#PauliPropagation.translationmerge-Tuple{PauliPropagation.AbstractPauliSum, Integer, Integer}","page":"Symmetry","title":"PauliPropagation.translationmerge","text":"translationmerge(psum::AbstractPauliSum, nx::Integer, ny::Integer)\n\nShift and merge of a psum in a system with 2D translational symmetry.\n\npsum = PauliSum(6)\nadd!(psum, :Z, 3)\nadd!(psum, :Z, 6)\ntranslationmerge(psum, 2, 3)\n\n\n\n\n\n","category":"method"},{"location":"api/Symmetry/#PauliPropagation.translationmerge-Tuple{PauliPropagation.AbstractPauliSum}","page":"Symmetry","title":"PauliPropagation.translationmerge","text":"translationmerge(psum::AbstractPauliSum)\n\nShift and merge of a psum in a system with 1D translational symmetry.\n\npsum = PauliSum(6)\nadd!(psum, :Z, 3)\nadd!(psum, :Z, 6)\ntranslationmerge(psum)\n>>> PauliSum(nqubits: 6, 1 Pauli term: \n 2.0 * ZIIIII\n)\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#Surrogate","page":"Surrogate","title":"Surrogate","text":"","category":"section"},{"location":"api/Surrogate/#Datatypes","page":"Surrogate","title":"Datatypes","text":"","category":"section"},{"location":"api/Surrogate/#Evaluate","page":"Surrogate","title":"Evaluate","text":"","category":"section"},{"location":"api/Surrogate/#Propagate","page":"Surrogate","title":"Propagate","text":"","category":"section"},{"location":"api/Surrogate/#PauliPropagation.NodePathProperties","page":"Surrogate","title":"PauliPropagation.NodePathProperties","text":"NodePathProperties(node::CircuitNode)\nNodePathProperties(node::CircuitNode, nsins::Int, ncos::Int, freq::Int)\n\nSurrogate PathProperties type. Carries CircuitNodes instead of numerical coefficients. If nsins, ncos, and freq are not provided, they are initialized to 0.\n\n\n\n\n\n","category":"type"},{"location":"api/Surrogate/#PauliPropagation.PropagationBase.tonumber-Tuple{NodePathProperties}","page":"Surrogate","title":"PauliPropagation.PropagationBase.tonumber","text":"tonumber(path::NodePathProperties)\n\nGet the cummulative coefficient of a NodePathProperties node. This assumes that the surrogate has already been evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.wrapcoefficients-Tuple{PauliString, Type{NodePathProperties}}","page":"Surrogate","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(pstr::PauliString, ::Type{NodePathProperties})\n\nWrap the coefficient of a PauliString into NodePathProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.wrapcoefficients-Tuple{PauliSum, Type{NodePathProperties}}","page":"Surrogate","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(psum::PauliSum, ::Type{NodePathProperties})\n\nWrap the coefficients of a PauliSum into NodePathProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.evaluate!-Union{Tuple{TT}, Tuple{PauliSum{TT, NodePathProperties}, Any}} where TT","page":"Surrogate","title":"PauliPropagation.evaluate!","text":"evaluate!(psum::PauliSum{<:Integer,NodePathProperties}, thetas; reset=true)\n\nEvaluate the expectation value of a Surrogate by evaluating all involved circuit nodes in the correct order. eval_list can be attained as the output of gettraceevalorder(). If reset is false, the function will not reset the is_evaluated flags of the nodes. This should only be done if they are manually reset.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Tuple{PauliPropagation.CircuitNode}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(circuit_node::CircuitNode)\n\nReset a CircuitNode in a the Surrogate. Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Tuple{PauliPropagation.EvalEndNode}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(end_node::EvalEndNode)\n\nReset a EvalEndNode in a the Surrogate.  These sit on the coeff field of NodePathProperties and are the end of the evaluation chain. Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Union{Tuple{AbstractVector{CT}}, Tuple{CT}} where CT<:NodePathProperties","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(paths::Vector{NodePathProperties})\n\nReset a vector of NodePathProperties in a the Surrogate.  Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Union{Tuple{PauliSum{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT<:NodePathProperties}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(psum::PauliSum{<:Integer, NodePathProperties})\n\nReset the nodes in a the Surrogate.  Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.PropagationBase.propagate!-Union{Tuple{TT}, Tuple{Any, PauliSum{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.PropagationBase.propagate!","text":"propagate!(circ, psum::PauliSum{<:Integer,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliSum through the circuit circ in the Heisenberg picture.  The PauliSum psum is modified in place. The circuit must only contain CliffordGates and PauliRotations. Truncations based on any numerical coefficient value cannot be used. Everything else is the same as in propagate!() for the non-Surrogate code.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.PropagationBase.propagate-Union{Tuple{TT}, Tuple{Any, PauliString{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.PropagationBase.propagate","text":"propagate(circ, pstr::PauliString{<:Integer,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliString through the circuit circ in the Heisenberg picture.  The circuit must only contain CliffordGates and PauliRotations. Truncations based on any numerical coefficient value cannot be used. Everything else is the same as in propagate!() for the non-Surrogate code.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.PropagationBase.propagate-Union{Tuple{TT}, Tuple{Any, PauliSum{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.PropagationBase.propagate","text":"propagate(circ, psum::PauliSum{<:Integer,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliSum through the circuit circ in the Heisenberg picture. The circuit must only contain CliffordGates and PauliRotations.  Truncations based on any numerical coefficient value cannot be used. Everything else is the same as in propagate!() for the non-Surrogate code.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#Path-Properties","page":"Path Properties","title":"Path Properties","text":"","category":"section"},{"location":"api/PathProperties/#Pauli-frequency-tracker","page":"Path Properties","title":"Pauli frequency tracker","text":"","category":"section"},{"location":"api/PathProperties/#Abstract-type","page":"Path Properties","title":"Abstract type","text":"","category":"section"},{"location":"api/PathProperties/#PauliPropagation.PauliFreqTracker","page":"Path Properties","title":"PauliPropagation.PauliFreqTracker","text":"PauliFreqTracker(coeff::Number, nsins::Int, ncos::Int, freq::Int)\n\nWrapper type for numerical coefficients in Pauli propagation that records  the number of sin and cos factors applied via a PauliRotation gate, and the so-called frequency, which is their sum. It appears redundant but these three properties need to be tracked separately because of how merging affects them.\n\n\n\n\n\n","category":"type"},{"location":"api/PathProperties/#PauliPropagation.PauliFreqTracker-Tuple{Number}","page":"Path Properties","title":"PauliPropagation.PauliFreqTracker","text":"PauliFreqTracker(coeff::Number)\n\nConstructor for PauliFreqTracker from only a coefficient. Initializes nsins, ncos, and freq to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.PathProperties","page":"Path Properties","title":"PauliPropagation.PathProperties","text":"Abstract type for wrapping coefficients and record custom path properties\n\n\n\n\n\n","category":"type"},{"location":"api/PathProperties/#Base.float-Tuple{PProp} where PProp<:PathProperties","page":"Path Properties","title":"Base.float","text":"float(path::PathProperties)\n\nReturns an equivalent PathProperties object where float() is applied to the coeff field.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.PropagationBase.tonumber-Tuple{PProp} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.PropagationBase.tonumber","text":"tonumber(path::PathProperties)\n\nGet the numerical coefficient of a PathProperties wrapper.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.unwrapcoefficients-Union{Tuple{PauliString{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT}","page":"Path Properties","title":"PauliPropagation.unwrapcoefficients","text":"unwrapcoefficients(pstr::PauliString)\n\nUnwrap the coefficient of a PauliString from a PathProperties type. Returns a PauliString with the coeff field of the PathProperties object.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.unwrapcoefficients-Union{Tuple{PauliSum{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT}","page":"Path Properties","title":"PauliPropagation.unwrapcoefficients","text":"unwrapcoefficients(psum::PauliSum)\n\nUnwrap the coefficients of a PauliSum from a PathProperties type. Returns a PauliSum with coefficients being the coeff field of the PathProperties objects.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.wrapcoefficients-Union{Tuple{PProp}, Tuple{PauliString, Type{PProp}}} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(pstr::PauliString, PathPropertiesType<:PathProperties)\n\nWrap the coefficient of a PauliString into a custom PathProperties type. For anything that is not natively supported by the library, you can subtype PathProperties. A one-argument constructor of the custom PathProperties type from a coefficient must be defined.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.wrapcoefficients-Union{Tuple{PProp}, Tuple{PauliSum, Type{PProp}}} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(psum::PauliSum, PathPropertiesType<:PathProperties)\n\nWrap the coefficients of a PauliSum into a custom PathProperties type. For anything that is not natively supported by the library, you can subtype PathProperties. A one-argument constructor of the custom PathProperties type from a coefficient must be defined.\n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#Truncations","page":"Truncations","title":"Truncations","text":"","category":"section"},{"location":"api/Truncations/#PauliPropagation.truncatedampingcoeff-Tuple{Integer, Any, Number, Real}","page":"Truncations","title":"PauliPropagation.truncatedampingcoeff","text":"truncatedampingcoeff(\n    pstr::Integer, \n    coeff::Real, \n    gamma::Number, \n    min_abs_coeff::Float64\n)\n\nCustom truncation function with dissipation-assisted damping of coefficients. It returns true (indicating to truncate) if the coefficient exponentially damped by the Pauli weight drops below min_abs_coeff.\n\nThe function evaluates the condition: abs(coeff) * 10^(-gamma * countweight(pstr)) < min_abs_coeff\n\ngamma is the damping factor controlling the rate of exponential decay with Pauli weight.\n\nTo turn this function into a custom truncation function for propagate(), you need to define a closure  that only takes the pstr and coeff as arguments, but has gamma and min_abs_coeff fixed.\n\nExample:\n\ncustomtruncfunc = (pstr, coeff) -> truncatedampingcoeff(pstr, coeff, 0.5, 1e-10) \n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#State-Overlap","page":"State Overlap","title":"State Overlap","text":"","category":"section"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithcomputational-Tuple{Any, Any}","page":"State Overlap","title":"PauliPropagation.overlapwithcomputational","text":"overlapwithcomputational(psum::PauliSum, onebitinds::Vector{Integer})\noverlapwithcomputational(pstr::PauliString, onebitinds::Vector{Integer})\n\nCalculates the overlap of a Pauli sum or Pauli string with the computational basis state  which has one-bits at all specified indices and zero-bits elsewhere. If |x><x| is a computational basis state, it we compute Tr[psum * |x><x|] = <x|psum|x> or Tr[pstr * |x><x|] = <x|pstr|x>. For example, overlapwithcomputational(psum, [1,2,4]) returns the overlap with |1101000...>.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithmaxmixed-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.overlapwithmaxmixed","text":"overlapwithmaxmixed(psum::AbstractPauliSum)\n\nCalculates the overlap of an AbstractPauliSum with the maximally mixed state I/2^n, i.e., Tr[psum * I/2^n].\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithpaulisum-Tuple{Any, Any}","page":"State Overlap","title":"PauliPropagation.overlapwithpaulisum","text":"overlapwithpaulisum(rho::PauliSum, psum::PauliSum)\n\nCalculate the overlap of a Pauli sum psum and a quantum state rho represented in the Pauli basis via another PauliSum. This is equivalent to the trace Tr[rho * psum]. Calls scalarproduct(rho, psum) * (2^nqubits(rho)) to calculate the overlap.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithplus-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.overlapwithplus","text":"overlapwithplus(psum::PauliSum) \noverlapwithplus(pstr::PauliString)\n\nCalculates the overlap of a Pauli sum or Pauli string with the plus state |+><+|, i.e. Tr[psum * |+><+|] = <+|psum|+> or Tr[pstr * |+><+|] = <+|pstr|+>.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithzero-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.overlapwithzero","text":"overlapwithzero(psum::PauliSum) \noverlapwithzero(pstr::PauliString)\n\nCalculates the overlap of a Pauli sum with the zero state |0><0|, i.e., Tr[psum * |0><0|] = <0|psum|0> or Tr[pstr * |0><0|] = <0|pstr|0>.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.plusfilter!-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.plusfilter!","text":"zerofilter!(psum)\n\nFilter a Pauli sum in-place with only Pauli strings that are not orthogonal to the plus state |+><+|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.plusfilter-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.plusfilter","text":"plusfilter(psum)\n\nReturn a filtered Pauli sum with only Pauli strings that are not orthogonal to the plus state |+><+|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.scalarproduct-Tuple{PauliPropagation.AbstractPauliSum, PauliPropagation.AbstractPauliSum}","page":"State Overlap","title":"PauliPropagation.scalarproduct","text":"scalarproduct(psum1::AbstractPauliSum, psum2::AbstractPauliSum)\nscalarproduct(pstr::PauliString, psum::AbstractPauliSum)\nscalarproduct(psum::AbstractPauliSum, pstr::PauliString)\nscalarproduct(pstr1::PauliString, pstr2::PauliString)\n\nCalculates the scalar product between any combination of PauliSum and PauliString. This  calculates the sum of the products of their coefficients for all Pauli strings that are present . Important: This is not equivalent to the trace Tr[psum1 * psum2] but instead  Tr[psum1 * psum2]/2^n, and equivalently for Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.zerofilter!-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.zerofilter!","text":"zerofilter!(psum)\n\nFilter a Pauli sum in-place with only Pauli strings that are not orthogonal to the zero state |0><0|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.zerofilter-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.zerofilter","text":"zerofilter(psum)\n\nReturn a filtered Pauli sum with only Pauli strings that are not orthogonal to the zero state |0><0|.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#Circuits","page":"Circuits","title":"Circuits","text":"","category":"section"},{"location":"api/Circuits/#Builders","page":"Circuits","title":"Builders","text":"","category":"section"},{"location":"api/Circuits/#Topologies","page":"Circuits","title":"Topologies","text":"","category":"section"},{"location":"api/Circuits/#Utils","page":"Circuits","title":"Utils","text":"","category":"section"},{"location":"api/Circuits/#PauliPropagation.tfitrottercircuit","page":"Circuits","title":"PauliPropagation.tfitrottercircuit","text":"tfitrottercircuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits), start_with_ZZ=true)\n\nCreate a circuit that corresponds to a Trotterization of the transverse-field Ising Hamiltonian. \n\nH = _(ij)  topology J_ij Z_i Z_j + _i=1  nqubits h_i X_i\n\nThis returns only the sequence of gates, not their parameters. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used. If start_with_ZZ is set to true, the circuit starts with a layer of ZZ gates, else with a layer of X gates. This is relevant depending on the initial state.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.tiltedtfitrottercircuit","page":"Circuits","title":"PauliPropagation.tiltedtfitrottercircuit","text":"tiltedtfitrottercircuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits))\n\nCreate a circuit that corresponds to a Trotterization of the transverse-field Ising Hamiltonian. \n\nH = _(ij)  topology J_ij Z_i Z_j \n  + _i=1  nqubits h_i Z_i +  _i=1  nqubits b_i X_i\n\nThis returns only the sequence of gates, not their parameters. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.heisenbergtrottercircuit","page":"Circuits","title":"PauliPropagation.heisenbergtrottercircuit","text":"heisenbergtrottercircuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits))\n\nCreate a circuit that corresponds to a Trotterization of the Heisenberg Hamiltonian.\n\nH = _(ij)  topology Jzz_ij Z_i Z_j + Jxx_ij X_i X_j + Jyy_ij Y_i Y_j\n\nThis returns only the sequence of gates, not their parameters. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used. Note that the gates are applied as layers of XX-YY-ZZ gates, not as layers of XX on all, then YY on all, then ZZ on all.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.hardwareefficientcircuit","page":"Circuits","title":"PauliPropagation.hardwareefficientcircuit","text":"hardwareefficientcircuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits))\n\nCreate a hardware-efficient circuit consisting of layers of single-qubit X-Z-X Pauli gates and YY entangling gates. A topology can be specified as a list of pairs of qubit indices.  If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.efficientsu2circuit","page":"Circuits","title":"PauliPropagation.efficientsu2circuit","text":"efficientsu2circuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits))\n\nCreate a hardware-efficient circuit consisting of layers of single-qubit Y-Z Pauli gates and CNOT entangling gates. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.su4circuit","page":"Circuits","title":"PauliPropagation.su4circuit","text":"su4circuit(nqubits::Integer, nlayers::Integer; topology=bricklayertopology(nqubits))\n\nCreate a circuit that consists of layers of SU(4) gates on a given topology.  SU(4) gates are decomposed via the KAK Decomposition into single-qubit Z-X-Z gates on each qubit, followed by XX-YY-ZZ gates and again single-qubit Z-X-Z gates, for a total of 15 Pauli gates. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.rxlayer!","page":"Circuits","title":"PauliPropagation.rxlayer!","text":"rxlayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:X, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.rylayer!","page":"Circuits","title":"PauliPropagation.rylayer!","text":"rylayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:Y, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.rzlayer!","page":"Circuits","title":"PauliPropagation.rzlayer!","text":"rzlayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:Z, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.rxxlayer!","page":"Circuits","title":"PauliPropagation.rxxlayer!","text":"rxxlayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:X, :X], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.ryylayer!","page":"Circuits","title":"PauliPropagation.ryylayer!","text":"ryylayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:Y, :Y], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.rzzlayer!","page":"Circuits","title":"PauliPropagation.rzzlayer!","text":"rzzlayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:Z, :Z], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.qcnncircuit","page":"Circuits","title":"PauliPropagation.qcnncircuit","text":"qcnncircuit(nqubits::Integer; periodic=false)\n\nCreate a Quantum Convolutional Neural Network (QCNN) circuit on nqubits qubits. The topology for the circuit is created by creating bricklayer topologies on half the qubits every layer. The final qubits are qubit 1 and ~nqubits/2, which should be measured.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.appendSU4!","page":"Circuits","title":"PauliPropagation.appendSU4!","text":"appendSU4!(circuit, pair)\n\nAppend a layer of SU(4) gates to a circuit on a given pair of qubits. The SU(4) gate is decomposed via the KAK Decomposition into single-qubit Z-X-Z gates on each qubit, followed by XX-YY-ZZ gates and again single-qubit Z-X-Z gates, for a total of 15 Pauli gates.\n\n\n\n\n\n","category":"function"},{"location":"api/Circuits/#PauliPropagation.bricklayertopology-Tuple{Any}","page":"Circuits","title":"PauliPropagation.bricklayertopology","text":"bricklayertopology(qindices; periodic=false)\n\nCreate the topology of a so-called 1D bricklayer circuit on a subset of qubits indicated by qindices. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.bricklayertopology-Tuple{Integer}","page":"Circuits","title":"PauliPropagation.bricklayertopology","text":"bricklayertopology(nqubits::Integer; periodic=false)\n\nCreate the topology of a so-called 1D bricklayer circuit on nqubits qubits. It consists of two sublayers connecting odd-even and eve-odd qubit indices, respectively. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rectangletopology-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.rectangletopology","text":"rectangletopology(nx::Integer, ny::Integer; periodic=false)\n\nCreate a 2D topology on a grid of nx by ny qubits. The order is none in particular and may need to be adapted for specific purposes. If periodic is set to true, the grid is connected periodically in both directions.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.staircasetopology-Tuple{Integer}","page":"Circuits","title":"PauliPropagation.staircasetopology","text":"staircasetopology(nqubits::Integer; periodic=false)\n\nCreate a 1D staircase topology on nqubits qubits. The qubits are connected in a staircase pattern, where qubit i is connected to qubit i+1. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.staircasetopology2d-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.staircasetopology2d","text":"staircasetopology2d(nx::Integer, ny::Integer)\n\nCreate a 2D staircase topology on a grid of nx by ny qubits. Mind the order of the topology, which forms a staircase spanning the grid -> in the Schrödinger picture <-.  An observable acting on qubits index nqubits may interact non-trivially with every gate on the topology.  Can topology can either be pathological or the most simple, depending on which index observables are non-identity.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.ibmeagletopology","page":"Circuits","title":"PauliPropagation.ibmeagletopology","text":"ibmeagletopology\n\nTopology of the IBM Eagle device with 127 qubits. Also called the heave-hex topology on 127 qubits.\n\n\n\n\n\n","category":"constant"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Tuple{Any, Type{PauliRotation}, Vector{Symbol}, Vector{Int64}}","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, ::PauliRotation, gate_symbols::Vector{Symbol}), qinds::Vector{Int})\n\nUtility function to get the parameter indices of PauliRotation gates with symbol gate_symbols acting on the qubits qinds. For example, getparameterindices(circuit, PauliRotation, [:X], [1]).\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Tuple{Any, Type{PauliRotation}, Vector{Symbol}}","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, ::PauliRotation, gate_symbols::Vector{Symbol}))\n\nUtility function to get the parameter indices of PauliRotation gates with symbol gate_symbols. For example, getparameterindices(circuit, PauliRotation, [:X]).\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Union{Tuple{GT}, Tuple{Any, Type{GT}}} where GT<:ParametrizedGate","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, GateType<:ParametrizedGate)\n\nUtility function to get the parameter indices of gates of type GateType in a circuit. This naturally only works for gates that subtype ParametrizedGate.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#Propagation","page":"Propagation","title":"Propagation","text":"","category":"section"},{"location":"api/Propagation/#Generics","page":"Propagation","title":"Generics","text":"","category":"section"},{"location":"api/Propagation/#Specializations","page":"Propagation","title":"Specializations","text":"","category":"section"},{"location":"api/Propagation/#Vector-Specializations","page":"Propagation","title":"Vector Specializations","text":"","category":"section"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.propagate","page":"Propagation","title":"PauliPropagation.PropagationBase.propagate","text":"propagate(circ, pstr::PauliString, thetas=nothing; min_abs_coeff=1e-10, max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, heisenberg=true, kwargs...)\n\nPropagate a PauliString through the circuit circ. By default this is done in the Heisenberg picture, as indicated by heisenberg=true.  This means that the circuit is applied to the Pauli string in reverse order, and the action of each gate is its conjugate action. Parameters for the parametrized gates in circ are given by thetas, and need to be passed as if the circuit was applied as written in the Schrödinger picture. If thetas are not passed, the circuit must contain only non-parametrized StaticGates. Default truncations are min_abs_coeff, max_weight, max_freq, and max_sins. max_freq, and max_sins will lead to automatic conversion if the coefficients are not already wrapped in suitable PathProperties objects. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, and apply.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.propagate-2","page":"Propagation","title":"PauliPropagation.PropagationBase.propagate","text":"propagate(circuit, psum::AbstractPauliSum, thetas=nothing; min_abs_coeff=1e-10, max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, heisenberg=true, kwargs...)\npropagate!(circuit, psum::AbstractPauliSum, thetas=nothing; min_abs_coeff=1e-10, max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, heisenberg=true, kwargs...)\n\nPropagate a Pauli sum psum through the circuit circ.  By default this is done in the Heisenberg picture, as indicated by heisenberg=true.  This means that the circuit is applied to the Pauli sum in reverse order, and the action of each gate is its conjugate action. In propagate() the Pauli sum psum is deepcopied and passed into the in-place propagation function propagate!(). Parameters for the parametrized gates in circ are given by thetas, and need to be passed as if the circuit was applied as written in the Schrödinger picture. If thetas are not passed, the circuit must contain only non-parametrized StaticGates. Default truncations are min_abs_coeff, max_weight, max_freq, and max_sins. max_freq, and max_sins will lead to automatic conversion if the coefficients are not already wrapped in suitable PathProperties objects. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, and apply.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.propagate!","page":"Propagation","title":"PauliPropagation.PropagationBase.propagate!","text":"propagate!(circuit, prop_cache::AbstractPauliPropagationCache, thetas=nothing; min_abs_coeff=1e-10, max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, heisenberg=true, kwargs...)\n\nIn-place propagation of an AbstractPauliPropagationCache through the circuit circ in the Heisenberg picture.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.truncate!-Tuple{AbstractPauliPropagationCache}","page":"Propagation","title":"PauliPropagation.PropagationBase.truncate!","text":"truncate!(psum::AbstractPauliSum; minabscoeff=1e-10, maxweight=Inf, maxfreq=Inf, maxsins=Inf, customtruncfunc=nothing, kwargs...)     truncate!(propcache::AbstractPauliPropagationCache; minabscoeff=1e-10, maxweight=Inf, maxfreq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nTruncation function for AbstractPauliPropagationCaches that combines multiple truncation criteria. The default truncation criteria are:\n\nmin_abs_coeff: Truncates Pauli strings with absolute coefficient below this value.\nmax_weight: Truncates Pauli strings with weight (number of non-identity Paulis) above this value.\nmax_freq: Truncates Pauli strings with frequency (number of cosine factors in coefficient) above this value.\nmax_sins: Truncates Pauli strings with number of sine factors in coefficient above this value.\n\nA custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr, coeff)::Bool.\n\nThis function combines all truncation criteria into a single truncation function truncfunc() calls PropagationBase.truncate!(truncfunc, prop_cache).\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.apply-Tuple{TransferMapGate, Any, Any}","page":"Propagation","title":"PauliPropagation.PropagationBase.apply","text":"apply(gate::TransferMapGate, pstr, coeff)\n\nApply a TransferMapGate to an integer Pauli string and its coefficient. The outcomes are determined by the transfer_map of the gate.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.applymergetruncate!-Tuple{ImaginaryPauliRotation, AbstractPauliPropagationCache, Any}","page":"Propagation","title":"PauliPropagation.PropagationBase.applymergetruncate!","text":"applymergetruncate!(gate::ImaginaryPauliRotation, prop_cache::AbstractPauliPropagationCache, tau; normalize_coeffs=true, kwargs...)\n\nOverload of applymergetruncate! for ImaginaryPauliRotation gates and a propagating PauliSum. Applies the gate, merges the resulting Pauli sum, and truncates it. If normalize_coeffs=true, the resulting Pauli sum is normalized by the coefficient of the identity Pauli string after merging. This is useful for numerical stability when evolving states in the Schrödinger picture.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.applytoall!-Tuple{AmplitudeDampingNoise, PauliPropagationCache, Any}","page":"Propagation","title":"PauliPropagation.PropagationBase.applytoall!","text":"applytoall!(gate::AmplitudeDampingNoise, prop_cache::PauliPropagationCache, gamma; kwargs...)\n\nOverload of applytoall! for AmplitudeDampingNoise gates and a propagating PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.applytoall!-Tuple{CliffordGate, AbstractPauliPropagationCache}","page":"Propagation","title":"PauliPropagation.PropagationBase.applytoall!","text":"applytoall!(gate::CliffordGate, prop_cache::AbstractPauliPropagationCache; kwargs...)\n\nOverload of applytoall! for CliffordGates with a propagating PauliSum. Provides the Clifford lookup map to the default applytoall!, and apply functions.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.applytoall!-Tuple{FrozenGate, AbstractPauliPropagationCache}","page":"Propagation","title":"PauliPropagation.PropagationBase.applytoall!","text":"applytoall!(gate::FrozenGate, thetas, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for FrozenGates. Re-directs to applytoall! for the wrapped FrozenGate.gate with the frozen parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.applytoall!-Tuple{PauliNoise, PauliPropagationCache, Any}","page":"Propagation","title":"PauliPropagation.PropagationBase.applytoall!","text":"applytoall!(gate::PauliNoise, prop_cache::PauliPropagationCache, p; kwargs...)\n\nOverload of applytoall! for PauliNoise gates with noise strength p and a propagating PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.applytoall!-Tuple{PauliRotation, PauliPropagationCache, Any}","page":"Propagation","title":"PauliPropagation.PropagationBase.applytoall!","text":"applytoall!(gate::PauliRotation, theta, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for PauliRotation gates and a propagating PauliSum. It fixes the type-instability of the apply() function and reduces moving Pauli strings between psum and aux_psum. psum and aux_psum are merged later.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.applytoall!-Tuple{TGate, AbstractPauliPropagationCache}","page":"Propagation","title":"PauliPropagation.PropagationBase.applytoall!","text":"applytoall!(gate::TGate, prop_cache::AbstractPauliPropagationCache; kwargs...)\n\nOverload of applytoall!() for TGate(qind) and a propagating PauliSum. Redirects to a PauliRotation(:Z, qind) with angle π/4.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.applytoall!-Tuple{CliffordGate, VectorPauliPropagationCache}","page":"Propagation","title":"PauliPropagation.PropagationBase.applytoall!","text":"applytoall!(gate::CliffordGate, prop_cache::VectorPauliPropagationCache; kwargs...)\n\nOverload of applytoall! for CliffordGates and a propagating VectorPauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.applytoall!-Tuple{ImaginaryPauliRotation, VectorPauliPropagationCache, Any}","page":"Propagation","title":"PauliPropagation.PropagationBase.applytoall!","text":"applytoall!(gate::ImaginaryPauliRotation, prop_cache::VectorPauliPropagationCache, tau; kwargs...)\n\nOverload of applytoall! for ImaginaryPauliRotation gates and a propagating VectorPauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.applytoall!-Tuple{PauliNoise, VectorPauliPropagationCache, Any}","page":"Propagation","title":"PauliPropagation.PropagationBase.applytoall!","text":"applytoall!(gate::PauliNoise, prop_cache::VectorPauliPropagationCache, p; kwargs...)\n\nOverload of applytoall! for PauliNoise gates with noise strength p and a propagating VectorPauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.PropagationBase.applytoall!-Tuple{PauliRotation, VectorPauliPropagationCache, Any}","page":"Propagation","title":"PauliPropagation.PropagationBase.applytoall!","text":"applytoall!(gate::PauliRotation, prop_cache::VectorPauliPropagationCache, theta; kwargs...)\n\nOverload of applytoall! for PauliRotation gates and a propagating VectorPauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliTransferMatrix/#Pauli-Transfer-Matrix","page":"Pauli Transfer Matrix","title":"Pauli Transfer Matrix","text":"","category":"section"},{"location":"api/PauliTransferMatrix/#Matrices","page":"Pauli Transfer Matrix","title":"Matrices","text":"","category":"section"},{"location":"api/PauliTransferMatrix/#Transfer-maps","page":"Pauli Transfer Matrix","title":"Transfer maps","text":"","category":"section"},{"location":"api/PauliTransferMatrix/#PauliPropagation.calculateptm-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Number","page":"Pauli Transfer Matrix","title":"PauliPropagation.calculateptm","text":"function calculateptm(mat::AbstractMatrix; tol=1e-15, heisenberg=true)\nfunction calculateptm(dtype<:Number, mat::AbstractMatrix; tol=1e-15, heisenberg=true)\n\nCalculate the Pauli Transfer Matrix (PTM) of a matrix mat.  The PTM will be real-valued in the Pauli basis. However, it can be complex in a general basis. Pass an optional data type dtype when entries are not floats. We truncate small complex components and abs values in the PTM using the tol parameter. Note, by default the PTM is calculated in the Heisenberg picture,  i.e., the PTM is that of the conjugate transpose of the  matrix. This can be changed via the heisenberg::Bool keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliTransferMatrix/#PauliPropagation.totransfermap","page":"Pauli Transfer Matrix","title":"PauliPropagation.totransfermap","text":"totransfermap(nq::Integer, circuit::Vector{Gate}, thetas=nothing)\n\nComputes the Pauli transfer map acting on nq qubits from a circuit with parameters thetas. thetas defaults to nothing but is required if the circuit contains parametrized gates. The returned lookup map is a vector of vectors like [(pstr1, coeff1), (pstr2, coeff2), ...], where the pstr are partial Pauli strings on the affected qubits.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliTransferMatrix/#PauliPropagation.totransfermap-Tuple{AbstractMatrix}","page":"Pauli Transfer Matrix","title":"PauliPropagation.totransfermap","text":"totransfermap(ptm::AbstractMatrix)\n\nComputes the Pauli transfer map acting on nq qubits from a Pauli Transfer Matrix (PTM). The PTM should be the matrix representation of a gate in Pauli basis. The returned lookup map is a vector of vectors like [(pstr1, coeff1), (pstr2, coeff2), ...], where the pstr are partial Pauli strings on the affected qubits.\n\n\n\n\n\n","category":"method"},{"location":"api/NumericalCertificates/#Numerical-Certificates","page":"Numerical Certificates","title":"Numerical Certificates","text":"","category":"section"},{"location":"api/NumericalCertificates/#PauliPropagation.estimatemse","page":"Numerical Certificates","title":"PauliPropagation.estimatemse","text":"estimatemse(circ, pstr::PauliString, n_mcsamples::Integer, thetas=π; stateoverlapfunc=overlapwithzero, circuit_is_reversed=false, customtruncfunc=nothing)\n\nFunction to estimate the mean square error of a truncated circuit simulation using Monte Carlo sampling. Returns the mean squared error of the truncated Pauli propagation simulation averaged over the thetas∈ [theta, theta] of the angle theta of each PauliRotation. Currently, the function only supports circuits with PauliRotation and CliffordGate gates.\n\nThe length the thetas vector should be equal to the number of parametrized gates in the circuit.  Alternatively, thetas can be a single real number applicable for all parametrized gates. The default thetas=π or any other non-array values assume that the circuit consists only of PauliRotation -CliffordGate. For PauliRotation, the value should be the integration range of the parameters around zero.\n\nAn initial state overlap function stateoverlapfunc can be provided to calculate the overlap of the backpropagated Pauli strings with the initial state. Importantly, the kwargs can be used to set the truncation parameters of the Pauli propagation. Currently supported are max_weight, max_freq, and max_sins. Note that min_abs_coeff is not supported here, as we consider errors integrated over the angles. max_freq effectively truncates small coefficients below (1/2)^max_freq on average over thetas ∈ [-π, π]. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool.\n\n\n\n\n\n","category":"function"},{"location":"api/NumericalCertificates/#PauliPropagation.estimatemse!-Tuple{Any, PauliString, AbstractVector, Any, Any}","page":"Numerical Certificates","title":"PauliPropagation.estimatemse!","text":"estimatemse!(\ncirc, pstr::PauliString, error_array::AbstractVector, thetas, split_probabilities; \nstateoverlapfunc=overlapwithzero, circuit_is_reversed=false, max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing\n)\n\nIn-place version of estimatemse. This function takes an array error_array of length n_mcsamples as an argument and modifies it in-place.  It further assumes that the thetas and split_probabilities are already correctly calculated and provided as arguments.  In general they will be vectors, but they can also be real numbers. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#Data-types","page":"Data types","title":"Data types","text":"","category":"section"},{"location":"api/PauliDataTypes/#PauliString","page":"Data types","title":"PauliString","text":"","category":"section"},{"location":"api/PauliDataTypes/#PauliSum","page":"Data types","title":"PauliSum","text":"","category":"section"},{"location":"api/PauliDataTypes/#VectorPauliSum","page":"Data types","title":"VectorPauliSum","text":"","category":"section"},{"location":"api/PauliDataTypes/#Conversions","page":"Data types","title":"Conversions","text":"","category":"section"},{"location":"api/PauliDataTypes/#AbstractPauliSum","page":"Data types","title":"AbstractPauliSum","text":"","category":"section"},{"location":"api/PauliDataTypes/#PauliPropagation.PauliString","page":"Data types","title":"PauliPropagation.PauliString","text":"PauliString(nqubits::Int, pauli::Symbol, qind::Integer, coeff=1.0)\nPauliString(nqubits::Int, paulis::Vector{Symbol}, qinds::Vector{Integer}, coeff=1.0)\n\nConstructor for a PauliString on nqubits qubits from a Symbol (:I, :X, :Y, :Z) or Vector{Symbol}. Provide the index or indices for those symbols as qind or qinds. The coefficient of the Pauli string in the Pauli sum defaults to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/PauliDataTypes/#PauliPropagation.PauliString-2","page":"Data types","title":"PauliPropagation.PauliString","text":"PauliString(nqubits::Int, term::TermType, coeff::CoeffType)\n\nPauliString is a struct that represents a Pauli string on nqubits qubits. Commonly term is an unsigned Integer.  See the other PauliString constructors for higher-level usage. \n\n\n\n\n\n","category":"type"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.coefftype-Tuple{PauliString}","page":"Data types","title":"PauliPropagation.PropagationBase.coefftype","text":"coefftype(pstr::PauliString)\n\nGet the coefficient type of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.numcoefftype-Union{Tuple{PauliString{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT}","page":"Data types","title":"PauliPropagation.PropagationBase.numcoefftype","text":"numcoefftype(pstr::PauliString)\n\nGet the type of the numerical coefficient of a PauliString.  Will return the type of the output of  numcoefftype(coefftype(pstr)).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.nqubits-Tuple{PauliString}","page":"Data types","title":"PauliPropagation.nqubits","text":"nqubits(pstr::PauliString)\n\nGet the number of qubits that the PauliString is defined on.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.paulitype-Tuple{PauliString}","page":"Data types","title":"PauliPropagation.paulitype","text":"paulitype(pstr::PauliString)\n\nGet the Pauli integer type of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PauliSum","page":"Data types","title":"PauliPropagation.PauliSum","text":"PauliSum(nqubits::Int, terms::Dict) <: AbstractPauliSum\n\nPauliSum is a struct that represents a sum of Pauli strings acting on nqubits qubits. It is a wrapper around a dictionary Dict(Pauli string => coefficient}, where the Pauli strings are typically unsigned Integers for efficiency reasons.\n\n\n\n\n\n","category":"type"},{"location":"api/PauliDataTypes/#PauliPropagation.PauliSum-Tuple{Int64}","page":"Data types","title":"PauliPropagation.PauliSum","text":"PauliSum(nqubits::Integer)\n\nContructor for an empty PauliSum on nqubits qubits. Element type defaults for Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PauliSum-Union{Tuple{CT}, Tuple{Type{CT}, Int64}} where CT","page":"Data types","title":"PauliPropagation.PauliSum","text":"PauliSum(CoeffType, nq::Int)\n\nContructor for an empty PauliSum on nqubits qubits. The type of the coefficients can be provided.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#Base.copy-Tuple{PauliSum}","page":"Data types","title":"Base.copy","text":"Copy a PauliSum by copying its terms field.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.nqubits-Tuple{PauliSum}","page":"Data types","title":"PauliPropagation.nqubits","text":"nqubits(psum::PauliSum)\n\nGet the number of qubits that the PauliSum is defined on.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.VectorPauliSum","page":"Data types","title":"PauliPropagation.VectorPauliSum","text":"VectorPauliSum{TV,CV} <: AbstractPauliSum\n\nVectorPauliSum is a struct that represents a sum of Pauli strings acting on nqubits qubits. It is a wrapper around two vectors: one for the Pauli strings (as unsigned Integers for efficiency reasons), and one for the coefficients. Using it defaults to multi-threaded operations where possible.\n\n\n\n\n\n","category":"type"},{"location":"api/PauliDataTypes/#PauliPropagation.VectorPauliSum-Tuple{Int64}","page":"Data types","title":"PauliPropagation.VectorPauliSum","text":"VectorPauliSum(nqubits::Int)\n\nConstructor for an empty VectorPauliSum on nqubits qubits. Element type defaults for Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.VectorPauliSum-Union{Tuple{CT}, Tuple{Type{CT}, Int64}} where CT","page":"Data types","title":"PauliPropagation.VectorPauliSum","text":"VectorPauliSum(::Type{CT}, nqubits::Int)\n\nContructor for an empty VectorPauliSum on nqubits qubits. The type of the coefficients can be provided.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.nqubits-Tuple{VectorPauliSum}","page":"Data types","title":"PauliPropagation.nqubits","text":"nqubits(vpsum::VectorPauliSum)\n\nGet the number of qubits that the VectorPauliSum is defined on.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PauliSum-Tuple{PauliString}","page":"Data types","title":"PauliPropagation.PauliSum","text":"PauliSum(pstr::PauliString)\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PauliSum-Tuple{Union{Tuple, Base.Generator, AbstractArray}}","page":"Data types","title":"PauliPropagation.PauliSum","text":"PauliSum(pstrs::Vector{PauliString})\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PauliSum-Tuple{VectorPauliSum}","page":"Data types","title":"PauliPropagation.PauliSum","text":"PauliSum(vpsum::VectorPauliSum)\n\nConvert a VectorPauliSum to a PauliSum. Does not change vpsum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PauliSum-Union{Tuple{CT}, Tuple{TT}, Tuple{Integer, PauliString{TT, CT}}} where {TT, CT}","page":"Data types","title":"PauliPropagation.PauliSum","text":"PauliSum(nq::Integer, pstr::PauliString)\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.VectorPauliSum-Tuple{Integer, PauliString}","page":"Data types","title":"PauliPropagation.VectorPauliSum","text":"VectorPauliSum(nq::Integer, pstr::PauliString)\n\nConstructor for a VectorPauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.VectorPauliSum-Tuple{PauliString}","page":"Data types","title":"PauliPropagation.VectorPauliSum","text":"VectorPauliSum(pstr::PauliString)\n\nConstructor for a VectorPauliSum from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.VectorPauliSum-Tuple{PauliSum}","page":"Data types","title":"PauliPropagation.VectorPauliSum","text":"VectorPauliSum(psum::PauliSum)\n\nConvert a PauliSum to a VectorPauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.VectorPauliSum-Tuple{Union{Tuple, Base.Generator, AbstractArray}}","page":"Data types","title":"PauliPropagation.VectorPauliSum","text":"VectorPauliSum(pstrs::Vector{PauliString})\n\nConstructor for a VectorPauliSum from a vector of PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation._checknumberofqubits-Tuple{Union{Tuple, Base.Generator, AbstractArray}}","page":"Data types","title":"PauliPropagation._checknumberofqubits","text":"Checks whether the number of qubits nqubits is the same between in some collection.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.AbstractPauliSum","page":"Data types","title":"PauliPropagation.AbstractPauliSum","text":"AbstractPauliSum <: AbstractTermSum\n\nAbstract type for objects represented sums of Paulis with coefficients.\n\n\n\n\n\n","category":"type"},{"location":"api/PauliDataTypes/#Base.:+-Tuple{PauliString, PauliString}","page":"Data types","title":"Base.:+","text":"+(pstr1::PauliString, pstr2::PauliString)\n\nAddition of two PauliStrings. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#Base.:+-Union{Tuple{PS}, Tuple{PS, PauliString}} where PS<:PauliPropagation.AbstractPauliSum","page":"Data types","title":"Base.:+","text":"+(pstr::PauliString, psum::AbstractPauliSum)\n+(psum::AbstractPauliSum, pstr::PauliString)\n\nAddition of a PauliString to a PauliSum. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#Base.:--Tuple{PauliPropagation.AbstractPauliSum, PauliString}","page":"Data types","title":"Base.:-","text":"-(pstr::PauliString, psum::AbstractPauliSum)\n-(psum::AbstractPauliSum, pstr::PauliString)\n\nSubtract a PauliString from a PauliSum or vice versa. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#Base.:--Tuple{PauliString, PauliString}","page":"Data types","title":"Base.:-","text":"-(pstr1::PauliString, pstr2::PauliString)\n\nSubtract two PauliStrings. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#Base.filter-Union{Tuple{F}, Tuple{F, PauliPropagation.AbstractPauliSum}} where F<:Function","page":"Data types","title":"Base.filter","text":"filter!(filterfunc::Function, psum::AbstractPauliSum)\n\nFilter a AbstractPauliSum by copying and removing all Pauli strings for which filterfunc(pstr, coeff) returns false.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.add!","page":"Data types","title":"PauliPropagation.PropagationBase.add!","text":"add!(psum::AbstractPauliSum, pauli::Symbol, qind::Integer, coeff=1.0)\nadd!(psum::AbstractPauliSum, paulis::Vector{Symbol}, qinds::Vector{Integer}, coeff=1.0)\n\nAdd a Pauli string to a AbstractPauliSum psum. Changes psum in-place. Provide the Pauli string as a Symbol (:I, :X, :Y, :Z) or Vector{Symbol}. Provide the index or indices for those symbols as qind or qinds. The coefficient of the Pauli string in the Pauli sum defaults to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.add!-Tuple{PauliPropagation.AbstractPauliSum, Any, Any}","page":"Data types","title":"PauliPropagation.PropagationBase.add!","text":"add!(psum::AbstractPauliSum, pstr, coeff)\n\nAdd a Pauli string pstr with coefficient coeff to a AbstractPauliSum psum. This changes psum in-place. pstr needs to have the same type as paulitype(psum), and coeff needs to have the same type as coefftype(psum).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.add!-Tuple{PauliPropagation.AbstractPauliSum, PauliPropagation.AbstractPauliSum}","page":"Data types","title":"PauliPropagation.PropagationBase.add!","text":"add!(psum1::AbstractPauliSum, psum2::AbstractPauliSum)\n\nAdd two AbstractPauliSums psum1 and psum2. Changes psum1 in-place. psum1 and psum2 need to be defined on the same number of qubits and have the same coefficient type.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.add!-Tuple{PauliPropagation.AbstractPauliSum, PauliString}","page":"Data types","title":"PauliPropagation.PropagationBase.add!","text":"add!(psum::AbstractPauliSum, pstr::PauliString)\n\nAdd a PauliString pstr to a PauliSum psum. Changes psum in-place. psum and pstr need to be defined on the same number of qubits and have the same coefficient type.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.coefficients","page":"Data types","title":"PauliPropagation.PropagationBase.coefficients","text":"coefficients(psum::AbstractPauliSum)\n\nReturns an iterator over the coefficients of a PauliSum. Call topaulistrings to receive entries as PauliStrings.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.getcoeff-Tuple{PauliPropagation.AbstractPauliSum, Any, Any}","page":"Data types","title":"PauliPropagation.PropagationBase.getcoeff","text":"getcoeff(psum::AbstractPauliSum, pstr::Vector{Symbol}, qinds::Vector{Int})\n\nGet the coefficient of a Pauli string in an AbstractPauliSum by providing the Pauli string pstr as a vector of Symbols acting on qubits qinds.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the AbstractPauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.getcoeff-Tuple{PauliPropagation.AbstractPauliSum, PauliString}","page":"Data types","title":"PauliPropagation.PropagationBase.getcoeff","text":"getcoeff(psum::AbstractPauliSum, pstr::Integer)\n\nGet the coefficient of a PauliString in a PauliSum. Defaults to 0 if the Pauli string is not in the PauliSum. Requires that the integer Pauli string in pstr is the same type as the integer Pauli strings in psum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.getcoeff-Tuple{PauliPropagation.AbstractPauliSum, Symbol, Integer}","page":"Data types","title":"PauliPropagation.PropagationBase.getcoeff","text":"getcoeff(psum::AbstractPauliSum, pauli::Symbol, qind::Integer)\n\nGet the coefficient of a Pauli string in an AbstractPauliSum by providing the Pauli string as a Symbol acting on qubit qind.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the AbstractPauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.getcoeff-Tuple{PauliPropagation.AbstractPauliSum, Vector{Symbol}}","page":"Data types","title":"PauliPropagation.PropagationBase.getcoeff","text":"getcoeff(psum::AbstractPauliSum, pstr::Vector{Symbol})\n\nGet the coefficient of a Pauli string in a AbstractPauliSum by providing the Pauli string pstr as a vector of Symbols acting on all qubits.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the AbstractPauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.PropagationBase.set!","page":"Data types","title":"PauliPropagation.PropagationBase.set!","text":"set!(psum::AbstractPauliSum, pstr, coeff)\n\nIn-place setting the coefficient of a Pauli string in an AbstractPauliSum. The type of the Pauli string needs to be the typeof(pstr)==paulitype(psum) and typeof(coeff)==coefftype(psum).\n\n\n\n\n\n","category":"function"},{"location":"api/PauliDataTypes/#PauliPropagation.filter!-Union{Tuple{F}, Tuple{F, PauliPropagation.AbstractPauliSum}} where F<:Function","page":"Data types","title":"PauliPropagation.filter!","text":"filter!(filterfunc::Function, psum::AbstractPauliSum)\n\nFilter a AbstractPauliSum in-place by removing all Pauli strings for which filterfunc(pstr, coeff) returns false.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.paulis-Tuple{PauliPropagation.AbstractPauliSum}","page":"Data types","title":"PauliPropagation.paulis","text":"paulis(psum::AbstractPauliSum)\n\nReturns an iterator over the integer pauli strings of an AbstractPauliSum. Call topaulistrings to receive entries as PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.paulitype-Tuple{PauliPropagation.AbstractPauliSum}","page":"Data types","title":"PauliPropagation.paulitype","text":"paulitype(psum::AbstractPauliSum)\n\nGet the Pauli integer type of a AbstractPauliSum object.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliDataTypes/#PauliPropagation.topaulistrings-Tuple{PauliPropagation.AbstractPauliSum}","page":"Data types","title":"PauliPropagation.topaulistrings","text":"topaulistrings(psum::AbstractPauliSum)\n\nReturns the Pauli strings in a, AbstractPauliSum and their coefficients as a list of PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Pauli-Algebra","page":"Pauli Algebra","title":"Pauli Algebra","text":"","category":"section"},{"location":"api/PauliAlgebra/#Pauli-operations","page":"Pauli Algebra","title":"Pauli operations","text":"","category":"section"},{"location":"api/PauliAlgebra/#Bit-operations","page":"Pauli Algebra","title":"Bit operations","text":"","category":"section"},{"location":"api/PauliAlgebra/#Utils","page":"Pauli Algebra","title":"Utils","text":"","category":"section"},{"location":"api/PauliAlgebra/#LinearAlgebra.tr-Tuple{PauliPropagation.AbstractPauliSum}","page":"Pauli Algebra","title":"LinearAlgebra.tr","text":"LinearAlgebra.tr(psum::AbstractPauliSum)\n\nCompute the trace of an AbstractPauliSum operator.\n\nThe trace is a linear operation: Tr(A + B) = Tr(A) + Tr(B). Since individual non-identity PauliString terms have a trace of zero (as per tr(::PauliString)), only the coefficient of the identity operator contributes to the total trace of a PauliSum.\n\nThe coefficient of the identity term (0x00) is retrieved from this mapping using get(psum.terms, 0x00, 0).  This coefficient is then multiplied by 2^nqubits(psum) (the dimension of the Hilbert space).  If the identity term (0x00) is not explicitly present in psum.terms, its coefficient is implicitly zero, resulting in a total trace of 0.0.\n\nArguments\n\npsum::PauliSum: The Pauli sum to trace.\n\nReturns\n\nCT: The trace value of the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#LinearAlgebra.tr-Union{Tuple{PauliString{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT}","page":"Pauli Algebra","title":"LinearAlgebra.tr","text":"LinearAlgebra.tr(pstr::PauliString)\n\nCompute the trace of a PauliString operator.\n\nThe trace of any non-identity Pauli operator (e.g., X, Y, Z, or their tensor products) is zero. The identity operator I has a trace equal to the dimension of the Hilbert space, 2^N, where N is the number of qubits.\n\nA PauliString represents a single term, typically of the form coeff * P_1 P_2 ... P_N. If the pstr.term bitmask is 0x00, it signifies the identity operator across all pstr.nqubits. In this case, the trace is pstr.coeff * 2^pstr.nqubits. For any other pstr.term value (representing a non-identity Pauli operator), the trace is 0.0.\n\nArguments\n\npstr::PauliString: The Pauli string to trace. \n\nReturns\n\nCT: The trace value of the PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(pstr1::Integer, pstr2::Integer)\n\nCalculate the commutator of two integer Pauli strings. Returns a tuple of the coefficient and the potentially integer Pauli string. The coefficient is zero if the Pauli strings commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(pstr1::PauliString, pstr2::PauliString)\n\nCalculate the commutator of two PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliSum, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(psum::PauliSum, pstr::PauliString)\ncommutator(pstr::PauliString, psum::PauliSum)\n\nCalculate the commutator of a PauliSum and a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(psum1::PauliSum, psum2::PauliSum)\n\nCalculate the commutator of two PauliSums.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(pstr1::Integer, pstr2::Integer)\n\nCheck if two integer Pauli strings commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(pstr1::PauliString, pstr2::PauliString)\n\nCheck if two Pauli strings of type PauliString commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(psum1::PauliSum, psum2::PauliSum)\n\nCheck if two Pauli sums of type PauliSum commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsXorY-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.containsXorY","text":"containsXorY(pstr::Integer)\n\nCheck if an integer Pauli string contains an X or Y Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsXorY-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.containsXorY","text":"containsXorY(pstr::PauliString)\n\nCheck if a Pauli string contains an X or Y Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsYorZ-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.containsYorZ","text":"containsYorZ(pstr::Integer)\n\nCheck if an integer Pauli string contains a Y or Z Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsYorZ-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.containsYorZ","text":"containsXorY(pstr::PauliString)\n\nCheck if a Pauli string contains a Y or Z Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(pstr::Integer)\n\nFunction to count the weight of an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(pstr::PauliString)\n\nFunction to count the weight of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(psum::PauliSum)\n\nFunction to count the weight Pauli strings in a PauliSum. Returns an array of weights.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countx-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countx","text":"countx(pstr::Integer)\n\nFunction to count the number of X Paulis in an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countx-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countx","text":"countx(pstr::PauliString)\n\nFunction to count the number of X Paulis in a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countx-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countx","text":"countx(psum::PauliSum)\n\nFunction to count the number of X Paulis in a PauliSum. Returns an array of counts.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(pstr::Integer)\n\nFunction to count the number of X and Y Paulis in an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(pstr::PauliString)\n\nFunction to count the number of X and Y Paulis in a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(psum::PauliSum)\n\nFunction to count the number of X and Y Paulis in a PauliSum. Returns an array of counts.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.county-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.county","text":"county(pstr::Integer)\n\nFunction to count the number of Y Paulis in an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.county-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.county","text":"county(pstr::PauliString)\n\nFunction to count the number of Y Paulis in a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.county-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.county","text":"county(psum::PauliSum)\n\nFunction to count the number of Y Paulis in a PauliSum. Returns an array of counts.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(pstr::Integer)\n\nFunction to count the number of Y and Z Paulis in an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(pstr::PauliString)\n\nFunction to count the number of Y and Z Paulis in a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(psum::PauliSum)\n\nFunction to count the number of Y and Z Paulis in a PauliSum. Returns an array of counts.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countz-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countz","text":"countz(pstr::Integer)\n\nFunction to count the number of Z Paulis in an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countz-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countz","text":"countz(pstr::PauliString)\n\nFunction to count the number of Z Paulis in a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countz-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countz","text":"countz(psum::PauliSum)\n\nFunction to count the number of Z Paulis in a PauliSum. Returns an array of counts.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pstr1::Integer, pstr2::Integer)\n\nCalculate the product of two integer Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pstr1::PauliString, pstr2::PauliString)\n\nCalculate the product of two PauliStrings. \n\nExamples\n\njulia> pauliprod(PauliString(1, [:X], [1]), PauliString(1, [:Y], [1])) # X*Y=iZ\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(psum1::PauliSum, psum2::PauliSum)\n\nCalculate the product of two PauliSums.  Default returns a PauliSum{TT, ComplexF64} where TT is the type of the new Pauli Strings.\n\nExamples\n\npsum = PauliSum(PauliString(3, [:Y], [2])) \npsum_identity = PauliSum(PauliString(3, [:I], [1]))\npauliprod(psum, psum_identity) # Psum * I = Psum\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.trace-Tuple{PauliPropagation.AbstractPauliSum}","page":"Pauli Algebra","title":"PauliPropagation.trace","text":"trace(psum::PauliSum)\n\nWrapper for LinearAlgebra.tr(psum::PauliSum).\n\nArguments\n\npsum::PauliSum: The Pauli sum to trace.\n\nReturns\n\nCT: The trace value of the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.trace-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.trace","text":"trace(pstr::PauliString)\n\nWrapper for LinearAlgebra.tr(pstr::PauliString).\n\nArguments\n\npstr::PauliString: The Pauli string to trace. \n\nReturns\n\nCT: The trace value of the PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getinttype-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.getinttype","text":"getinttype(nqubits::Integer)\n\nFunction to return the smallest integer type that can hold nqubits. This is the type that will be used internally for representing Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getpauli-Tuple{Integer, Any}","page":"Pauli Algebra","title":"PauliPropagation.getpauli","text":"getpauli(pstr::PauliStringType, qinds::Vector{Integer})\n\nGets the Paulis on indices qinds of a pstr in the integer representation.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getpauli-Tuple{Integer, Int64, Int64}","page":"Pauli Algebra","title":"PauliPropagation.getpauli","text":"getpauli(pstr::PauliStringType, qind1::Int, qind2::Int)\n\nGets the Paulis from qind1 to qind2 of a pstr in the integer representation. This function is useful for extracting a continuous sub-PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttostring-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttostring","text":"inttostring(pstr::PauliType, nqubits::Integer)\n\nReturns a string representation of an integer Pauli string pstr on nqubits qubits. The characters of the string from left to right are the Paulis on the qubits from 1 to nqubits.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttosymbol-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttosymbol","text":"inttosymbol(pstr::PauliStringType, nqubits::Integer)\n\nMaps an integer Pauli string to a vector of symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttosymbol-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttosymbol","text":"inttosymbol(pauli::PauliType)\n\nMaps an integer Pauli to its corresponding symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.ispauli-Tuple{Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.ispauli","text":"ispauli(pauli1::Union{Symbol, PauliType}, pauli2::Union{Symbol, PauliType})\n\nispauli(pauli1::Union{Vector{Symbol}, PauliStringType}, pauli2::Union{Vector{Symbol}, PauliStringType})\n\nCheck if two Paulis are equal, where one is given as a symbol and the other as an integer.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-NTuple{4, Integer}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(pstr::PauliStringType, target_paulis::PauliStringType, index1::Integer, index2::Integer)\n\nSets the Paulis from index1 to index2 of an integer Pauli string to target_paulis.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(\n    pstr::PauliStringType, \n    target_paulis::Vector{Symbol}, \n    qinds::Vector{Integer}\n)\n\nSet the Paulis qinds of an integer Pauli string pstr to target_paulis. target_paulis is a vector of symbols. Use tuples in performance critical functions because they are immutable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Integer, Any}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(\n    pstr::PauliStringType, \n    target_paulis::PauliStringType, \n    qinds::Vector{Integer}\n)\n\nSet the Paulis qinds of an integer Pauli string pstr to target_paulis. Use Tuples for qinds in performance critical functions because they are immutable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(pstr::PauliStringType, target_pauli::PauliType, index::Integer)\n\nSets the Pauli on index index of an integer Pauli string to target_pauli.  That Pauli should be provided as integer (0, 1, 2, 3).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(pstr::PauliStringType, target_pauli::Symbol, index::Integer)\n\nSets the Pauli on index of an integer Pauli string to target_pauli.  That Pauli should be provided as a symbol (:I, :X, :Y, :Z).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Any}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(pstr::Union{Vector{Symbol}, Symbol})\n\nMaps a symbol or a vector of symbols pstr to an integer Pauli string.\n\nExample:\n\nsymboltoint([:X, :I])\n>>> 0x01\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Integer, Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(nqubits::Integer, paulis::Vector{Symbol}, qinds::Vector{Int})\n\nMaps a vector of symbols pstr acting on the indices qinds to an integer Pauli string. Other sites are set to the identity. qinds can be any iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Integer, Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(nqubits::Integer, pauli::Symbol, qind::Integer)\n\nMaps a single symbol pauli acting on the index qind to an integer Pauli string. Other sites are set to the identity.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Symbol}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(pauli::Symbol)\n\nMaps a single symbol to its corresponding integer representation.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Union{Tuple{TT}, Tuple{Type{TT}, Any, Any}} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(::PauliStringType, paulis, qinds)\n\nMaps a vector of symbols paulis acting on the indices qinds to an integer Pauli string with type PauliStringType. Other sites are set to the identity. qinds can be any iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Union{Tuple{TT}, Tuple{Type{TT}, Symbol, Integer}} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(::PauliStringType, pauli::Symbol, qind::Integer)\n\nMaps a single symbol pauli acting on the index qind to an integer Pauli string with type PauliStringType. Other sites are set to the identity.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"Documentation Paper\n(Image: )(Image: ) (Image: arXiv)","category":"section"},{"location":"#PauliPropagation.jl","page":"Home","title":"PauliPropagation.jl","text":"PauliPropagation.jl is a Julia package for simulating Pauli propagation in quantum circuits and systems. It focuses on simulating the evolution of observables expressed in the Pauli basis under the action of unitary gates and non-unitary channels in a quantum circuit.\n\nUnlike traditional simulators which simulate a circuit mathcalE evolving the state rho in the Schrödinger picture, Pauli propagation often adopts the Heisenberg picture, evolving an observable O under mathcalE^dagger. This can be particularly efficient when the observables remain sparse or structured under evolution, and is useful for estimating expectation values such as textTrleftrho mathcalE^dagger(O)right, studying operator dynamics, and computing correlation functions.\n\nPauli propagation is related to the so-called (extended) stabilizer simulation, but is fundamentally different from, for example, tensor networks. It offers a distinct approach that can handle different regimes of quantum dynamics.\n\nImplemented in Julia, PauliPropagation.jl combines high-performance computation (using features such as multiple dispatch) with an accessible and high-level interface.  ","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Note the current package requires Julia 1.10+.\n\nThe PauliPropagation.jl package is registered and can be installed into your environment in the following way:\n\nusing Pkg\nPkg.add(\"PauliPropagation\")","category":"section"},{"location":"#Install-from-GitHub","page":"Home","title":"Install from GitHub","text":"If you want to install the latest code, you can install the package directly from the Github link. For example, if you are working with a Jupyter notebook, run\n\nusing Pkg\nPkg.add(url=\"https://github.com/MSRudolph/PauliPropagation.jl.git\", rev=\"branchname\")\n\nwhere you can use the keyword rev=\"branchname\" to install development versions of the package. We don't recommend using branches other than main or dev.","category":"section"},{"location":"#A-note-on-installing-Julia","page":"Home","title":"A note on installing Julia","text":"It is recommended to install julia using juliaup with instructions from here. Then, Julia's long-term support version (currently a 1.10 version) can be installed via\n\njuliaup add lts\n\nTo get started running Jupyter notebooks, start a Julia session and install the IJulia package.\n\nIf you are working on several projects with potentially conflicting packages, it is recommended to work with within local environments or projects.\n\nFor more details, we refer to this useful guide.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"You can find detailed example notebooks in the examples folder. We provide a brief example of how to use PauliPropagation.jl.\n\nConsider simulating the dynamics of an operator O=Z_16 under the evolution of a unitary  channel mathcalE(cdot) = U^dagger cdot U in a n=32 qubits system. \n\nusing PauliPropagation\n\nnqubits = 32\n\nobservable = PauliString(nqubits, :Z, 16) # I...IZI...I\n\nOur goal is to compute\n\ntextTrU^dagger O U rho\n\nA simple unitary U is the brickwork circuit, composed of two qubit gates alternating neighbouring sites. We define the circuit connectivity by \n\ntopology = bricklayertopology(nqubits; periodic=true)\n\nwhere periodic specifies the boundary condition of the gates. The library has built-in circuits with e.g. a circuit containing alternating RX and RZZ Pauli gates on the topology. This can be defined by Trotterization of a transverse field Ising Hamiltonian with l steps\n\nU = prod_a=1^l prod_j=1^n e^-i dt   X_j e^-i dt Z_j Z_j+1\n\nnlayers = 32 # l as above\n\ncircuit = tfitrottercircuit(nqubits, nlayers; topology=topology)\n\nIn our simulations, we can choose the circuit parameter dt\n\ndt = 0.1 # time step\n\nparameters = ones(countparameters(circuit)) * dt # all parameters\n\nImportant: The circuit and parameters are defined in the order that they would act in the Schrödinger picture. Within our propagate() function, the order will be reversed to act on the observable. \n\nDuring the propagation via propagate(), we employ truncation strategies such as coefficient or weight truncations, these options can be specified as keywords. \n\n## the truncations\nmax_weight = 6 # maximum Pauli weight\n\nmin_abs_coeff = 1e-4 # minimal coefficient magnitude\n\n## propagate through the circuit\npauli_sum = propagate(circuit, observable, parameters; max_weight, min_abs_coeff)\n\nThe output pauli_sum gives us an approximation of propagated Pauli strings\n\nU^dagger O U approx sum_alpha c_alpha P_alpha\n\nFinally we can compute expectation values with an initial state such as rho = (0 rangle  langle 0 )^otimes n\n\n## overlap with the initial state\noverlapwithzero(pauli_sum)\n# yields 0.154596728241...\n\nThis computation is efficient because the initial state can be written in terms of only mathbbI and Z strings\n\nrho = left(fracmathbbI + Z2right)^otimes n\n\nTherefore, the trace is equivalent to the sum over the coefficients of Pauli strings containing only I and Z Paulis, \n\nmathrmTrU^dagger O U rho approx sum_alpha in mathbbI Z textstrings c_alpha","category":"section"},{"location":"#Important-Notes-and-Caveats","page":"Home","title":"Important Notes and Caveats","text":"Circuits are specified in the Schrödinger picture, as if operated upon states. Behind the scenes, propagate() will (by default) apply the adjoint circuit upon the passed PauliSum which is treated as the observable operator. The default can be changed by passing heisenberg=false to propagate(), though it will not make simulating dense quantum states efficient. \nSchrödinger propagation via heisenberg=false is supported since version 0.7, but not for all gates. So far, we natively support PauliRotation, CliffordGate, and <:PauliNoise gates. ImaginaryPauliRotation is only supported with heisenberg=false.\nWhile Pauli propagation can, in principle, be used for extended stabilizer simulation, we do not currently support sub-exponential strong simulation of stabilizer states.\nSampling quantum states is currently not supported, but is coming soon.\nMany underlying data structures and functions can be used for other purposes involving Pauli operators.\n\nAll of the above can be addressed by writing the additional missing code due to the nice extensibility of Julia.","category":"section"},{"location":"#Upcoming-Features","page":"Home","title":"Upcoming Features","text":"This package is still work-in-progress. You will probably find certain features that you would like to have and that are currently missing.\nHere are some features that we want to implement in the future. Feel free to contribute!\n\nGPU acceleration. Since version 0.7, we provide a PauliPropagationCUDA extension in ext/. So far, it only works with PauliRotation gates and is not yet maximally performant. \nStochastic evolution. Propagation methods are mainly memory-limited. We aim to change this and introduce time vs memory trade-offs.","category":"section"},{"location":"#How-to-contribute","page":"Home","title":"How to contribute","text":"We have a Slack channel #pauli-propagation in the Julia Slack.\n\nIf something bothers you or you want to propose an enhancement, please open an Issue describing everything in detail.\n\nFor a concrete change of code, please fork this GitHub repository and submit a Pull Request.\n\nOtherwise, feel free to reach out to the developers!","category":"section"},{"location":"#Authors","page":"Home","title":"Authors","text":"The main developer of this package is Manuel S. Rudolph in the Quantum Information and Computation Laboratory of Prof. Zoë Holmes at EPFL, Switzerland. Contact Manuel via manuel.rudolph@epfl.ch.\n\nFurther contributors to this package include Yanting Teng, Tyson Jones, and Su Yeon Chang. This package is the derivative of ongoing work at the Quantum Information and Computation lab at EPFL, supervised by Prof. Zoë Holmes.\n\nFor more specific code issues, bug fixes, etc. please open a GitHub issue.","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you are publishing research using PauliPropagation.jl, please cite this library and our paper: \n\n@article{rudolph2025pauli,\n  title={Pauli Propagation: A Computational Framework for Simulating Quantum Systems},\n  author={Rudolph, Manuel S and Jones, Tyson and Teng, Yanting and Angrisani, Armando and Holmes, Zoe},\n  journal={arXiv preprint arXiv:2501.13101},\n  year={2025},\n  url={https://arxiv.org/abs/2501.13101}\n}","category":"section"},{"location":"#Related-publications","page":"Home","title":"Related publications","text":"Some of the developers of this package are co-authors in the following papers using Pauli propagation and (at least parts of) this code. If you are using our package, please consider citing some of these works:\n\nClassical simulations of noisy variational quantum circuits\nClassical surrogate simulation of quantum systems with LOWESA\nQuantum Convolutional Neural Networks are (Effectively) Classically Simulable\nClassically estimating observables of noiseless quantum circuits\nEfficient quantum-enhanced classical simulation for patches of quantum landscapes\nSimulating quantum circuits with arbitrary local noise using Pauli Propagation\nLeveraging Symmetry Merging in Pauli Propagation\nThermal State Simulation with Pauli and Majorana Propagation\n\nAnd more are coming up.","category":"section"},{"location":"api/Gates/#Gates","page":"Gates","title":"Gates","text":"","category":"section"},{"location":"api/Gates/#Clifford-Gates","page":"Gates","title":"Clifford Gates","text":"","category":"section"},{"location":"api/Gates/#Pauli-Rotations","page":"Gates","title":"Pauli Rotations","text":"","category":"section"},{"location":"api/Gates/#Imaginary-Pauli-Rotations","page":"Gates","title":"Imaginary Pauli Rotations","text":"","category":"section"},{"location":"api/Gates/#Noise-Channels","page":"Gates","title":"Noise Channels","text":"","category":"section"},{"location":"api/Gates/#Misc","page":"Gates","title":"Misc","text":"","category":"section"},{"location":"api/Gates/#Frozen-Gates","page":"Gates","title":"Frozen Gates","text":"","category":"section"},{"location":"api/Gates/#PauliPropagation.CliffordGate","page":"Gates","title":"PauliPropagation.CliffordGate","text":"A type for a Clifford gate that carries the name of the gate and qubit indices on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.CliffordGate-Tuple{Symbol, Any}","page":"Gates","title":"PauliPropagation.CliffordGate","text":"CliffordGate(symbol::Symbol, qinds::Vector{Int})\nCliffordGate(symbol::Symbol, qinds::Int)\n\nA Clifford gate with the name symbol acting on the qubits qinds. symbol needs to match any of the implemented Clifford gates in the global clifford_map. qinds can be a single integer, a vector of integers, or anything that transforms into a vector via vec(collect(qinds)).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.composecliffordmaps-Tuple{Any}","page":"Gates","title":"PauliPropagation.composecliffordmaps","text":"composecliffordmaps(circuit::Vector{CliffordGate})\n\nCompose a circuit of Clifford gates into a single Clifford map. The length of the map is 4^nq where nq is the maximum qubit index in the circuit. The resulting clifford map can be added to the global clifford_map with a custom Clifford gate name. The maximum number of qubits is 4 due to current restrictions of UInt8. Even if all gates only act on one qubit, that qubit index will determine the dimensionality of the map.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.createcliffordmap-Tuple{Dict}","page":"Gates","title":"PauliPropagation.createcliffordmap","text":"createcliffordmap(gate_relations::Dict)\n\nCreate a Clifford gate map from a dictionary of gate relations which can then be pushed to the global clifford_map. gate_relations is a dictionary with pairs like (:X, :X) => (:Z, :X, -1), describing the action of the Clifford gate on symbols (including the sign change).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.reset_clifford_map!-Tuple{}","page":"Gates","title":"PauliPropagation.reset_clifford_map!","text":"reset_clifford_map!()\n\nReset global clifford_map to the CLifford gate implemented by default.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.transposecliffordmap-Tuple{Vector{Tuple{UInt8, Int64}}}","page":"Gates","title":"PauliPropagation.transposecliffordmap","text":"transposecliffordmap(map_array::Vector{Tuple{UInt8,Int}})\n\nTranspose the Clifford gate maparray so that the output map is the inverse of the input map. For example, transposecliffordmap(clifford_map[:H]) returns the map for the inverse of the Hadamard gate, which is the same map.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.clifford_map","page":"Gates","title":"PauliPropagation.clifford_map","text":"clifford_map\n\nGlobal dictionary of Clifford gates and their action on Pauli strings. Currently supported Clifford gates are :H, :X, :Y, :Z, :SX, :SY, :S (:SZ) , :CNOT, :CZ, :ZZpihalf, and :SWAP. If one indexes into the returned arrays with the integer that corresponds to the partial Pauli string, the returned tuple is (sign, partial_pstr) where sign is the sign change and partial_pstr is the new partial Pauli string.\n\n\n\n\n\n","category":"constant"},{"location":"api/Gates/#PauliPropagation.PauliRotation","page":"Gates","title":"PauliPropagation.PauliRotation","text":"A type for a Pauli rotation gate carrying the gate generator and the qubit indices on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliRotation-Tuple{Any, Any, Any}","page":"Gates","title":"PauliPropagation.PauliRotation","text":"PauliRotation(symbols, qinds, theta)\n\nConstructor for a frozen PauliRotation generated by the Pauli string symbols acting on the qubits qinds, and with fixed parameter theta.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliRotation-Tuple{Any, Any}","page":"Gates","title":"PauliPropagation.PauliRotation","text":"PauliRotation(symbols::Vector{Symbol}, qinds::Vector{Int})\nPauliRotation(symbol::Symbol, qind::Int)\n\nA parametrized Pauli rotation generated by the Pauli string symbols acting on the qubits qinds. For example PauliRotation(:X, 2) or PauliRotation([:X, :Y], [1, 2]). We follow the convention that those rotation are equivalent by conjugation of \n\ne^-i θ2 P\n\nwhere P is the corresponding Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.commutes-Tuple{PauliRotation, Integer}","page":"Gates","title":"PauliPropagation.commutes","text":"commutes(gate::PauliRotation, pstr::Integer)\n\nCheck if a PauliRotation commutes with an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.commutes-Tuple{PauliRotation, PauliString}","page":"Gates","title":"PauliPropagation.commutes","text":"commutes(gate::PauliRotation, pstr::PauliString)\n\nCheck if a PauliRotation commutes with a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.tomatrix-Tuple{PauliRotation, Any}","page":"Gates","title":"PauliPropagation.tomatrix","text":"tomatrix(gate::PauliRotation, theta)\n\nCompute the unitary matrix for the PauliRotation gate with parameter theta in the computational 0/1 basis. This is done by computing the matrix U = cos(θ/2) I - i sin(θ/2) P where P is the Pauli matrix corresponding to the symbols. The returned unitary is returned in Schrödinger picture form.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.ImaginaryPauliRotation","page":"Gates","title":"PauliPropagation.ImaginaryPauliRotation","text":"A type for an imaginary Pauli rotation gate carrying the gate generator and the qubit indices on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.ImaginaryPauliRotation-Tuple{Any, Any, Any}","page":"Gates","title":"PauliPropagation.ImaginaryPauliRotation","text":"ImaginaryPauliRotation(symbols, qinds, tau)\n\nConstructor for a frozen ImaginaryPauliRotation generated by the Pauli string symbols acting on the qubits qinds, and with fixed parameter tau.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.ImaginaryPauliRotation-Tuple{Any, Any}","page":"Gates","title":"PauliPropagation.ImaginaryPauliRotation","text":"ImaginaryPauliRotation(symbols::Vector{Symbol}, qinds::Vector{Int})\nImaginaryPauliRotation(symbol::Symbol, qind::Int)\n\nA parametrized imaginary Pauli rotation generated by the Pauli string symbols acting on the qubits qinds. For example ImaginaryPauliRotation(:X, 2) or ImaginaryPauliRotation([:X, :Y], [1, 2]). We follow the convention that those rotation are equivalent by conjugation of \n\ne^-θ2 P\n\nwhere P is the corresponding Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.AmplitudeDampingNoise","page":"Gates","title":"PauliPropagation.AmplitudeDampingNoise","text":"A type for an amplitude damping noise channel carrying the qubit index on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.AmplitudeDampingNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.AmplitudeDampingNoise","text":"AmplitudeDampingNoise(qind::Int)\nAmplitudeDampingNoise(qind::Int, gamma::Real)\n\nAn amplitude damping noise channel acting on the qubit at index qind. If gamma is provided, this returns a frozen gate with that noise strength. Damps X and Y Paulis by a factor of sqrt(1-gamma) and splits Z into and gamma * I and (1-gamma) * Z component (in the transposed Heisenberg picture).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.DephasingNoise","page":"Gates","title":"PauliPropagation.DephasingNoise","text":"DephasingNoise(qind::Int)\nDephasingNoise(qind::Int, p::Real)\n\nThis is an alias for PauliZNoise. If p is provided, this returns a frozen gate with that noise strength. A dephasing noise channel acting on the qubit at index qind. Will damp X and Y Paulis equally by a factor of 1-p.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.DepolarizingNoise","page":"Gates","title":"PauliPropagation.DepolarizingNoise","text":"A type for a depolarizing noise channel carrying the qubit index on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.DepolarizingNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.DepolarizingNoise","text":"DepolarizingNoise(qind::Int)\nDepolarizingNoise(qind::Int, p::Real)\n\nA depolarizing noise channel acting on the qubit at index qind. If p is provided, this returns a frozen gate with that noise strength. Will damp X, Y, and Z Paulis equally by a factor of 1-p.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.ParametrizedNoiseChannel","page":"Gates","title":"PauliPropagation.ParametrizedNoiseChannel","text":"Abstract type for parametrized noise channels.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliNoise","page":"Gates","title":"PauliPropagation.PauliNoise","text":"Abstract type for Pauli noise, i.e., noise that is diagonal in Pauli basis.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliXNoise","page":"Gates","title":"PauliPropagation.PauliXNoise","text":"A type for a Pauli X noise channel carrying the qubit index on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliXNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliXNoise","text":"PauliXNoise(qind::Int)\nPauliXNoise(qind::Int, p::Real)\n\nA Pauli-X noise channel acting on the qubit at index qind. If p is provided, this returns a frozen gate with that noise strength. Will damp Y and Z Paulis equally by a factor of 1-p. This corresponds to inserting a Pauli X operator into the circuit with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliYNoise","page":"Gates","title":"PauliPropagation.PauliYNoise","text":"A type for a Pauli Y noise channel carrying the qubit index on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliYNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliYNoise","text":"PauliYNoise(qind::Int)\nPauliYNoise(qind::Int, p::Real)\n\nA Pauli-Y noise channel acting on the qubit at index qind. If p is provided, this returns a frozen gate with that noise strength. Will damp X and Z Paulis equally by a factor of 1-p. This corresponds to inserting a Pauli Y operator into the circuit with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliZNoise","page":"Gates","title":"PauliPropagation.PauliZNoise","text":"A type for a Pauli Z noise channel carrying the qubit index on which it acts.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliZNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliZNoise","text":"PauliZNoise(qind::Int)\nPauliZNoise(qind::Int, p::Real)\n\nA Pauli-Z noise channel acting on the qubit at index qind. If p is provided, this returns a frozen gate with that noise strength. Will damp X and Y Paulis equally by a factor of 1-p. This corresponds to inserting a Pauli Z operator with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.TGate-Tuple{Integer}","page":"Gates","title":"PauliPropagation.TGate","text":"TGate(qind::Integer)\n\nReturns a T gate acting on qubit qind. It acts on qubit qind like a PauliRotation(:Z, qind) with angle π/4.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.TransferMapGate","page":"Gates","title":"PauliPropagation.TransferMapGate","text":"TransferMapGate(transfer_map::Vector{Vector{Tuple{PauliStringType,CoeffType}}}, qinds::Vector{Int})\n\nA non-parametrized StaticGate defined by a transfer map acting on the qubits qinds. Transfer maps can be constructed manually or generated via totransfermap().\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.TransferMapGate-Tuple{AbstractMatrix, Any}","page":"Gates","title":"PauliPropagation.TransferMapGate","text":"A constructor for TransferMapGate that accepts matrix representations in the 0/1 basis or the Pauli basis (a PTM).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.tomatrix-Tuple{TGate}","page":"Gates","title":"PauliPropagation.tomatrix","text":"tomatrix(gate::TGate)\n\nCompute the unitary matrix for a TGate. The returned unitary is returned in Schrödinger picture form. \n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.FrozenGate-Union{Tuple{PT}, Tuple{GT}, Tuple{GT, PT}} where {GT<:ParametrizedGate, PT}","page":"Gates","title":"PauliPropagation.FrozenGate","text":"FrozenGate(gate::ParametrizedGate, parameter)\n\nA StaticGate that wraps a ParametrizedGate with a fixed parameter. These are used to fix the parameter of ParametrizedGate at the time of circuit construction. This can be convenient but might exclude this parameter from being, e.g., differentiated by external libraries.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.freeze-Tuple{Any, Any}","page":"Gates","title":"PauliPropagation.freeze","text":"freeze(gates::Vector{Gate}, parameters::Vector{Number})\n\nReturns a vector of Gates where ParametrizedGates are frozen with their parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.freeze-Tuple{ParametrizedGate, Any}","page":"Gates","title":"PauliPropagation.freeze","text":"freeze(gate::ParametrizedGate, parameter)\n\nReturns a FrozenGate wrapping the gate with the fixed parameter.\n\n\n\n\n\n","category":"method"}]
}
