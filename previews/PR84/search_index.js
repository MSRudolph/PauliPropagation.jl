var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"TODO","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The PauliPropagation.jl package is registered and can be installed into your environment in the following way:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"PauliPropagation\")","category":"page"},{"location":"installation/#Install-from-GitHub","page":"Installation","title":"Install from GitHub","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you want to install the latest code, you can install the package directly from the Github link. For example, if you are working with a Jupyter notebook, run","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/MSRudolph/PauliPropagation.jl.git\", rev=\"branchname\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"where you can use the keyword rev=\"branchname\" to install development versions of the package. We don't recommend using branches other than main or dev.","category":"page"},{"location":"installation/#Clone-repository-and-install-locally","page":"Installation","title":"Clone repository and install locally","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Navigate to a local directory where you want to clone this repository into and run the following in a terminal","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"git clone git@github.com:MSRudolph/PauliPropagation.jl.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Inside this cloned repository you can now freely import PauliPropagation or install it into your environment.\nAlternatively, you can push the relative path to the cloned repository to the Julia package load path called LOAD_PATH via","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"rel_path = \"your/relative/path/PauliPropagation\"\npush!(LOAD_PATH,rel_path);","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"This may require that you have no global installation of PauliPropagation in your enviroment.","category":"page"},{"location":"installation/#A-note-on-julia-installation","page":"Installation","title":"A note on julia installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"It is recommended to install julia using juliaup","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"juliaup add 1.10","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Go to the project directory (e.g. PauliPropagation.jl). To start julia for a local environment","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia --project=./","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"More details can be found on this useful guide.","category":"page"},{"location":"api/Surrogate/#Surrogate","page":"Surrogate","title":"Surrogate","text":"","category":"section"},{"location":"api/Surrogate/#Datatypes","page":"Surrogate","title":"Datatypes","text":"","category":"section"},{"location":"api/Surrogate/#PauliPropagation.NodePathProperties","page":"Surrogate","title":"PauliPropagation.NodePathProperties","text":"NodePathProperties(node::CircuitNode)\nNodePathProperties(node::CircuitNode, nsins::Int, ncos::Int, freq::Int)\n\nSurrogate PathProperties type. Carries CircuitNodes instead of numerical coefficients. If nsins, ncos, and freq are not provided, they are initialized to 0.\n\n\n\n\n\n","category":"type"},{"location":"api/Surrogate/#PauliPropagation.tonumber-Tuple{NodePathProperties}","page":"Surrogate","title":"PauliPropagation.tonumber","text":"tonumber(path::NodePathProperties)\n\nGet the cummulative coefficient of a NodePathProperties node. This assumes that the surrogate has already been evaluated.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.wrapcoefficients-Tuple{PauliString, Type{NodePathProperties}}","page":"Surrogate","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(pstr::PauliString, ::Type{NodePathProperties})\n\nWrap the coefficient of a PauliString into NodePathProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.wrapcoefficients-Tuple{PauliSum, Type{NodePathProperties}}","page":"Surrogate","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(psum::PauliSum, ::Type{NodePathProperties})\n\nWrap the coefficients of a PauliSum into NodePathProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#Evaluate","page":"Surrogate","title":"Evaluate","text":"","category":"section"},{"location":"api/Surrogate/#PauliPropagation.evaluate!-Union{Tuple{TT}, Tuple{PauliSum{TT, NodePathProperties}, Any}} where TT","page":"Surrogate","title":"PauliPropagation.evaluate!","text":"evaluate!(psum::PauliSum{<:Integer,NodePathProperties}, thetas; reset=true)\n\nEvaluate the expectation value of a Surrogate by evaluating all involved circuit nodes in the correct order. eval_list can be attained as the output of gettraceevalorder(). If reset is false, the function will not reset the is_evaluated flags of the nodes. This should only be done if they are manually reset.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Tuple{PauliPropagation.CircuitNode}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(circuit_node::CircuitNode)\n\nReset a CircuitNode in a the Surrogate. Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Tuple{PauliPropagation.EvalEndNode}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(end_node::EvalEndNode)\n\nReset a EvalEndNode in a the Surrogate.  These sit on the coeff field of NodePathProperties and are the end of the evaluation chain. Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Union{Tuple{AbstractVector{CT}}, Tuple{CT}} where CT<:NodePathProperties","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(paths::Vector{NodePathProperties})\n\nReset a vector of NodePathProperties in a the Surrogate.  Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.reset!-Union{Tuple{PauliSum{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT<:NodePathProperties}","page":"Surrogate","title":"PauliPropagation.reset!","text":"reset!(psum::PauliSum{<:Integer, NodePathProperties})\n\nReset the nodes in a the Surrogate.  Needs to be done in-between evaluations with different parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#Propagate","page":"Surrogate","title":"Propagate","text":"","category":"section"},{"location":"api/Surrogate/#PauliPropagation.propagate!-Union{Tuple{TT}, Tuple{Any, PauliSum{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.propagate!","text":"propagate!(circ, psum::PauliSum{<:Integer,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliSum through the circuit circ in the Heisenberg picture.  The PauliSum psum is modified in place. The circuit must only contain CliffordGates and PauliRotations. Truncations based on any numerical coefficient value cannot be used. Everything else is the same as in propagate!() for the non-Surrogate code.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.propagate-Union{Tuple{TT}, Tuple{Any, PauliString{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.propagate","text":"propagate(circ, pstr::PauliString{<:Integer,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliString through the circuit circ in the Heisenberg picture.  The circuit must only contain CliffordGates and PauliRotations. Truncations based on any numerical coefficient value cannot be used. Everything else is the same as in propagate!() for the non-Surrogate code.\n\n\n\n\n\n","category":"method"},{"location":"api/Surrogate/#PauliPropagation.propagate-Union{Tuple{TT}, Tuple{Any, PauliSum{TT, NodePathProperties}}} where TT<:Integer","page":"Surrogate","title":"PauliPropagation.propagate","text":"propagate(circ, psum::PauliSum{<:Integer,NodePathProperties}; max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nConstruct a Pauli propagation surrogate of the propagated PauliSum through the circuit circ in the Heisenberg picture. The circuit must only contain CliffordGates and PauliRotations.  Truncations based on any numerical coefficient value cannot be used. Everything else is the same as in propagate!() for the non-Surrogate code.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#Path-Properties","page":"Path Properties","title":"Path Properties","text":"","category":"section"},{"location":"api/PathProperties/#Pauli-frequency-tracker","page":"Path Properties","title":"Pauli frequency tracker","text":"","category":"section"},{"location":"api/PathProperties/#PauliPropagation.PauliFreqTracker","page":"Path Properties","title":"PauliPropagation.PauliFreqTracker","text":"PauliFreqTracker(coeff::Number, nsins::Int, ncos::Int, freq::Int)\n\nWrapper type for numerical coefficients in Pauli propagation that records  the number of sin and cos factors applied via a PauliRotation gate, and the so-called frequency, which is their sum. It appears redundant but these three properties need to be tracked separately because of how merging affects them.\n\n\n\n\n\n","category":"type"},{"location":"api/PathProperties/#PauliPropagation.PauliFreqTracker-Tuple{Number}","page":"Path Properties","title":"PauliPropagation.PauliFreqTracker","text":"PauliFreqTracker(coeff::Number)\n\nConstructor for PauliFreqTracker from only a coefficient. Initializes nsins, ncos, and freq to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#Abstract-type","page":"Path Properties","title":"Abstract type","text":"","category":"section"},{"location":"api/PathProperties/#PauliPropagation.PathProperties","page":"Path Properties","title":"PauliPropagation.PathProperties","text":"Abstract type for wrapping coefficients and record custom path properties\n\n\n\n\n\n","category":"type"},{"location":"api/PathProperties/#Base.float-Tuple{PProp} where PProp<:PathProperties","page":"Path Properties","title":"Base.float","text":"float(path::PathProperties)\n\nReturns an equivalent PathProperties object where float() is applied to the coeff field.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.tonumber-Tuple{PProp} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.tonumber","text":"tonumber(path::PathProperties)\n\nGet the numerical coefficient of a PathProperties wrapper.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.unwrapcoefficients-Union{Tuple{PauliString{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT}","page":"Path Properties","title":"PauliPropagation.unwrapcoefficients","text":"unwrapcoefficients(pstr::PauliString)\n\nUnwrap the coefficient of a PauliString from a PathProperties type. Returns a PauliString with the coeff field of the PathProperties object.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.unwrapcoefficients-Union{Tuple{PauliSum{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT}","page":"Path Properties","title":"PauliPropagation.unwrapcoefficients","text":"unwrapcoefficients(psum::PauliSum)\n\nUnwrap the coefficients of a PauliSum from a PathProperties type. Returns a PauliSum with coefficients being the coeff field of the PathProperties objects.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.wrapcoefficients-Union{Tuple{PProp}, Tuple{PauliString, Type{PProp}}} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(pstr::PauliString, PathPropertiesType<:PathProperties)\n\nWrap the coefficient of a PauliString into a custom PathProperties type. For anything that is not natively supported by the library, you can subtype PathProperties. A one-argument constructor of the custom PathProperties type from a coefficient must be defined.\n\n\n\n\n\n","category":"method"},{"location":"api/PathProperties/#PauliPropagation.wrapcoefficients-Union{Tuple{PProp}, Tuple{PauliSum, Type{PProp}}} where PProp<:PathProperties","page":"Path Properties","title":"PauliPropagation.wrapcoefficients","text":"wrapcoefficients(psum::PauliSum, PathPropertiesType<:PathProperties)\n\nWrap the coefficients of a PauliSum into a custom PathProperties type. For anything that is not natively supported by the library, you can subtype PathProperties. A one-argument constructor of the custom PathProperties type from a coefficient must be defined.\n\n\n\n\n\n","category":"method"},{"location":"api/Truncations/#Truncations","page":"Truncations","title":"Truncations","text":"","category":"section"},{"location":"api/Truncations/#PauliPropagation.truncatedampingcoeff-Tuple{Integer, Any, Real, Real}","page":"Truncations","title":"PauliPropagation.truncatedampingcoeff","text":"truncatedampingcoeff(\n    pstr::Integer, \n    coeff::Real, \n    gamma::Real, \n    min_abs_coeff::Float64\n)\n\nCustom truncation function with dissipation-assisted damping of coefficients.\n\nThis function damps the coefficient coeff scaling with the weight of an interger Pauli string pstr.  The damping factor is gamma.  If the coefficient, damped by an exponential factor, falls below min_abs_coeff,  the function returns true to indicate truncation.\n\nArguments\n\npstr::PauliStringType: The Pauli string whose coefficient may be damped.\ncoeff::Float64: The coefficient associated with the Pauli string pstr.\ngamma::Float64: Gamma, rate of exponential decay in the damping process.\nmin_abs_coeff::Float64: The minimum value of the coefficient for truncation.\n\nReturns\n\nBool: true if the damped coefficient of pstr < min_abs_coeff;   false otherwise.\n\nDetails\n\nThe function evaluates the condition: abs(coeff) * exp(-gamma * w(pstr)) < min_abs_coeff\n\nwhere w(pstr) is the weight of the Pauli string (computed by countweight).  The damping factor gamma controls the exponential decay.\n\nExamples\n\n```julia truncatedampingcoeff(pstr, 0.8, 0.5, 0.01)\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#State-Overlap","page":"State Overlap","title":"State Overlap","text":"","category":"section"},{"location":"api/StateOverlap/#Base.filter!-Union{Tuple{F}, Tuple{F, PauliSum}} where F<:Function","page":"State Overlap","title":"Base.filter!","text":"filter!(filterfunc::Function, psum::PauliSum)\n\nFilter a PauliSum in-place by removing all Pauli strings for which filterfunc(pstr, coeff) returns false.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#Base.filter-Union{Tuple{F}, Tuple{F, PauliSum}} where F<:Function","page":"State Overlap","title":"Base.filter","text":"filter(filterfunc::Function, psum::PauliSum)\n\nReturn a filtered PauliSum by removing all Pauli strings for which filterfunc(pstr, coeff) returns false.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapbyorthogonality-Union{Tuple{F}, Tuple{F, PauliSum}} where F<:Function","page":"State Overlap","title":"PauliPropagation.overlapbyorthogonality","text":"overlapbyorthogonality(orthogonalfunc::Function, psum::PauliSum)\noverlapbyorthogonality(orthogonalfunc::Function, pstr::PauliString)\noverlapbyorthogonality(orthogonalfunc::Function, pstr::Integer)\n\nOverlap a PauliSum, PauliString or integer Pauli string with a state or operator via function  that returns true if a Pauli string is orthogonal or not. If a Pauli string is orthogonal, it does not contribute, otherwise it contributes with its coefficient. This is particularly useful for overlaps with stabilizer states. An example orthogonalfunc is containsXorY which returns true if a Pauli string contains an X or Y Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithcomputational-Tuple{PauliSum, Any}","page":"State Overlap","title":"PauliPropagation.overlapwithcomputational","text":"overlapwithcomputational(psum::PauliSum, onebitinds)\noverlapwithcomputational(pstr::PauliString, onebitinds)\n\nCalculates the overlap of a Pauli sum or Pauli string with the computational basis state  which has one-bits at all specified indices and zero-bits elsewhere. If |x><x| is a computational basis state, it we compute Tr[psum * |x><x|] = <x|psum|x> or Tr[pstr * |x><x|] = <x|pstr|x>. For example, overlapwithcomputational(psum, [1,2,4]) returns the overlap with |1101000...>.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithmaxmixed-Union{Tuple{PauliSum{TT, CT}}, Tuple{CT}, Tuple{TT}} where {TT, CT}","page":"State Overlap","title":"PauliPropagation.overlapwithmaxmixed","text":"overlapwithmaxmixed(psum::PauliSum)\n\nCalculates the overlap of a PauliSum with the maximally mixed state I/2^n, i.e., Tr[psum * I/2^n].\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithplus-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.overlapwithplus","text":"overlapwithplus(psum) \noverlapwithplus(pstr)\n\nCalculates the overlap of a Pauli sum or Pauli string with the plus state |+><+|, i.e. Tr[psum * |+><+|] = <+|psum|+> or Tr[pstr * |+><+|] = <+|pstr|+>.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.overlapwithzero-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.overlapwithzero","text":"overlapwithzero(psum) \noverlapwithzero(pstr)\n\nCalculates the overlap of a Pauli sum with the zero state |0><0|, i.e., Tr[psum * |0><0|] = <0|psum|0> or Tr[pstr * |0><0|] = <0|pstr|0>.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.plusfilter!-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.plusfilter!","text":"zerofilter!(psum)\n\nFilter a Pauli sum in-place with only Pauli strings that are not orthogonal to the plus state |+><+|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.plusfilter-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.plusfilter","text":"plusfilter(psum)\n\nReturn a filtered Pauli sum with only Pauli strings that are not orthogonal to the plus state |+><+|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.scalarproduct-Tuple{PauliSum, PauliSum}","page":"State Overlap","title":"PauliPropagation.scalarproduct","text":"scalarproduct(psum1::PauliSum, psum2::PauliSum)\nscalarproduct(pstr::PauliString, psum::PauliSum)\nscalarproduct(psum::PauliSum, pstr::PauliString)\nscalarproduct(pstr1::PauliString, pstr2::PauliString)\n\nCalculates the scalar product between any combination of PauliSum and PauliString. This  calculates the sum of the products of their coefficients for all Pauli strings that are present . Important: This is not equivalent to the trace Tr[psum1 * psum2] but instead  Tr[psum1 * psum2]/2^n, and equivalently for Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.zerofilter!-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.zerofilter!","text":"zerofilter!(psum)\n\nFilter a Pauli sum in-place with only Pauli strings that are not orthogonal to the zero state |0><0|.\n\n\n\n\n\n","category":"method"},{"location":"api/StateOverlap/#PauliPropagation.zerofilter-Tuple{Any}","page":"State Overlap","title":"PauliPropagation.zerofilter","text":"zerofilter(psum)\n\nReturn a filtered Pauli sum with only Pauli strings that are not orthogonal to the zero state |0><0|.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#Circuits","page":"Circuits","title":"Circuits","text":"","category":"section"},{"location":"api/Circuits/#Builders","page":"Circuits","title":"Builders","text":"","category":"section"},{"location":"api/Circuits/#PauliPropagation.appendSU4!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.appendSU4!","text":"appendSU4!(circuit, pair)\n\nAppend a layer of SU(4) gates to a circuit on a given pair of qubits. The SU(4) gate is decomposed via the KAK Decomposition into single-qubit Z-X-Z gates on each qubit, followed by XX-YY-ZZ gates and again single-qubit Z-X-Z gates, for a total of 15 Pauli gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.efficientsu2circuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.efficientsu2circuit","text":"efficientsu2circuit(nqubits::Integer, nlayers::Integer; topology=nothing)\n\nCreate a hardware-efficient circuit consisting of layers of single-qubit Y-Z Pauli gates and CNOT entangling gates. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.hardwareefficientcircuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.hardwareefficientcircuit","text":"hardwareefficientcircuit(nqubits::Integer, nlayers::Integer; topology=nothing)\n\nCreate a hardware-efficient circuit consisting of layers of single-qubit X-Z-X Pauli gates and YY entangling gates. A topology can be specified as a list of pairs of qubit indices.  If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.heisenbergtrottercircuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.heisenbergtrottercircuit","text":"heisenbergtrottercircuit(nqubits::Integer, nlayers::Integer; topology=nothing)\n\nCreate a circuit that corresponds to a Trotterization of the Heisenberg Hamiltonian. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used. Note that the gates are applied as layers of XX-YY-ZZ gates, not as layers of XX on all, then YY on all, then ZZ on all. On the bricklayer topology, these are equivalent.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.qcnncircuit-Tuple{Integer}","page":"Circuits","title":"PauliPropagation.qcnncircuit","text":"qcnncircuit(nqubits::Integer; periodic=false)\n\nCreate a Quantum Convolutional Neural Network (QCNN) circuit on nqubits qubits. The topology for the circuit is created by creating bricklayer topologies on half the qubits every layer. The final qubits are qubit 1 and ~nqubits/2, which should be measured.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rxlayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.rxlayer!","text":"rxlayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:X, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rxxlayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.rxxlayer!","text":"rxxlayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:X, :X], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rylayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.rylayer!","text":"rylayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:Y, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.ryylayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.ryylayer!","text":"ryylayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:Y, :Y], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rzlayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.rzlayer!","text":"rzlayer!(circuit, nqubits)\n\nAppend a layer of single-qubit PauliRotation(:Z, qind) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rzzlayer!-Tuple{Any, Any}","page":"Circuits","title":"PauliPropagation.rzzlayer!","text":"rzzlayer!(circuit, topology)\n\nAppend a layer of two-qubit PauliRotation([:Z, :Z], pair) gates to the circuit for each pair in the topology.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.su4circuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.su4circuit","text":"su4circuit(nqubits::Integer, nlayers::Integer; topology=nothing)\n\nCreate a circuit that consists of layers of SU(4) gates on a given topology.  SU(4) gates are decomposed via the KAK Decomposition into single-qubit Z-X-Z gates on each qubit, followed by XX-YY-ZZ gates and again single-qubit Z-X-Z gates, for a total of 15 Pauli gates. A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.tfitrottercircuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.tfitrottercircuit","text":"tfitrottercircuit(nqubits::Integer, nlayers::Integer; topology=nothing, start_with_ZZ=true)\n\nCreate a circuit that corresponds to a Trotterization of the transverse-field Ising Hamiltonian.  A topology can be specified as a list of pairs of qubit indices. If no topology is specified, a bricklayer topology is used. If start_with_ZZ is set to true, the circuit starts with a layer of ZZ gates, else with a layer of X gates. This is relevant depending on the initial state.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.tiltedtfitrottercircuit-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.tiltedtfitrottercircuit","text":"tiltedtfitrottercircuit(nqubits, n_layers; topology=nothing)\n\nReturns a Trottterized circuit for the tilted transverse field Ising model. H = Sum{(i, i+1) in topology} Zi Z_{i+1} \n\nSum{i=1}^{nqubits} Zi + Sum{i=1}^{nqubits} Xi\n\nArguments\n\nnqubits::Integer: The number of qubits in the circuit.\nn_layers::Integer: The number of Trotter steps to perform.\ntopology=nothing: The topology of the qubits in the circuit.    Default (nothing): A linear chain.\n\nReturns\n\nThe Trottterized circuit as a vector of Gate.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#Topologies","page":"Circuits","title":"Topologies","text":"","category":"section"},{"location":"api/Circuits/#PauliPropagation.ibmeagletopology","page":"Circuits","title":"PauliPropagation.ibmeagletopology","text":"ibmeagletopology\n\nTopology of the IBM Eagle device with 127 qubits. Also called the heave-hex topology on 127 qubits.\n\n\n\n\n\n","category":"constant"},{"location":"api/Circuits/#PauliPropagation.bricklayertopology-Tuple{Any}","page":"Circuits","title":"PauliPropagation.bricklayertopology","text":"bricklayertopology(qindices; periodic=false)\n\nCreate the topology of a so-called 1D bricklayer circuit on a subset of qubits indicated by qindices. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.bricklayertopology-Tuple{Integer}","page":"Circuits","title":"PauliPropagation.bricklayertopology","text":"bricklayertopology(nqubits::Integer; periodic=false)\n\nCreate the topology of a so-called 1D bricklayer circuit on nqubits qubits. It consists of two sublayers connecting odd-even and eve-odd qubit indices, respectively. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.rectangletopology-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.rectangletopology","text":"rectangletopology(nx::Integer, ny::Integer; periodic=false)\n\nCreate a 2D topology on a grid of nx by ny qubits. The order is none in particular and may need to be adapted for specific purposes. If periodic is set to true, the grid is connected periodically in both directions.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.staircasetopology-Tuple{Integer}","page":"Circuits","title":"PauliPropagation.staircasetopology","text":"staircasetopology(nqubits::Integer; periodic=false)\n\nCreate a 1D staircase topology on nqubits qubits. The qubits are connected in a staircase pattern, where qubit i is connected to qubit i+1. If periodic is set to true, the last qubit is connected to the first qubit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.staircasetopology2d-Tuple{Integer, Integer}","page":"Circuits","title":"PauliPropagation.staircasetopology2d","text":"staircasetopology2d(nx::Integer, ny::Integer)\n\nCreate a 2D staircase topology on a grid of nx by ny qubits. Mind the order of the topology, which forms a staircase spanning the grid -> in the Schrödinger picture <-.  An observable acting on qubits index nqubits may interact non-trivially with every gate on the topology.  Can topology can either be pathological or the most simple, depending on which index observables are non-identity.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#Utils","page":"Circuits","title":"Utils","text":"","category":"section"},{"location":"api/Circuits/#PauliPropagation.countparameters-Tuple{Any}","page":"Circuits","title":"PauliPropagation.countparameters","text":"countparameters(circuit)\n\nUtility function to count the number of gates of type ParametrizedGate in a circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Tuple{Any, Type{PauliRotation}, Vector{Symbol}, Vector{Int64}}","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, ::PauliRotation, gate_symbols::Vector{Symbol}), qinds::Vector{Int})\n\nUtility function to get the parameter indices of PauliRotation gates with symbol gate_symbols acting on the qubits qinds. For example, getparameterindices(circuit, PauliRotation, [:X], [1]).\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Tuple{Any, Type{PauliRotation}, Vector{Symbol}}","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, ::PauliRotation, gate_symbols::Vector{Symbol}))\n\nUtility function to get the parameter indices of PauliRotation gates with symbol gate_symbols. For example, getparameterindices(circuit, PauliRotation, [:X]).\n\n\n\n\n\n","category":"method"},{"location":"api/Circuits/#PauliPropagation.getparameterindices-Union{Tuple{GT}, Tuple{Any, Type{GT}}} where GT<:ParametrizedGate","page":"Circuits","title":"PauliPropagation.getparameterindices","text":"getparameterindices(circuit, GateType<:ParametrizedGate)\n\nUtility function to get the parameter indices of gates of type GateType in a circuit. This naturally only works for gates that subtype ParametrizedGate.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#Propagation","page":"Propagation","title":"Propagation","text":"","category":"section"},{"location":"api/Propagation/#Generics","page":"Propagation","title":"Generics","text":"","category":"section"},{"location":"api/Propagation/#PauliPropagation.apply-Union{Tuple{SG}, Tuple{SG, Any, Any, Any}} where SG<:StaticGate","page":"Propagation","title":"PauliPropagation.apply","text":"apply(gate::StaticGate, pstr, coeff, theta)\n\nCalling apply on a StaticGate will dispatch to a 3-argument apply function without the paramter theta. If a 4-argument apply function is defined for a concrete type, it will still dispatch to that one. See the 4-custom-gates.ipynb for examples of how to define custom gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applyandadd!-NTuple{5, Any}","page":"Propagation","title":"PauliPropagation.applyandadd!","text":"applyandadd!(gate, pstr, coefficient, theta, output_psum; kwargs...)\n\n3rd-level function below applymergetruncate! that applies one gate to one Pauli string in psum, moving results into output_psum by default. This function can be overwritten for a custom gate if the lower-level function apply is not sufficient.  This is likely the the case if apply is not type-stable because it does not return a unique number of outputs.  E.g., a Pauli gate returns 1 or 2 (pstr, coefficient) outputs. See the 4-custom-gates.ipynb for examples of how to define custom gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applymergetruncate!-NTuple{5, Any}","page":"Propagation","title":"PauliPropagation.applymergetruncate!","text":"applymergetruncate!(gate, psum, aux_psum, thetas, param_idx; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\n1st-level function below propagate! that applies one gate to all Pauli strings in psum, potentially using aux_psum in the process, and merges everything back into psum. Truncations are checked here after merging. This function can be overwritten for a custom gate if the lower-level functions applytoall!, applyandadd!, and apply are not sufficient.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-NTuple{4, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate, theta psum, output_psum; kwargs...)\n\n2nd-level function below applymergetruncate! that applies one gate to all Pauli strings in psum, moving results into output_psum by default. After this functions, Pauli strings in remaining in psum and output_psum are merged. This function can be overwritten for a custom gate if the lower-level functions applyandadd! and apply are not sufficient. In particular, this function can be used to manipulate both psum and output_psum at the same time to reduce memory movement. Note that manipulating psum on anything other than the current Pauli string will likely lead to errors. See the 4-custom-gates.ipynb for examples of how to define custom gates.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.propagate","page":"Propagation","title":"PauliPropagation.propagate","text":"propagate(circ, pstr::PauliString, thetas=nothing; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nPropagate a PauliString through the circuit circ in the Heisenberg picture.  This means that the circuit is applied to the Pauli string in reverse order, and the action of each gate is its conjugate action. Parameters for the parametrized gates in circ are given by thetas, and need to be passed as if the circuit was applied as written in the Schrödinger picture. If thetas are not passed, the circuit must contain only non-parametrized StaticGates. Default truncations are max_weight, min_abs_coeff, max_freq, and max_sins. max_freq, and max_sins will lead to automatic conversion if the coefficients are not already wrapped in suitable PathProperties objects. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#PauliPropagation.propagate-2","page":"Propagation","title":"PauliPropagation.propagate","text":"propagate(circ, psum::PauliSum, thetas=nothing; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nPropagate a PauliSum through the circuit circ in the Heisenberg picture.  This means that the circuit is applied to the Pauli sum in reverse order, and the action of each gate is its conjugate action. Parameters for the parametrized gates in circ are given by thetas, and need to be passed as if the circuit was applied as written in the Schrödinger picture. If thetas are not passed, the circuit must contain only non-parametrized StaticGates. Default truncations are max_weight, min_abs_coeff, max_freq, and max_sins. max_freq, and max_sins will lead to automatic conversion if the coefficients are not already wrapped in suitable PathProperties objects. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#PauliPropagation.propagate!","page":"Propagation","title":"PauliPropagation.propagate!","text":"propagate!(circ, psum::PauliSum, thetas=nothing; max_weight=Inf, min_abs_coeff=1e-10, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing, kwargs...)\n\nPropagate a Pauli sum  through the circuit circ in the Heisenberg picture.  This means that the circuit is applied to the Pauli sum in reverse order, and the action of each gate is its conjugate action. The input psum will be modified. Parameters for the parametrized gates in circ are given by thetas, and need to be passed as if the circuit was applied as written in the Schrödinger picture. If thetas are not passed, the circuit must contain only non-parametrized StaticGates. Default truncations are max_weight, min_abs_coeff, max_freq, and max_sins. max_freq, and max_sins can only be used with suitable PathProperties coefficients like PauliFreqTracker. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool. Further kwargs are passed to the lower-level functions applymergetruncate!, applytoall!, applyandadd!, and apply.\n\n\n\n\n\n","category":"function"},{"location":"api/Propagation/#Specializations","page":"Propagation","title":"Specializations","text":"","category":"section"},{"location":"api/Propagation/#PauliPropagation.apply-Tuple{CliffordGate, Integer, Any}","page":"Propagation","title":"PauliPropagation.apply","text":"apply(gate::CliffordGate, pstr::PauliStringType, coeff)\n\nApply a CliffordGate to an integer Pauli string and its coefficient. \n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.apply-Tuple{TransferMapGate, Any, Any}","page":"Propagation","title":"PauliPropagation.apply","text":"apply(gate::TransferMapGate, pstr, coeff)\n\nApply a TransferMapGate to an integer Pauli string and its coefficient. The outcomes are determined by the transfer_map of the gate.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applyandadd!-Tuple{CliffordGate, Vararg{Any, 4}}","page":"Propagation","title":"PauliPropagation.applyandadd!","text":"applyandadd!(gate::CliffordGate, pstr, coeff, theta, output_psum; kwargs...)\n\nOverload of applyandadd! for CliffordGate gates. Use set!() instead of add!() because Clifford gates create non-overlapping Pauli strings. applytoall! does not need to be adapted.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{AmplitudeDampingNoise, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::AmplitudeDampingNoise, theta, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for AmplitudeDampingNoise gates.  It fixes the type-instability of the apply() function and reduces moving Pauli strings between psum and auxpsum. psum and `auxpsum` are merged later.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{FrozenGate, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::FrozenGate, thetas, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for FrozenGates. Re-directs to applytoall! for the wrapped FrozenGate.gate with the frozen parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{PauliNoise, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::PauliNoise, p, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for PauliNoise gates with noise strength p.  It changes the coefficients in-place and does not require the aux_psum, which stays empty.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{PauliRotation, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::PauliRotation, theta, psum, aux_psum; kwargs...)\n\nOverload of applytoall! for PauliRotation gates.  It fixes the type-instability of the apply() function and reduces moving Pauli strings between psum and aux_psum. psum and aux_psum are merged later.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.applytoall!-Tuple{TGate, Any, Any, Any}","page":"Propagation","title":"PauliPropagation.applytoall!","text":"applytoall!(gate::TGate, thetas, psum, aux_psum; kwargs...)\n\nOverload of applytoall!() for TGate(qind). Redirects to a PauliRotation(:Z, qind) with angle π/4.\n\n\n\n\n\n","category":"method"},{"location":"api/Propagation/#PauliPropagation.getnewpaulistring-Tuple{MaskedPauliRotation, Integer}","page":"Propagation","title":"PauliPropagation.getnewpaulistring","text":"getnewpaulistring(gate::MaskedPauliRotation, pstr::PauliStringType)\n\nGet the new Pauli string after applying a MaskedPauliRotation to an integer Pauli string, as well as the corresponding ±1 coefficient.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliTransferMatrix/#Pauli-Transfer-Matrix","page":"Pauli Transfer Matrix","title":"Pauli Transfer Matrix","text":"","category":"section"},{"location":"api/PauliTransferMatrix/#Matrices","page":"Pauli Transfer Matrix","title":"Matrices","text":"","category":"section"},{"location":"api/PauliTransferMatrix/#PauliPropagation.calculateptm-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Number","page":"Pauli Transfer Matrix","title":"PauliPropagation.calculateptm","text":"function calculateptm(mat; tol=1e-15, heisenberg=true)\nfunction calculateptm(dtype, mat; tol=1e-15, heisenberg=true)\n\nCalculate the Pauli Transfer Matrix (PTM) of a matrix mat.  The PTM will be real-valued in the Pauli basis. However, it can be complex in a general basis. Pass an optional data type dtype when entries are not floats. We truncate small complex components and abs values in the PTM using the tol parameter. Note, by default the PTM is calculated in the -> Heisenberg picture <-,  i.e., the PTM is that of the conjugate transpose of the  matrix. This can be changed via the heisenberg::Bool keyword argument. Arguments\n\nmat::Matrix: The evolutioin gate matrix for which the PTM is calculated.\ntol::Float64=1e-15: The tolerance for dropping small values in the PTM.\nheisenberg::Bool=true: Whether the PTM is calculated in the Heisenberg picture. \ndtype::DataType: Default type for a real PTM is Float64.\n\nReturns\n\nptm::Matrix: The PTM of the conjugate transpose of matrix mat.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliTransferMatrix/#Transfer-maps","page":"Pauli Transfer Matrix","title":"Transfer maps","text":"","category":"section"},{"location":"api/PauliTransferMatrix/#PauliPropagation.totransfermap","page":"Pauli Transfer Matrix","title":"PauliPropagation.totransfermap","text":"totransfermap(nq::Integer, circuit::Vector{Gate}, thetas=nothing)\n\nComputes the Pauli transfer map acting on nq qubits from a circuit with parameters thetas. thetas defaults to nothing but is required if the circuit contains parametrized gates. The returned lookup map is a vector of vectors like [(pstr1, coeff1), (pstr2, coeff2), ...], where the pstr are partial Pauli strings on the affected qubits.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliTransferMatrix/#PauliPropagation.totransfermap-Tuple{AbstractMatrix}","page":"Pauli Transfer Matrix","title":"PauliPropagation.totransfermap","text":"totransfermap(ptm::Matrix)\n\nComputes the Pauli transfer map acting on nq qubits from a Pauli Transfer Matrix (PTM). The PTM should be the matrix representation of a gate in Pauli basis. The returned lookup map is a vector of vectors like [(pstr1, coeff1), (pstr2, coeff2), ...], where the pstr are partial Pauli strings on the affected qubits.\n\n\n\n\n\n","category":"method"},{"location":"api/NumericalCertificates/#Numerical-Certificates","page":"Numerical Certificates","title":"Numerical Certificates","text":"","category":"section"},{"location":"api/NumericalCertificates/#PauliPropagation.estimatemse","page":"Numerical Certificates","title":"PauliPropagation.estimatemse","text":"estimatemse(circ, pstr::PauliString, n_mcsamples::Integer, thetas=π; stateoverlapfunc=overlapwithzero, circuit_is_reversed=false, customtruncfunc=nothing)\n\nFunction to estimate the mean square error of a truncated circuit simulation using Monte Carlo sampling. Returns the mean squared error of the truncated Pauli propagation simulation averaged over the thetas∈ [theta, theta] of the angle theta of each PauliRotation. Currently, the function only supports circuits with PauliRotation and CliffordGate gates.\n\nThe length the thetas vector should be equal to the number of parametrized gates in the circuit.  Alternatively, thetas can be a single real number applicable for all parametrized gates. The default thetas=π or any other non-array values assume that the circuit consists only of PauliRotation -CliffordGate. For PauliRotation, the value should be the integration range of the parameters around zero.\n\nAn initial state overlap function stateoverlapfunc can be provided to calculate the overlap of the backpropagated Pauli strings with the initial state. Importantly, the kwargs can be used to set the truncation parameters of the Pauli propagation. Currently supported are max_weight, max_freq, and max_sins. Note that min_abs_coeff is not supported here, as we consider errors integrated over the angles. max_freq effectively truncates small coefficients below (1/2)^max_freq on average over thetas ∈ [-π, π]. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool.\n\n\n\n\n\n","category":"function"},{"location":"api/NumericalCertificates/#PauliPropagation.estimatemse!-Tuple{Any, PauliString, AbstractVector, Any, Any}","page":"Numerical Certificates","title":"PauliPropagation.estimatemse!","text":"estimatemse!(\ncirc, pstr::PauliString, error_array::AbstractVector, thetas, split_probabilities; \nstateoverlapfunc=overlapwithzero, circuit_is_reversed=false, max_weight=Inf, max_freq=Inf, max_sins=Inf, customtruncfunc=nothing\n)\n\nIn-place version of estimatemse. This function takes an array error_array of length n_mcsamples as an argument and modifies it in-place.  It further assumes that the thetas and split_probabilities are already correctly calculated and provided as arguments.  In general they will be vectors, but they can also be real numbers. A custom truncation function can be passed as customtruncfunc with the signature customtruncfunc(pstr::PauliStringType, coefficient)::Bool.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Pauli-Algebra","page":"Pauli Algebra","title":"Pauli Algebra","text":"","category":"section"},{"location":"api/PauliAlgebra/#Data-types","page":"Pauli Algebra","title":"Data types","text":"","category":"section"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliString","page":"Pauli Algebra","title":"PauliPropagation.PauliString","text":"PauliString(nqubits::Int, pauli::Symbol, qind::Integer, coeff=1.0)\nPauliString(nqubits::Int, paulis::Vector{Symbol}, qinds::Vector{Integer}, coeff=1.0)\n\nConstructor for a PauliString on nqubits qubits from a Symbol (:I, :X, :Y, :Z) or Vector{Symbol}. Provide the index or indices for those symbols as qind or qinds. The coefficient of the Pauli string in the Pauli sum defaults to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliString-2","page":"Pauli Algebra","title":"PauliPropagation.PauliString","text":"PauliString(nqubits::Int, term::TermType, coeff::CoeffType)\n\nPauliString is a struct that represents a Pauli string on nqubits qubits. Commonly term is an unsigned Integer.  See the other PauliString constructors for higher-level usage. \n\n\n\n\n\n","category":"type"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(nqubits::Int, terms::Dict)\n\nPauliSum is a struct that represents a sum of Pauli strings acting on nqubits qubits. It is a wrapper around a dictionary Dict(Pauli string => coefficient}, where the Pauli strings are typically unsigned Integers for efficiency reasons.\n\n\n\n\n\n","category":"type"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Tuple{Int64}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(nqubits::Integer)\n\nContructor for an empty PauliSum on nqubits qubits. Element type defaults for Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(pstr::PauliString)\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Tuple{Union{Tuple, Base.Generator, AbstractArray}}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(pstrs::Vector{PauliString})\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Union{Tuple{CT}, Tuple{TT}, Tuple{Integer, PauliString{TT, CT}}} where {TT, CT}","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(nq::Integer, pstr::PauliString)\n\nConstructor for a PauliSum on nqubits qubits from a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.PauliSum-Union{Tuple{CT}, Tuple{Type{CT}, Int64}} where CT","page":"Pauli Algebra","title":"PauliPropagation.PauliSum","text":"PauliSum(CoeffType, nq::Int)\n\nContructor for an empty PauliSum on nqubits qubits. The type of the coefficients can be provided.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:*-Tuple{PauliString, Number}","page":"Pauli Algebra","title":"Base.:*","text":"*(pstr::PauliString, c::Number)\n\nMultiply a PauliString by a scalar c. Returns a new PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:*-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"Base.:*","text":"*(pstr1::PauliString, pstr2::PauliString)\n\nPerform a Pauli product of two PauliStrings. \n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:*-Tuple{PauliSum, Number}","page":"Pauli Algebra","title":"Base.:*","text":"*(psum::PauliSum, c::Number)\n\nMultiply a PauliSum by a scalar c. This copies the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:*-Tuple{PauliSum, PauliString}","page":"Pauli Algebra","title":"Base.:*","text":"*(pstr::PauliString, psum::PauliSum)\n*(psum::PauliSum, pstr::PauliString)\n\nPerform a Pauli product of a PauliString with a PauliSum. Returns a PauliSum with complex coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:*-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"Base.:*","text":"*(psum1::PauliSum, psum2::PauliSum)\n\nPerform a Pauli product of two PauliSums. Returns a PauliSum with complex coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT2}, Tuple{TT1}, Tuple{PauliSum{TT1, CT1}, PauliSum{TT2, CT2}}} where {TT1, TT2, CT1, CT2}","page":"Pauli Algebra","title":"Base.:+","text":"+(psum1::PauliSum, psum2::PauliSum)\n\nAddition of two PauliSums. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT}, Tuple{PauliString{TT, CT1}, PauliString{TT, CT2}}} where {TT, CT1, CT2}","page":"Pauli Algebra","title":"Base.:+","text":"+(pstr1::PauliString, pstr2::PauliString)\n\nAddition of two PauliStrings. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT}, Tuple{PauliSum{TT, CT1}, PauliString{TT, CT2}}} where {TT, CT1, CT2}","page":"Pauli Algebra","title":"Base.:+","text":"+(pstr::PauliString, psum::PauliSum)\n+(psum::PauliSum, pstr::PauliString)\n\nAddition of a PauliString to a PauliSum. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:+-Union{Tuple{CT}, Tuple{TT}, Tuple{PauliSum{TT, CT}, Number}} where {TT, CT}","page":"Pauli Algebra","title":"Base.:+","text":"+(psum::PauliSum, c::Number)\n+(c::Number, psum::PauliSum)\n\nAddition of c * Identity to a PauliSum. This copies the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:--Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"Base.:-","text":"-(pstr1::PauliString, pstr2::PauliString)\n\nSubtract two PauliStrings. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:--Tuple{PauliSum, PauliString}","page":"Pauli Algebra","title":"Base.:-","text":"-(pstr::PauliString, psum::PauliSum)\n-(psum::PauliSum, pstr::PauliString)\n\nSubtract a PauliString from a PauliSum or vice versa. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:--Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"Base.:-","text":"-(psum1::PauliSum, psum2::PauliSum)\n\nSubtract two PauliSums. Returns a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:/-Tuple{PauliString, Number}","page":"Pauli Algebra","title":"Base.:/","text":"/(pstr::PauliString, c::Number)\n\nDivide a PauliString by a scalar c. Returns a new PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:/-Tuple{PauliSum, Number}","page":"Pauli Algebra","title":"Base.:/","text":"/(psum::PauliSum, c::Number)\n\nDivide a PauliSum by a scalar c. This copies the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:==-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"Base.:==","text":"==(psum1::PauliSum, psum2::PauliSum)\n\nEquality check for PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.:≈-Union{Tuple{CT2}, Tuple{TT2}, Tuple{CT1}, Tuple{TT1}, Tuple{PauliSum{TT1, CT1}, PauliSum{TT2, CT2}}} where {TT1, CT1, TT2, CT2}","page":"Pauli Algebra","title":"Base.:≈","text":"≈(psum1::PauliSum, psum2::PauliSum)\n\nApproximate equality check for PauliSum. Simply calls isapprox() on the coefficients of the contained Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.copy-Tuple{PauliSum}","page":"Pauli Algebra","title":"Base.copy","text":"Copy a PauliSum by copying its terms field.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.empty!-Tuple{PauliSum}","page":"Pauli Algebra","title":"Base.empty!","text":"empty!(psum::PauliSum)\n\nEmpty the PauliSum by emptying the dictionary on the terms fields. \n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.iterate","page":"Pauli Algebra","title":"Base.iterate","text":"Iterator for PauliSum returns an iterator over (pstr, coeff) pairs`.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliAlgebra/#Base.length-Tuple{PauliSum}","page":"Pauli Algebra","title":"Base.length","text":"length(psum::PauliSum)\n\nNumber of terms in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.similar-Tuple{PauliSum}","page":"Pauli Algebra","title":"Base.similar","text":"similar(psum::PauliSum)\n\nCreate a new PauliSum with the same number of qubits and coefficient type as psum. Calls sizehint!() with length(psum) on the dictionary of the new PauliSum. \n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Base.sizehint!-Tuple{PauliSum, Any}","page":"Pauli Algebra","title":"Base.sizehint!","text":"sizehint!(psum::PauliSum, n)\n\nHint to the PauliSum to reserve space for n terms.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation._checknumberofqubits-Tuple{Union{Tuple, Base.Generator, AbstractArray}}","page":"Pauli Algebra","title":"PauliPropagation._checknumberofqubits","text":"Checks whether the number of qubits nqubits is the same between in some collection.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.add!","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum::PauliSum, pauli::Symbol, qind::Integer, coeff=1.0)\nadd!(psum::PauliSum, paulis::Vector{Symbol}, qinds::Vector{Integer}, coeff=1.0)\n\nAdd a Pauli string to a PauliSum psum. Changes psum in-place. Provide the Pauli string as a Symbol (:I, :X, :Y, :Z) or Vector{Symbol}. Provide the index or indices for those symbols as qind or qinds. The coefficient of the Pauli string in the Pauli sum defaults to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliAlgebra/#PauliPropagation.add!-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT2}, Tuple{TT1}, Tuple{PauliSum{TT1, CT1}, PauliString{TT2, CT2}}} where {TT1, TT2, CT1, CT2}","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum::PauliSum, pstr::PauliString)\n\nAdd a PauliString pstr to a PauliSum psum. Changes psum in-place. psum and pstr need to be defined on the same number of qubits and have the same coefficient type.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.add!-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT2}, Tuple{TT1}, Tuple{PauliSum{TT1, CT1}, PauliSum{TT2, CT2}}} where {TT1, TT2, CT1, CT2}","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum1::PauliSum, psum2::PauliSum)\n\nAdd two PauliSums psum1 and psum2. Changes psum1 in-place. psum1 and psum2 need to be defined on the same number of qubits and have the same coefficient type.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.add!-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT}, Tuple{PauliSum{TT, CT1}, TT, CT2}} where {TT, CT1, CT2}","page":"Pauli Algebra","title":"PauliPropagation.add!","text":"add!(psum::PauliSum{Integer, CoeffType}, pstr::Integer, coeff::CoeffType)\n\nAdd a Pauli string pstr with coefficient coeff to a PauliSum psum. This changes psum in-place. pstr needs to have the same type as paulitype(psum), and coeff needs to have the same type as coefftype(psum).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.coefficients-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.coefficients","text":"coefficients(psum::PauliSum)\n\nReturns an iterator over the coefficients of a PauliSum. Call topaulistrings to receive entries as PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.coefftype-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.coefftype","text":"coefftype(pstr::PauliString)\n\nGet the coefficient type of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.coefftype-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.coefftype","text":"coefftype(psum::PauliSum)\n\nGet the coefficient type of a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Tuple{PauliSum, Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pstr::Vector{Symbol}, qinds::Vector{Int})\n\nGet the coefficient of a Pauli string in a PauliSum by providing the Pauli string pstr as a vector of Symbols acting on qubits qinds.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Tuple{PauliSum, Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pauli::Symbol, qind::Integer)\n\nGet the coefficient of a Pauli string in a PauliSum by providing the Pauli string as a Symbol acting on qubit qind.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Tuple{PauliSum, Vector{Symbol}}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pstr::Vector{Symbol})\n\nGet the coefficient of a Pauli string in a PauliSum by providing the Pauli string pstr as a vector of Symbols acting on all qubits.  This is consistent with how Pauli strings can be added to a PauliSum via add!().  Defaults to 0 if the Pauli string is not in the PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT2}, Tuple{TT1}, Tuple{PauliSum{TT1, CT1}, PauliString{TT2, CT2}}} where {TT1, TT2, CT1, CT2}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pstr::PauliString)\n\nGet the coefficient of a PauliString in a PauliSum. Defaults to 0 if the Pauli string is not in the PauliSum. Requires that the integer Pauli string in pstr is the same type as the integer Pauli strings in psum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getcoeff-Union{Tuple{CT}, Tuple{TT2}, Tuple{TT1}, Tuple{PauliSum{TT1, CT}, TT2}} where {TT1, TT2, CT}","page":"Pauli Algebra","title":"PauliPropagation.getcoeff","text":"getcoeff(psum::PauliSum, pstr::Integer)\n\nGet the coefficient of an integer Pauli string in a PauliSum. Defaults to 0 if the Pauli string is not in the PauliSum. Requires that the integer Pauli string pstr is the same type as the integer Pauli strings in psum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.mult!-Tuple{PauliSum, Number}","page":"Pauli Algebra","title":"PauliPropagation.mult!","text":"mult!(psum::PauliSum, c::Number)\n\nMultiply a PauliSum by a scalar c in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.norm","page":"Pauli Algebra","title":"PauliPropagation.norm","text":"norm(psum::PauliSum, L=2)\n\nCalculate the norm of a PauliSum with respect to the L-norm.  Calls LinearAlgebra.norm on the coefficients of the PauliSum.\n\n\n\n\n\n","category":"function"},{"location":"api/PauliAlgebra/#PauliPropagation.numcoefftype-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.numcoefftype","text":"numcoefftype(pstr::PauliString)\n\nGet the type of the numerical coefficient of a PauliString.  Will return the type of the output of  tonumber(pstr.coeff).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.numcoefftype-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.numcoefftype","text":"numcoefftype(psum::PauliSum)\n\nGet the type of the numerical coefficient of a PauliSum by calling numcoefftype() on the coefficients. If the PauliSum is empty, an error is thrown because the type cannot be inferred.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.paulis-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.paulis","text":"paulis(psum::PauliSum)\n\nReturns an iterator over the integer pauli strings of a PauliSum. Call topaulistrings to receive entries as PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.paulitype-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.paulitype","text":"paulitype(pstr::PauliString)\n\nGet the Pauli integer type of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.paulitype-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.paulitype","text":"paulitype(psum::PauliSum)\n\nGet the Pauli integer type of a PauliSum.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.set!-Union{Tuple{CT2}, Tuple{CT1}, Tuple{TT}, Tuple{PauliSum{TT, CT1}, TT, CT2}} where {TT, CT1, CT2}","page":"Pauli Algebra","title":"PauliPropagation.set!","text":"set!(psum::PauliSum{TermType, CoeffType}, pstr::TermType, coeff::CoeffType)\n\nIn-place setting the coefficient of a Pauli string in a PauliSum dictionary. The type of the Pauli string needs to be the keytype=TermType of the dictionary, and the coefficient coeff needs to be the valuetype=CoeffType.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.tonumber-Tuple{Number}","page":"Pauli Algebra","title":"PauliPropagation.tonumber","text":"tonumber(val::Number)\n\nTrivial function returning a numerical value of a number. Will be overloaded for custom wrapper types like PathProperties.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.topaulistrings-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.topaulistrings","text":"topaulistrings(psum::PauliSum)\n\nReturns the Pauli strings in a PauliSum and their coefficients as a list of PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Pauli-operations","page":"Pauli Algebra","title":"Pauli operations","text":"","category":"section"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(pstr1::Integer, pstr2::Integer)\n\nCalculate the commutator of two integer Pauli strings. Returns a tuple of the coefficient and the potentially integer Pauli string. The coefficient is zero if the Pauli strings commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(pstr1::PauliString, pstr2::PauliString)\n\nCalculate the commutator of two PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliSum, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(psum::PauliSum, pstr::PauliString)\ncommutator(pstr::PauliString, psum::PauliSum)\n\nCalculate the commutator of a PauliSum and a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutator-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.commutator","text":"commutator(psum1::PauliSum, psum2::PauliSum)\n\nCalculate the commutator of two PauliSums.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(pstr1::Integer, pstr2::Integer)\n\nCheck if two integer Pauli strings commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(pstr1::PauliString, pstr2::PauliString)\n\nCheck if two Pauli strings of type PauliString commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.commutes-Tuple{PauliSum, PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.commutes","text":"commutes(psum1::PauliSum, psum2::PauliSum)\n\nCheck if two Pauli sums of type PauliSum commute.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsXorY-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.containsXorY","text":"containsXorY(pstr::Integer)\n\nCheck if an integer Pauli string contains an X or Y Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsXorY-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.containsXorY","text":"containsXorY(pstr::PauliString)\n\nCheck if a Pauli string contains an X or Y Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsYorZ-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.containsYorZ","text":"containsYorZ(pstr::Integer)\n\nCheck if an integer Pauli string contains a Y or Z Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.containsYorZ-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.containsYorZ","text":"containsXorY(pstr::PauliString)\n\nCheck if a Pauli string contains a Y or Z Pauli.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(pstr::Integer)\n\nFunction to count the weight of an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(pstr::PauliString)\n\nFunction to count the weight of a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countweight-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countweight","text":"countweight(psum::PauliSum)\n\nFunction to count the weight Pauli strings in a PauliSum. Returns an array of weights.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(pstr::Integer)\n\nFunction to count the number of X and Y Paulis in an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(pstr::PauliString)\n\nFunction to count the number of X and Y Paulis in a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countxy-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countxy","text":"countxy(psum::PauliSum)\n\nFunction to count the number of X and Y Paulis in a PauliSum. Returns an array of counts.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(pstr::Integer)\n\nFunction to count the number of Y and Z Paulis in an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{PauliString}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(pstr::PauliString)\n\nFunction to count the number of Y and Z Paulis in a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.countyz-Tuple{PauliSum}","page":"Pauli Algebra","title":"PauliPropagation.countyz","text":"countyz(psum::PauliSum)\n\nFunction to count the number of Y and Z Paulis in a PauliSum. Returns an array of counts.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{Integer, Integer, Any}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pstr1::Integer, pstr1::Integer, changed_indices::Vector{Integer})\n\nCalculate the product of two integer Paulis.  Indicate via changed_indices which qubit sites to check for calculating the sign. It can be any iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pstr1::Integer, pstr2::Integer)\n\nCalculate the product of two integer Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.pauliprod-Tuple{PauliString, PauliString}","page":"Pauli Algebra","title":"PauliPropagation.pauliprod","text":"pauliprod(pstr1::PauliString, pstr2::PauliString)\n\nCalculate the product of two PauliStrings. For example X*Y = iZ.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Bit-operations","page":"Pauli Algebra","title":"Bit operations","text":"","category":"section"},{"location":"api/PauliAlgebra/#PauliPropagation._paulishiftright-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation._paulishiftright","text":"_paulishiftright(pstr::PauliStringType)\n\nShift to the right and truncate the first encoded Pauli string. Just a utility function.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getinttype-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.getinttype","text":"getinttype(nqubits::Integer)\n\nFunction to return the smallest integer type that can hold nqubits for memory and speed.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#Utils","page":"Pauli Algebra","title":"Utils","text":"","category":"section"},{"location":"api/PauliAlgebra/#PauliPropagation._getprettystr-Tuple{Dict, Int64}","page":"Pauli Algebra","title":"PauliPropagation._getprettystr","text":"Pretty string function.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getpauli-Tuple{Integer, Any}","page":"Pauli Algebra","title":"PauliPropagation.getpauli","text":"getpauli(pstr::PauliStringType, qinds::Vector{Integer})\n\nGets the Paulis on indices qinds of a pstr in the integer representation.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.getpauli-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.getpauli","text":"getpauli(pstr::PauliStringType, index::Integer)\n\nGets the Pauli on index index of an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.identitylike-Tuple{TT} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.identitylike","text":"identitylike(pstr::PauliStringType)\n\nReturns an integer Pauli string of the same type as pstr with all Paulis set to identity.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.identitypauli-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.identitypauli","text":"identitypauli(nqubits::Integer)\n\nReturns the integer representation of the identity Pauli string acting on nqubits qubits. The type of will be the smallest integer type that can hold the number of qubits, as given by getinttype(nqubits).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.identitypauli-Union{Tuple{Type{TT}}, Tuple{TT}} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.identitypauli","text":"identitypauli(::PauliStringType)\n\nReturns the integer representation of the identity Pauli string with type PauliStringType.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttostring-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttostring","text":"inttostring(pstr::PauliType, nqubits::Integer)\n\nReturns a string representation of an integer Pauli string pstr on nqubits qubits.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttosymbol-Tuple{Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttosymbol","text":"inttosymbol(pstr::PauliStringType, nqubits::Integer)\n\nMaps an integer Pauli string to a vector of symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.inttosymbol-Tuple{Integer}","page":"Pauli Algebra","title":"PauliPropagation.inttosymbol","text":"inttosymbol(pauli::PauliType)\n\nMaps an integer Pauli to its corresponding symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.ispauli-Tuple{Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.ispauli","text":"ispauli(pauli1::Union{Symbol, PauliType}, pauli2::Union{Symbol, PauliType})\n\nispauli(pauli1::Union{Vector{Symbol}, PauliStringType}, pauli2::Union{Vector{Symbol}, PauliStringType})\n\nCheck if two Paulis are equal, where one is given as a symbol and the other as an integer.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(\n    pstr::PauliStringType, \n    target_paulis::Vector{Symbol}, \n    qinds::Vector{Integer}\n)\n\nSet the Paulis qinds of an integer Pauli string pstr to target_paulis. target_paulis is a vector of symbols. Use tuples in performance critical functions because they are immutable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Integer, Any}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(\n    pstr::PauliStringType, \n    target_paulis::PauliStringType, \n    qinds::Vector{Integer}\n)\n\nSet the Paulis qinds of an integer Pauli string pstr to target_paulis. Use Tuples for qinds in performance critical functions because they are immutable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Integer, Integer}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(pstr::PauliStringType, target_pauli::PauliType, index::Integer)\n\nSets the Pauli on index index of an integer Pauli string to target_pauli.  That Pauli should be provided as integer (0, 1, 2, 3).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.setpauli-Tuple{Integer, Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.setpauli","text":"setpauli(pstr::PauliStringType, target_pauli::Symbol, index::Integer)\n\nSets the Pauli on index of an integer Pauli string to target_pauli.  That Pauli should be provided as a symbol (:I, :X, :Y, :Z).\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Any}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(pstr::Union{Vector{Symbol}, Symbol})\n\nMaps a symbol or a vector of symbols pstr to an integer Pauli string.\n\nExample\n\nsymboltoint([:X, :I])\n\n# output\n\n0x01\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Integer, Any, Any}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(nqubits::Integer, paulis::Vector{Symbol}, qinds::Vector{Int})\n\nMaps a vector of symbols pstr acting on the indices qinds to an integer Pauli string. Other sites are set to the identity. qinds can be any iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Integer, Symbol, Integer}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(nqubits::Integer, pauli::Symbol, qind::Integer)\n\nMaps a single symbol pauli acting on the index qind to an integer Pauli string. Other sites are set to the identity.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Tuple{Symbol}","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(pauli::Symbol)\n\nMaps a single symbol to its corresponding integer representation.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Union{Tuple{TT}, Tuple{Type{TT}, Any, Any}} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(::PauliStringType, paulis, qinds)\n\nMaps a vector of symbols paulis acting on the indices qinds to an integer Pauli string with type PauliStringType. Other sites are set to the identity. qinds can be any iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/PauliAlgebra/#PauliPropagation.symboltoint-Union{Tuple{TT}, Tuple{Type{TT}, Symbol, Integer}} where TT<:Integer","page":"Pauli Algebra","title":"PauliPropagation.symboltoint","text":"symboltoint(::PauliStringType, pauli::Symbol, qind::Integer)\n\nMaps a single symbol pauli acting on the index qind to an integer Pauli string with type PauliStringType. Other sites are set to the identity.\n\n\n\n\n\n","category":"method"},{"location":"#PauliPropagation.jl","page":"Home","title":"PauliPropagation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PauliPropagation.jl is a Julia package for Pauli propagation simulation of quantum circuits and quantum systems. It focuses on simulating the evolution of observables expressed in the Pauli basis, under e.g. the dynamics of quantum circuits.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unlike traditional simulation approaches that evolve quantum states (Schrödinger picture), Pauli propagation often works in the Heisenberg picture, evolving observables like mathcalE^dagger(hatO) rather than states mathcalE(rho). This can be particularly efficient when the observables remain sparse or structured under evolution, and is useful for studying operator dynamics, estimating expectation values, and computing correlation functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pauli propagation sits alongside other classical simulation techniques, such as stabilizer simulation and tensor networks, but offers a distinct approach that can handle different regimes of quantum complexity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implemented in Julia, PauliPropagation.jl combines high-performance computation (using features such as multiple dispatch) with an accessible and high-level interface.  ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Note the current package requires Julia 1.10+.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The PauliPropagation.jl package is registered and can be installed into your environment in the following way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"PauliPropagation\")","category":"page"},{"location":"#Install-from-GitHub","page":"Home","title":"Install from GitHub","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you want to install the latest code, you can install the package directly from the Github link. For example, if you are working with a Jupyter notebook, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/MSRudolph/PauliPropagation.jl.git\", rev=\"branchname\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"where you can use the keyword rev=\"branchname\" to install development versions of the package. We don't recommend using branches other than main or dev.","category":"page"},{"location":"#Clone-repository-and-install-locally","page":"Home","title":"Clone repository and install locally","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Navigate to a local directory where you want to clone this repository into and run the following in a terminal","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone git@github.com:MSRudolph/PauliPropagation.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inside this cloned repository you can now freely import PauliPropagation or install it into your environment.\nAlternatively, you can push the relative path to the cloned repository to the Julia package load path called LOAD_PATH via","category":"page"},{"location":"","page":"Home","title":"Home","text":"rel_path = \"your/relative/path/PauliPropagation\"\npush!(LOAD_PATH,rel_path);","category":"page"},{"location":"","page":"Home","title":"Home","text":"This may require that you have no global installation of PauliPropagation in your enviroment.","category":"page"},{"location":"#A-note-on-julia-installation","page":"Home","title":"A note on julia installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is recommended to install julia using juliaup","category":"page"},{"location":"","page":"Home","title":"Home","text":"juliaup add 1.10","category":"page"},{"location":"","page":"Home","title":"Home","text":"Go to the project directory (e.g. PauliPropagation.jl). To start julia for a local environment","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=./","category":"page"},{"location":"","page":"Home","title":"Home","text":"More details can be found on this useful guide.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can find detailed example notebooks in the examples folder. We provide a brief example of how to use PauliPropagation.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider simulating the dynamics of an operator O=Z_16 under the evolution of a unitary  channel mathcalE(cdot) = U^dagger cdot U in a n=32 qubits system. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PauliPropagation\n\nnqubits = 32\n\nobservable = PauliString(nqubits, :Z, 16) # I...IZI...I","category":"page"},{"location":"","page":"Home","title":"Home","text":"Our goal is to compute","category":"page"},{"location":"","page":"Home","title":"Home","text":"textTrU^dagger O U rho","category":"page"},{"location":"","page":"Home","title":"Home","text":"A simple unitary U is the brickwork circuit, composed of two qubit gates alternating neighbouring sites. We define the circuit connectivity by ","category":"page"},{"location":"","page":"Home","title":"Home","text":"topology = bricklayertopology(nqubits; periodic=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where periodic specifies the boundary condition of the gates. The library has built-in circuits with e.g. a circuit containing alternating RX and RZZ Pauli gates on the topology. This can be defined by Trotterization of a transverse field Ising Hamiltonian with l steps","category":"page"},{"location":"","page":"Home","title":"Home","text":"U = prod_a=1^l prod_j=1^n e^-i dt   X_j e^-i dt Z_j Z_j+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"nlayers = 32 # l as above\n\ncircuit = tfitrottercircuit(nqubits, nlayers; topology=topology)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In our simulations, we can choose the circuit parameter dt","category":"page"},{"location":"","page":"Home","title":"Home","text":"dt = 0.1 # time step\n\nparameters = ones(countparameters(circuit)) * dt # all parameters","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can now compute the evolution using the propagate function. During the propagation, we employ truncation strategies such as coefficient or weight truncations, these options can be specified as keywords. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"## the truncations\nmax_weight = 6 # maximum Pauli weight\n\nmin_abs_coeff = 1e-4 # minimal coefficient magnitude\n\n## propagate through the circuit\npauli_sum = propagate(circuit, observable, parameters;\nmax_weight=max_weight, min_abs_coeff=min_abs_coeff)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output pauli_sum gives us an approximation of propagated Paulis ","category":"page"},{"location":"","page":"Home","title":"Home","text":"U^dagger O U approx sum_alpha c_alpha P_alpha","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally we can compute expectation values with an initial state such as rho = (0 rangle  langle 0 )^otimes n","category":"page"},{"location":"","page":"Home","title":"Home","text":"## overlap with the initial state\noverlapwithzero(pauli_sum)\n# yields 0.154596728241...","category":"page"},{"location":"","page":"Home","title":"Home","text":"This computation is efficient because the initial state can be written in terms of only mathbbI and Z strings","category":"page"},{"location":"","page":"Home","title":"Home","text":"rho = (fracmathbbI + Z2)^otimes n","category":"page"},{"location":"","page":"Home","title":"Home","text":"Therefore, the trace is equivalent to sum over coefficients of such Pauli strings ","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathrmTrU^dagger O U rho approx sum_alpha in mathbbI Z textstrings c_alpha","category":"page"},{"location":"#Important-Notes-and-Caveats","page":"Home","title":"Important Notes and Caveats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All of the following points can be addressed by you writing the necessary missing code due to the nice extensibility of Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The default is the Heisenberg backpropagation. Schrödinger propagation may soon be natively supported. At this moment, there are options to transpose PauliRotation gates by multiplying their angles with -1 and CliffordGates by using transposecliffordmap().\nWe currently do not support the strong simulation of quantum states in non-exponential time (even for Stabilizer states). Pauli propagation could in principle be used as a backend for extended stabilizer simulation.\nSampling quantum states is currently not supported.\nMany underlying data structures and functions can be used for other purposes involving Pauli operators.","category":"page"},{"location":"#Upcoming-Features","page":"Home","title":"Upcoming Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is still work-in-progress. You will probably find certain features that you would like to have and that are currently missing.\nHere are some features that we want to implement in the future. Feel free to contribute!","category":"page"},{"location":"","page":"Home","title":"Home","text":"A documentation website!\nEasier Schrödinger picture propagation. Currently, the default is Heisenberg and there is no easy way to transpose the gates.\nA fast and flexible Surrogate version. Currently, we provide a version of the Pauli propagation Surrogate that is good and works, at least for Pauli gates and Clifford gates. Stay tuned for a whole lot more.","category":"page"},{"location":"#How-to-contribute","page":"Home","title":"How to contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have a Slack channel #pauli-propagation in the Julia Slack.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If something bothers you or you want to propose an enhancement, please open an Issue describing everything in detail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a concrete change of code, please fork this GitHub repository and submit a Pull Request.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Otherwise, feel free to reach out to the developers!","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main developer of this package is Manuel S. Rudolph in the Quantum Information and Computation Laboratory of Prof. Zoë Holmes at EPFL, Switzerland. Contact Manuel via manuel.rudolph@epfl.ch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is the derivative of ongoing collaborations with Armando Angrisani and Tyson Jones at EPFL, supervised by Prof. Zoë Holmes at EPFL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Further contributors to this package include Yanting Teng and Su Yeon Chang.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more specific code issues, bug fixes, etc. please open a GitHub issue.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are publishing research using PauliPropagation.jl, please cite this library and our upcoming paper presenting it (coming soon(ish)).","category":"page"},{"location":"#Related-publications","page":"Home","title":"Related publications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some of the developers of this package are co-authors in the following papers using Pauli propagation and (at least parts of) this code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Classical simulations of noisy variational quantum circuits\nClassical surrogate simulation of quantum systems with LOWESA\nQuantum Convolutional Neural Networks are (Effectively) Classically Simulable\nClassically estimating observables of noiseless quantum circuits\nEfficient quantum-enhanced classical simulation for patches of quantum landscapes\nSimulating quantum circuits with arbitrary local noise using Pauli Propagation","category":"page"},{"location":"","page":"Home","title":"Home","text":"And more are coming up.","category":"page"},{"location":"api/Gates/#Gates","page":"Gates","title":"Gates","text":"","category":"section"},{"location":"api/Gates/#Clifford-Gates","page":"Gates","title":"Clifford Gates","text":"","category":"section"},{"location":"api/Gates/#PauliPropagation.CliffordGate-Tuple{Symbol, Any}","page":"Gates","title":"PauliPropagation.CliffordGate","text":"CliffordGate(symbol::Symbol, qinds::Vector{Int})\nCliffordGate(symbol::Symbol, qinds::Int)\n\nA Clifford gate with the name symbol acting on the qubits qinds. symbol needs to match any of the implemented Clifford gates in the global clifford_map. qinds can be a single integer, a vector of integers, or anything that transforms into a vector via vec(collect(qinds)).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.composecliffordmaps-Tuple{Any}","page":"Gates","title":"PauliPropagation.composecliffordmaps","text":"composecliffordmaps(circuit::Vector{CliffordGate})\n\nCompose a circuit of Clifford gates into a single Clifford map. The length of the map is 4^nq where nq is the maximum qubit index in the circuit. The resulting clifford map can be added to the global clifford_map with a custom Clifford gate name. The maximum number of qubits is 4 due to current restrictions of UInt8. Even if all gates only act on one qubit, that qubit index will determine the dimensionality of the map.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.createcliffordmap-Tuple{Dict}","page":"Gates","title":"PauliPropagation.createcliffordmap","text":"createcliffordmap(gate_relations::Dict)\n\nCreate a Clifford gate map from a dictionary of gate relations which can then be pushed to the global clifford_map. gate_relations is a dictionary with pairs like (:X, :X) => (:Z, :X, -1), describing the action of the Clifford gate on symbols (including the sign change).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.reset_clifford_map!-Tuple{}","page":"Gates","title":"PauliPropagation.reset_clifford_map!","text":"reset_clifford_map!()\n\nReset global clifford_map to the CLifford gate implemented by default.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.transposecliffordmap-Tuple{Vector{Tuple{UInt8, Int64}}}","page":"Gates","title":"PauliPropagation.transposecliffordmap","text":"transposecliffordmap(map_array::Vector{Tuple{UInt8,Int}})\n\nTranspose the Clifford gate maparray so that the output map is the inverse of the input map. For example, transposecliffordmap(clifford_map[:H]) returns the map for the inverse of the Hadamard gate, which is the same map.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.clifford_map","page":"Gates","title":"PauliPropagation.clifford_map","text":"clifford_map\n\nGlobal dictionary of Clifford gates and their action on Pauli strings. Currently supported Clifford gates are :H, :X, :Y, :Z, :SX, :SY, :S (:SZ) , :CNOT, :CZ, :ZZpihalf, and :SWAP. If one indexes into the returned arrays with the integer that corresponds to the partial Pauli string, the returned tuple is (sign, partial_pstr) where sign is the sign change and partial_pstr is the new partial Pauli string.\n\n\n\n\n\n","category":"constant"},{"location":"api/Gates/#Pauli-Rotations","page":"Gates","title":"Pauli Rotations","text":"","category":"section"},{"location":"api/Gates/#PauliPropagation.PauliRotation-Tuple{Any, Any, Any}","page":"Gates","title":"PauliPropagation.PauliRotation","text":"PauliRotation(symbols, qinds, theta)\n\nConstructor for a frozen PauliRotation generated by the Pauli string symbols acting on the qubits qinds, and with fixed parameter theta.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliRotation-Tuple{Any, Any}","page":"Gates","title":"PauliPropagation.PauliRotation","text":"PauliRotation(symbols::Vector{Symbol}, qinds::Vector{Int})\nPauliRotation(symbol::Symbol, qinds::Int)\n\nA parametrized Pauli rotation generated by the Pauli string symbols acting on the qubits qinds. For example PauliRotation(:X, 2)  or PauliRotation([:X, :Y], [1, 2]).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.commutes-Tuple{PauliRotation, Integer}","page":"Gates","title":"PauliPropagation.commutes","text":"commutes(gate::PauliRotation, pstr::Integer)\n\nCheck if a PauliRotation commutes with an integer Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.commutes-Tuple{PauliRotation, PauliString}","page":"Gates","title":"PauliPropagation.commutes","text":"commutes(gate::PauliRotation, pstr::PauliString)\n\nCheck if a PauliRotation commutes with a PauliString.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.tomatrix-Tuple{PauliRotation, Any}","page":"Gates","title":"PauliPropagation.tomatrix","text":"tomatrix(gate::PauliRotation, theta)\n\nCompute the unitary matrix for the PauliRotation gate with parameter theta in the computational 0/1 basis. This is done by computing the matrix U = cos(θ/2) I - i sin(θ/2) P where P is the Pauli matrix corresponding to the symbols. The returned unitary is returned in Schrödinger picture form. \n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#Noise","page":"Gates","title":"Noise","text":"","category":"section"},{"location":"api/Gates/#PauliPropagation.AmplitudeDampingNoise","page":"Gates","title":"PauliPropagation.AmplitudeDampingNoise","text":"AmplitudeDampingNoise(qind::Int)\nAmplitudeDampingNoise(qind::Int, gamma::Real)\n\nAn amplitude damping noise channel acting on the qubit at index qind. If gamma is provided, this returns a frozen gate with that noise strength. Damps X and Y Paulis by a factor of sqrt(1-gamma) and splits Z into and gamma * I and (1-gamma) * Z component (in the transposed Heisenberg picture).\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.DephasingNoise","page":"Gates","title":"PauliPropagation.DephasingNoise","text":"DephasingNoise(qind::Int)\nDephasingNoise(qind::Int, p::Real)\n\nThis is an alias for PauliZNoise. If p is provided, this returns a frozen gate with that noise strength. A dephasing noise channel acting on the qubit at index qind. Will damp X and Y Paulis equally by a factor of 1-p.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.DepolarizingNoise-Tuple{Int64, Real}","page":"Gates","title":"PauliPropagation.DepolarizingNoise","text":"DepolarizingNoise(qind::Int, p::Real)\n\nA frozen depolarizing noise channel acting on the qubit at index qind with noise strength p. Will damp X, Y, and Z Paulis equally by a factor of 1-p.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.DepolarizingNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.DepolarizingNoise","text":"DepolarizingNoise(qind::Int)\n\nA depolarizing noise channel acting on the qubit at index qind. Will damp X, Y, and Z Paulis equally by a factor of 1-p.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.ParametrizedNoiseChannel","page":"Gates","title":"PauliPropagation.ParametrizedNoiseChannel","text":"Abstract type for parametrized noise channels\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliNoise","page":"Gates","title":"PauliPropagation.PauliNoise","text":"Abstract type for Pauli noise, i.e., noise that is diagonal in Pauli basis\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.PauliXDamping-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliXDamping","text":"PauliXDamping(qind::Int)\nPauliXDamping(qind::Int, p::Real)\n\nA Pauli-X noise damping acting on the qubit at index qind. If p is provided, this returns a frozen gate with that damping strength. Will damp X Paulis by a factor of 1-p.  This alone is not a valid quantum channel.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliXNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliXNoise","text":"PauliXNoise(qind::Int)\nPauliXNoise(qind::Int, p::Real)\n\nA Pauli-X noise channel acting on the qubit at index qind. If p is provided, this returns a frozen gate with that noise strength. Will damp Y and Z Paulis equally by a factor of 1-p. This corresponds to inserting a Pauli X operator into the circuit with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliYDamping-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliYDamping","text":"PauliYDamping(qind::Int)\n\nA Pauli-Y noise damping acting on the qubit at index qind. If p is provided, this returns a frozen gate with that damping strength. Will damp Y Paulis by a factor of 1-p.  This alone is not a valid quantum channel.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliYNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliYNoise","text":"PauliYNoise(qind::Int)\nPauliYNoise(qind::Int, p::Real)\n\nA Pauli-Y noise channel acting on the qubit at index qind. If p is provided, this returns a frozen gate with that noise strength. Will damp X and Z Paulis equally by a factor of 1-p. This corresponds to inserting a Pauli Y operator into the circuit with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliZDamping-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliZDamping","text":"PauliZDamping(qind::Int)\n\nA Pauli-Z noise damping acting on the qubit at index qind. If p is provided, this returns a frozen gate with that damping strength. Will damp Z Paulis by a factor of 1-p.  This alone is not a valid quantum channel.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.PauliZNoise-Tuple{Int64}","page":"Gates","title":"PauliPropagation.PauliZNoise","text":"PauliZNoise(qind::Int)\nPauliZNoise(qind::Int, p::Real)\n\nA Pauli-Z noise channel acting on the qubit at index qind. If p is provided, this returns a frozen gate with that noise strength. Will damp X and Y Paulis equally by a factor of 1-p. This corresponds to inserting a Pauli Z operator with probability p/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#Misc","page":"Gates","title":"Misc","text":"","category":"section"},{"location":"api/Gates/#PauliPropagation.TGate-Tuple{Integer}","page":"Gates","title":"PauliPropagation.TGate","text":"TGate(qind::Integer)\n\nReturns a T gate acting on qubit qind. It acts on qubit qind like a PauliRotation(:Z, qind) with angle π/4.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.TransferMapGate","page":"Gates","title":"PauliPropagation.TransferMapGate","text":"TransferMapGate(transfer_map::Vector{Vector{Tuple{PauliStringType,CoeffType}}}, qinds::Vector{Int})\n\nA non-parametrized StaticGate defined by a transfer map acting on the qubits qinds. Transfer maps can be constructed manually or generated via totransfermap().\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.TransferMapGate-Tuple{AbstractMatrix, Any}","page":"Gates","title":"PauliPropagation.TransferMapGate","text":"A constructor for TransferMapGate that accepts matrix representations in the 0/1 basis or the Pauli basis (a PTM).\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.tomatrix-Tuple{TGate}","page":"Gates","title":"PauliPropagation.tomatrix","text":"tomatrix(gate::TGate)\n\nCompute the unitary matrix for a TGate. The returned unitary is returned in Schrödinger picture form. \n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#Frozen-Gates","page":"Gates","title":"Frozen Gates","text":"","category":"section"},{"location":"api/Gates/#PauliPropagation.FrozenGate","page":"Gates","title":"PauliPropagation.FrozenGate","text":"FrozenGate(gate::ParametrizedGate, parameter::Number)\n\nA StaticGate that wraps a ParametrizedGate with a fixed parameter. These are used to fix the parameter of ParametrizedGate at the time of circuit construction. This can be convenient but might exclude this parameter from being, e.g., differentiated by external libraries.\n\n\n\n\n\n","category":"type"},{"location":"api/Gates/#PauliPropagation.freeze-Tuple{Any, Any}","page":"Gates","title":"PauliPropagation.freeze","text":"freeze(gates::Vector{Gate}, parameters::Vector{Number})\n\nReturns a vector of Gates where ParametrizedGates are frozen with their parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Gates/#PauliPropagation.freeze-Tuple{ParametrizedGate, Number}","page":"Gates","title":"PauliPropagation.freeze","text":"freeze(gate::ParametrizedGate, parameter::Number)\n\nReturns a FrozenGate wrapping the gate with the fixed parameter.\n\n\n\n\n\n","category":"method"}]
}
